## Java--基础编程

JAVA语言的核心

### Day 00 编程入门

#### 学习的原则

* 学习编写代码的捷径：敲、狂敲
  * 一天的代码至少敲3遍：第一遍照着写，第二遍背着写，第三遍自己写
  * 三分看、七分练
* 先模仿好的编码习惯，有些东西需要背
* 每天30min复习整理
* 战略上藐视，战术上重视

艾宾浩斯遗忘曲线

### Day 01 Java语言概述

#### Roadmap

第一阶段：30天、Java基础、MySQL、JDBC等<span style="color:red">**（May 18, 2021 -- ）**</span>

第二阶段：15天、JavaWeb、HTML基础与CSS、XML与Tomcat、JSP等（组件）

第三阶段：16天、JavaEE框架、Spring、SpringMVC、MyBatis、Linux等

所谓框架：常用组件的集合，封装、使用组件开发效率比较低

互联网众筹项目：15天、规模不小，但是略掉重复性的功能滤掉了

第四阶段：15天、JaveEE高级、IDEA开发工具、Git与GitHub、MySQL高级、Nginx反向代理、Docker

电商项目：15天、电商项目包含其他各门类的业务场景的影子

电商项目总结与拓展：3天

在线教育项目：12天

总记127天左右，一周6天，共20个周左右

May 18, 2021 ---20 weeks---> Sep 14, 2021

#### Java学习

![Java知识图谱](/Users/chris/Coding Bootcamp/Notes/Backend/00. Java基础/知识图谱.png)

笔记不要太详细，概要记重要的是过程。

培养兴趣：两个周左右的时间建立编程的feel，敲、狂敲

#### 软件开发

软件有系统软件和应用软件之分、人机交互方式有GUI和CLI之分

#### 计算机编程语言简介

粗浅分为三代：

1. 机器语言：二进制代码

2. 汇编语言：助记符

3. 高级语言：可以分为两个阶段

   3.1. 面向过程

   3.2. 面向对象

#### Java语言概述

* SUN（Stanford University Network）公司开发的
  * Java小程序（applet）可以嵌入HTML当中，在Web浏览器中运行
* 后台开发：Java、PHP、Python
  * Java体量大，开发周期慢：绝对主力，首选语言
  * Python有替换PHP的趋势，开发周期短：一两个人两三个月也就搭起来了
  * Go语言、据说有Java的开发效率和C/C++的运行效率
  * Node.js
* Java简史
  * Java地名，是个岛，盛产咖啡
  * 1991年以Oak命名
  * 1996年，发布JDK 1.0
  * 2004年，发布JDK1.5，有突破性的重要版本，改名为JDK5.0
  * 2005年，J2SE -> JavaSE; J2EE -> JavaEE; J2ME -> JavaME
  * 2009年，SUN公司被Oracle公司收购了，74亿美元
  * 2014年，发布JDK 8.0，继JDK5.0以来变化最大的版本
* Java技术体系平台
  * JavaSE：桌面级应用，现在基本上已经不会出现了
  * JaveEE：企业级的应用Servelt、JSP
* Java语言的诞生
  * 类C语言、纯粹的面向对象语言
  * 舍弃C语言中容易引起错误的指针
  * 增加了垃圾回收器

#### Java语言运行机制和运行过程

Java语言特点：

1. 面向对象：

   1.1. 两个基本概念：类、对象

   1.2. 三大特性：封装、继承、多态

2. 健壮性：

   2.1. 吸收C/C++优点，舍去影响健壮性的部分（指针，申请、释放内存）

3. 跨平台性：

   3.1. 跨平台性：“Write once， Run anywhere”

   3.2. 原理： JVM安装好，JVM就负责Java程序在系统中的运行

4. Java核心机制：

   4.1. JVM

   4.2. 垃圾回收

#### Java语言的环境搭建：

* JDK（Java Development Kit Java开发工具包）

  * 给Java开发人员使用，包含JRE
  * 开发工具包括：编译工具javac，打包工具jar等

* JRE（Java Runtime Environment Java运行时环境）

  * 如果想运行开发好的Java程序，只需要JRE
  * Java程序需要的核心类库

* 三者关系：

  * Java 8.0![Java 8.0](/Users/chris/Coding Bootcamp/Notes/Backend/00. Java基础/Java8.0_platform.jpg)
  * 简化版![简化版](/Users/chris/Coding Bootcamp/Notes/Backend/00. Java基础/JVM,JRE,JDK.png)

* 我的环境：

  * OS: macOS 11.3 (20E232) Big Sur
  * JDK路径:
    * /Users/chris/Library/Java/JavaVirtualMachines/azul-1.8.0_282/Contents/Home
    * /Users/chris/Library/Java/JavaVirtualMachines/azul-1.8.0_292/Contents/Home
  * `JAVA_HOME`：bin目录的上层目录。这也是一个约定的变量，通常指JRE目录。上面的两个都可以事JAVA_HOME
    * 其实大部分Java程序不需要JDK，而是只需要其子集JRE，所以很多程序也会去取这个变量来用。
  * 为什么需要配置环境变量？
    * 希望在任何路径下都能够执行相应的程序

* HelloWorld

  ```java
  class HelloWorld{
    public sttic void main(String[] args){
      System.out.println("Hello World!");
    }
  }
  ```

* 源文件（.java文件）--javac编译--> 字节码文件（bytecode .class文件）--java运行-->结果

  * Windows路径名不是区分大小写
  * classpath：class文件的路径，不要配

#### Java注释  Comments

​	提高代码可读性、不参与运行，单行注释和多行注释的主要作用都是这样，方便别人也方便自己；另外也可以用来调试

##### 单行注释

```java
class HelloWorld{
  //单行注释
  public sttic void main(String[] args){
    System.out.println("Hello World!");
  }
}
```



##### 多行注释

```java
class HelloWorld{
  /*多行注释
  好多好多行
  */
  public sttic void main(String[] args){
    System.out.println("Hello World!");
  }
}
```

提高代码可读性、不参与运行，单行注释和多行注释的主要作用都是这样，方便别人也方便自己；另外也可以用来调试

##### 文档注释（Java特有）

```java
/**

文档注释，可以被javadoc解析的
@author fscj
@version v1.0
这是我重新起航的第一个Java程序，非常开心

*/
public class HelloWorld{
  /*多行注释
  好多好多行
  */
  public sttic void main(String[] args){
    System.out.println("Hello World!");
  }
}
```

```shell
javadoc -d DIR_NAME -author -version HellowWOrld.java
```

* 注意：多行注释不能嵌套，很简单的原理

#### Java API 文档

CHM是Windows上用的，macOS上再说吧，不行就看英文文档

#### Java 类和public 类

* 在以一个Java源文件中，可以声明多个`class`但是，只能有一个生命为`public`
* 而且要求声明为`public`的类，类名必须等于（源）文件名

#### Java编码习惯以及IDE说明

* 正确的注释和注释风格
  * 使用文档注释来注释整个类或整个方法
  * 如果注释方法中的某一个步骤，使用单行或者多行注释
* 一个`tab`进行缩进、运算符两边各加一个括号增强可读性
* 常用IDE，Eclipse和IntelliJ IDEA

---

Here is May 18, 2021

### Day 02 Java基本语法

#### 关键字和保留字

##### keyword定义

被Java语言赋予了特殊含义，用做专门用途的字符串。

* 特点：所有关键字都是小写的
* `true`, `false`,`null`严格意义上不算关键字，但还是当关键字来用。意思是自己定义标识符的时候还是不要用这些字

##### reserved word定义

现有Java版本尚未使用，但以后版本可能会作为关键字使用的。意思是自己定义标识符的时候还是不

* `goto`,`const`



#### 标识符

* Identifier: Java对各种变量、方法和类等要素命名时使用的字符序列成为标识符
  * 凡事自己起名的都叫标识符
* 规则：
  * `a-z | A-Z | 0-9 | _ | $`
  * 数字不能开头
  * 不能事关键字或者保留字，但是可以包含
  * Java中严格区分大小写，长度无限制
  * 标识符不能包含空格
* 规范：
  * 包名：多单词组成是所有字母都小写：`xxxyyyzzz`
  * 类名、接口名：大驼峰：`XxxYyyZzz`
  * 变量名、方法名：小驼峰：`xxxYyyZzz`
  * 常量名：所有字母大写，多单词时用下划线连接：`XXX_YYY_ZZZ`
* 使用meaningful的标识符，见名知意

#### 变量

* 变量的概念

  * 内存中的一个存储区域
  * 该区域的数据可以在同一类型范围内不断变化
  * 是程序中最基本的存储单元，包含**类型**、**名称**和**存储的值**

* 变量的作用

  * 在内存中存储数据

* 注意：

  * Java中每个变量必须先声明，后使用
  * 使用变量名访问数据
  * 作用域：一对大括号内`{}`
    * 变量只在其作用域内有效
    * 同一个作用域内不能出现同名变量

* 举例：

  ```java
  class VariableTest{
    public static void main(String[] args){
      //变量的定义
      int myAge = 12;
      //变量的使用
      System.out.println(myAge);
      //变量定义可以分为声明和赋值两步
      int myNumber;
      myNUmber = 10001;
    }
    
  }
  ```

* 变量的分类

  * 8种基本数据类型primitive type

    * 数值型

      * 整数型`short`,`int`,`long`,`byte`

      * 浮点型`float`,`double`

        ```java
        class VariableTest
          //基本数据类型的使用
          public static void main(String[] args){
          /* 整数型
          byte 8位 一个字节
          short 16位 两个字节
          int 32位 四个字节 表示范围最高约21亿
          long 64位 八个字节 声明时以"l"或者"L"结尾，不加的话，在数值不超过int型表达范围的时候编译也能通过
            通常使用 int 型
          */
          long l1 = 23123123l;
        
          /* 浮点型
          float 4字节 声明时以"f"或者"F"结尾，不加编译失败
          doulbe 8字节
          跟整型比起来，占用同样的存储空间，但是表示的范围也大，还带小数点，但是精度不行
          通常使用 double 型
          */
          double d1 = 1234.4;
          float f1 = 1234.5f;
          
          /* 字符型
          char 1字符=2字节 通常用一对单引号，内部不能写两个字符
          通常使用 double 型
          */
          char ch1 = 'a';
          
          //char ch2 = 'AB'; 编译不通过
          }
          
        }
        ```

    * 字符型`char` ，表示方式：

      * 声明一个字符`char ch1 = 'a';`必须是一个字符，空的不行`char ch2 = '';`编译失败
      * 转义字符`\n`,`\t`等
      * `Unicode` 值 `\u0123`
      * 字符集：计算机内部2进制和字符之间的对应关系，
        * 最早的就是`ASCII`码，其中`'a'` 对应到 `97`
        * `Unicode`要解决互联网发达以后不同国家的字符集之间通信的问题
        * `UTF-8`后面都用这个

    * 布尔型 `boolean`

  * 基本类型之间的运算规则：
    前提：不包含`boolean`，所以是7种数据类型之间的转换

    * 自动类型提升：当容量小的数据类型和容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。此时的容量大小指的是表示数的范围的大小，不是存储范围的大小
      `byte / char / short / int --> long  --> float --> double`
      特别的当`byte,char,short`三种做运算的时候，结果为`int`，即便是`byte + byte`结果也是`int`
    * 强制类型转换：自动类型提升运算的逆运算`int1 = (int) d1;//截断操作`

  * 3种引用数据类型reference type

    * 类`Class` 字符串`String` 属于这类
    * 接口`Interface`
    * 数组`[]`

  * 初见`String`类型

    * `String`，中文名字叫字符串，属于引用数据类型
    * 申明时用一对双引号`String str1 = "Hellow World";`
    * `String`类型可以和8种基本数据类型的变量做连接运算，且只能是连接运算。
      * `String str = "Hello World" + 1234;`，可见运算结果仍然是`String`类型

    ```java
    //练习1
    char c = 'a';
    int num = 10;
    String str = "hello";
    
    System.out.println(c + num + str);//"a10hello"!!!正确答案"107hello"
    System.out.println(c + str + num);//"ahello10"
    System.out.println(c + (num + str));//"ahello10"
    System.out.println((c + num) + str);//"107hello"
    System.out.println(str + num + c);//"hello10a"
    
    //练习2
    System.out.println("*   *");//OK
    System.out.println('*' + 't' + '*');//NOT OK
    System.out.println('*' + "t" + '*');//OK
    System.out.println('*' + 't' + "*");//NOT OK
    System.out.println('*' + ('t' + "*"));//OK
    ```

    

  ---

  Here is May 19, 2021

### Day 03 Java基本语法

#### 每日一考

1. 标识符的命名规则有哪些？
   26个字母大小写,$, _,[0-9]
   数字不能开头
   严格区分大小写
   不能是关键字和保留字，但是可以包含

2. 标识符的命名规范有哪些？
   包名：全小写
   类、接口名：大驼峰
   变量、方法：小驼峰 
   <span style="color:red">常量名，全大写，下划线分割</span>

3. Java变量找数据类型怎么分，并指出Java的基本数据类型有哪8种，并指出各自占用的内存空间大小
   基本数据类型：
   整型：`byte`，1个字节;`short`，2个字节;`int`，4个字节;`long`，8个字节;
   浮点型：`float`，4个字节;，`double`，8个字节;
   布尔型：`boolean`，1个字节，具体体层转化成`int`但是不同管
   字符型：`char`，2个字节
   引用数据类型：3种：类`Class`、接口`Interface`、数组`[]`

4. 说明基本数据类型之间的自动类型提升的运算规则

   按照该类型所能表示的数字范围的递增顺序
   `byte/char/short --> int --> long --> float -->double`

   特殊规则：前三种，之间运算，结果都是`int`；默认整型是`int`；默认浮点型是`double`

5. 说明基本数据类型之间的强制类型转换的使用规则和强转可能出现的问题。
   用法：`(int)`括号加类型
   问题：丢失数据精度，或者编译失败

#### 运算符

* 算数运算符

  * 单元：`+,-,++,--`
  * 双元：`+,-,*,/,%`
  * 连接运算符：`+`

  ```java
  class ArithmeticTest{
    
    public static void main(String[] args){
      /* 算数运算符的说明
      
      */
      // % 模运算符
      //如果出现负数，那么结果的符号与被模数相同
      int m1 = 12;
      int n1 = 5;
      System.out.println("m1 % n1 = " + m1 % n1);//2
  		int m1 = -12;
      int n1 = 5;
      System.out.println("m1 % n1 = " + m1 % n1);//-2
      int m1 = 12;
      int n1 = -5;
      System.out.println("m1 % n1 = " + m1 % n1);//2
      int m1 = -12;
      int n1 = -5;
      System.out.println("m1 % n1 = " + m1 % n1);//-2
    }
    /* 自增自减运算符不会改变数据的类型 */
    	short s1 = 10;
    	// short s1 = s1 + 1;//编译失败
    	short s1 = (short)(s1 + 1);//正确，但是相对低效
    	s1++;
    
    	byte b1 = 127;
    	byte++;
    	System.out.println("b1 = " + b1);//猜测：-128，猜测正确
  }
  ```

  ```java
  /*
  练习题：给定一个三位数，输出它的百位数，十位数，个位数：
  */
  
  class AriExer{
    
    public static void main(){
      int num = 187;
      
      int ge = num % 10;
      // int shi = (num/10) % 10;//这个不对
      int shi = num % 100 / 10;
      int bai = num / 100;
    }
    
    
    
  }
  ```

  

  题外话：代码量是评判程序员好坏的基本指标，干就完事儿了；代码积累过程中解决了多少个bug

* 赋值运算符
  `=, +=, -=, /=, %=`，支持连续赋值

  ```java
  //连续赋值的两种情况
  int i1, j1;
  i1 = j1 = 10;
  
  int i2 = 10, int j2 = 20;
  
  //复合赋值运算符不会改变变量的数据类型
  short s1 = 10;
  s1 = s1 + 2;//编译不通过
  s1 += 2;
  
  //开发中实现一个变量+2的操作 int num = 10;
  //方法1
  num = num + 2;
  //方法2(推荐)
  num += 2;
  
  //开发中实现一个变量+1的操作 int num = 10;
  //方法1
  num = num + 1;
  //方法2
  num += 1;
  //方法3（推荐）
  num++;
  
  //练习题：
  int i = 1;
  i *= 0.1;
  System.out.println(i);//0 注意，复合赋值运算不会改变数据类型
  
  //练习题：
  int n = 10;
  n += (n++) + (++n);//推理：25， 推理错误！
  /* 推导
  1: (n++)==> 10 n ==> 11;
  2: (++n)==> 12 n ==> 13;
  3: 10 + 12 ==> 22;
  4: 13 + 22 ==> 25;
  */
  
  /* 正确推导
  1: 10 + () + ()
  2: (n++)==> 10 n ==> 11;
  3: (++n)==> 12 n ==> 13;
  4: 13 + 22 ==> 25;
  */
  ```

  

* 比较（关系）运算符
  `==, !=, >, <, >=, <=, instanceof`
  要注意`==`和`=`的区分

* 逻辑运算符
  `&, &&, |, ||, !, ^`
  只能适用于布尔类型的变量,"单与"和"双与"的区别：

  ```java
  class LogicTest {
    public static void main(String[] args){
      //区分& 和 &&
      boolean b1 = false;
      int num1 = 10;
      if(b1 & (num1++ > 0)){
        System.out.printlin("我现在在北京");
      }else{
        System.out.printlin("我现在在南京");
      }
      
      System.out.println("num1 = " + num1);//11
      
      boolean b2 = false;
      int num2 = 10;
      if(b2 && (num2++ > 0)){
        System.out.printlin("我现在在北京");
      }else{
        System.out.printlin("我现在在南京");
      }
      System.out.println("num2 = " + num2);//10，说明num2没有进行++运算
    }
    
  }
  ```

  

* <span style="color:purple;">位运算符</span>
  `<<, >>, >>>, &, |, ^, ~`，注意，没有`<<<`
  位移运算都是对整数来说的，区分`&, |, ^`和逻辑运算符就看操作数的数据类型

  ```java
  /* 练习：交换两个变量的值
  
  */
  int num1 = 10;
  int num2 = 20;
  
  //两个只能站一个人的小岛，甲乙两人互换位置
  //好处：不用定义临时变量
  //弊端：有可能相加结果超出存储范围。局限性：只能作用在数值型的变量上面
  num1 = num1 + num2;
  num2 = num1 - num2;
  num1 = num1 - num2;
  
  //位运算符的方式，厉害了
  num1 = num1 ^ num2;
  num2 = num1 ^ num2;
  num1 = num1 ^ num2;
  ```

  

* 三元运算符
  `(condition) ? exp1 : exp2`
  表达式1和表达式2要求是一致的，三元运算符可以嵌套

* 关于三元运算符和`if-else`语句

  * 关系：能用三元运算符写的都可以用`if-else`语句来写，反之不成立
  * 取舍：如果既可以用三元运算符又可以用`if-else`语句，优先tenary，原因是简洁，执行效率高

#### 流程控制

来源于工业上的生产流程，代码的执行也是个流程。实际生产中需要用到如下三种基本流程结构

* 顺序结构

  * 程序从上到下顺序执行

* 分支结构

  * 三种`if-else`
    
    ```java
    /* 第一种*/
    if (exp) {}
    /* 第二种 二选一*/
    if (exp1){...}else{...}/* 第三种 多选一*/
    if (exp1){...}
    else if ()
    {...}
    ...
    else{}
    ```
    
  * `switch-case`结构
    
    ```java
    /* 
    switch 后面跟的exp只能是下列6种中的一个：
    byte, short, char, int, 枚举类型（JDK 5.0新增）, String类型(JDK 7.0新增)
    */
    switch(exp){
        
      case const0:
        System.out.println('Zero');
        break;
      case const1:
        System.out.println('One');
        break;
      default:
        System.out.println('Other');
    }
    ```

### Day 04 Java基本语法

#### 每日一考

1. `&`和`&&`的异同
     相同点：运算结果相同、都会执行左边的运算数（表达式）
     不同点：当`&&`左边的操作数已经是`false`的情况下，`&&`右边的表达式不会被计算

2. 程序输出题：

     ```java
     class OperatorTest {
     	public static void main(String[] args) {
     		boolean x = true;
     		boolean y = false;
     		short z = 40;
     		if ((z++ == 40) && (y = true)) {
     			z++;
     		}
     		if ((x = false) || (++z == 43)) {
     			z++;
     		}
     		System.out.println("z = " + z);
     	}
     }
     ```

     输出结果为：`z = 44`

3. 定义三个int型变量并赋值，使用三元运算符或者if-else获取这三个数中的较大数的实现

     ```java
     int n1 = 10, int n2 = 12; int n3 = 4;
     // 三元运算符
     int max;
     max = n1 > n2 ? (n1 > n3 ? n1 : n3) : n2; 
     // if-else
     int max;
     if (n1 >= n2 && n1 >= n3){
       max = n1;
     }else if (n1 < n2 && n2 >= n3) {
       max = n2;
     }else{
       max = n3;
     }
     ```

     

4. 编写程序，声明2个double型变量并赋值。判断第一个数大于10.0，且第2个数小于20.0，打印两数之和。否则，打印两数的乘积。

     ```java
     double d1 = 12.3, double d2 = 3.14;
     if (d1 > 10.0 && d2 < 20.0){
       System.out.println("d1 + d2 = " + (d1 + d2));
     }else{
       System.out.println("d1 * d2 = " + (d1 * d2));
     }
     ```

     

5. 交换两个变量值的代码的实现

     ```java
     String s1 = "北京";
     String s2 = "南京";
     String temp;
     temp = s1;
     s1 = s2;
     s2 = temp;
     ```

#### Scanner类的使用

```java
import java.util.Scanner;

class ScannerTest{
  
  public static void main(String[] args){
    
    Scanner scan = new Scanner(System.in);
    
    Systemout.println("请输入姓名");
    String name = scan.next();
    System.out.println(name);
    
    Systemout.println("请输入年龄");
    int age = scan.nextInt();
    System.out.println(age);
    
    Systemout.println("请输入年龄");
    double weight = scan.nextDouble();
    System.out.println(weight);
    
    Systemout.println("你是否相中我了呢？(true/false)");
    boolean isLove = scan.nextBoolean();
    System.out.println(isLove);
    
    //原生没有char型，但是可以先接受为String，后面用String的charAt()方法
    
    System.out.println("输入你的性别：（男/女）");
    String gener = scan.next();
    char genderChar = gener.charAt(0);
    Syste.out.println(genderChar);
  }
  
}
```

#### if-else例题

例题1: 键盘输入小鹏的成绩，给奖励

```java
import java.util.Scanner;

class IfTest{
  
  public static void main(String[] args){
    
    Scanner scan = new Scanner(System.in);
    
    Systemout.println("请输入岳小鹏期末成绩：(0,100]");
    
    int score = scan.nextInt();
    
    if(score == 100){
      System.out.println("BMW");
    }else if(score > 80 && score <= 99){
      System.out.println(iPhone xs max);
    }else if(score >= 60 && score <= 80){
      System.out.println("iPad");
    }else{
        System.out.println("Nothing");
      } 
  }
  /* 
  说明：
  >如果多个条件表达式之间是“互斥”关系，没有交集，判断和执行语句的顺序可以随便换，无所谓
  >如果多个条件表达式之间有交集，需要根据实际情况考虑
  >如果多个条件表达式之间是包含关系，通常情况下，范围小的写在上面
  */
}
```

例题2：输入三个数，排序

```java
import java.util.Scanner
  /* 
  从键盘输入三个整数用if-else排序，从小到大排序
  */
class IfTest2{
  
  public static void main(String[] args){
    
    Scanner scan = new Scanner(System.in);
    
    Systemout.println("请输入第一个整数：");
    int n1 = scan.nextInt();
    Systemout.println("请输入第二个整数：");
    int n2 = scan.nextInt();
    Systemout.println("请输入第三个整数：");
    int n3 = scan.nextInt();
    
    if (n1 > n2){
      if (n3 >= n1){
        System.out.println(n2 + "," + n1 + "," + n3);
      }else if(n3 <= n2){
        System.out.println(n3 + "," + n2 + "," + n1);
      }else{
        System.out.println(n2 + "," + n3 + "," + n1);
      }
    }else{
      if (n3 >= n2){
        System.out.println(n1 + "," + n2 + "," + n3);
      }else if(n3 <= n1){
        System.out.println(n3 + "," + n1 + "," + n2);
      }else{
        System.out.println(n1 + "," + n3 + "," + n2);
      }
      
    }
  }
  /* 
  说明：
  >如果多个条件表达式之间是“互斥”关系，没有交集，判断和执行语句的顺序可以随便换，无所谓
  >如果多个条件表达式之间有交集，需要根据实际情况考虑
  >如果多个条件表达式之间是包含关系，通常情况下，范围小的写在上面
  */
}
```

**重点：**`if-else`结构可以嵌套，实际开发中很少会用到超过3层的嵌套`if-else`

#### switch-case例题

```java
/* 
通过键盘输入month 和date，输出2019年的第几天
目的是展示Break不是一定要写的
*/
import java.util.Scanner;
class SwitchCaseTest2{
  
  public static void main(String[] args){
    Scanner scan = new Scanner(System.in);
    System.out.println("请输入2019年的month：");
    int month = scan.nextInt();
    System.out.println("请输入2019年的day：");
    int day = scan.nextInt();
    int sumDays = 0;
    switch(month){
      case 12:
        sumDays += 30;
      case 11:
        sumDays += 31;
      case 10:
        sumDays += 30;
      case 9:
        sumDays += 31;
      case 8:
        sumDays += 31;
      case 7:
        sumDays += 30;
      case 6:
        sumDays += 31;
      case 5:
        sumDays += 30;
      case 4:
        sumDays += 31;
      case 3:
        sumDays += 28;
      case 2:
        sumDays += 31;
      case 1:
        sumDays += day;
    }
    System.out.println("2019年" + month + "月" + day + "日是2019年的第" + sumDays + "天");
  }
}
```

凡可以用`switch-case`写的分支结构都可以用`if-else`写，反之不成立

#### 循环结构

* 循环结构的四个要素

  1. 初始化条件
  2. 循环条件 ==>是`boolean`类型
  3. 循环体
  4. 迭代条件

* `for`循环的结构

   ```java
   for(int i = 1; i < 10; i++){
     /* 循环体 */
   }
   
   /* 写程序循环1到150自然数，如果是3的倍数加上foo 如果是5的倍数打印biz 如果是7的倍数baz*/
   for(int i = 1; i < 151; i++){
     
     System.out.print(i + " ");
     if (i % 3 == 0){
       System.out.print("foo");
     }
     if (i % 5 == 0){
       System.out.print("biz");
     }
     if (i % 7 == 0){
       System.out.print("baz");
     }
     System.out.println();
   }
   ```

  真正工作的时候代码量没有现在这么大，可能一天是200--300行，也就是说我现在学习的过程中，一天至少要敲500行代码。我猜的

---

Here is May 22, 2021

### Day 05 Java基本语法

#### 每日一考

1. `switch` 后面使用的表达式可以是哪些类型的数据？
   6种：`byte, short, int, char, 枚举类型(JKD 5.0), String(JKD 7.0)`

2. 使用`switch`语句改写下列`if`语句：

   ```java
   int a = 3;
   int x = 100;
   if(a == 1)
     x += 5;
   else if(a == 2)
     x += 10;
   else if(a == 3)
     x += 16;
   else
     x += 34;
   
   //改写
   switch(a)
     case 1:
     x += 5;
   	break;
   	case 2:
     x += 10;
   	break;
   	case 3:
     x += 16;
   	break:
   default:
     x += 34;
   
   
   ```

   

3. 谈谈三元运算符、`if-else`语句、`switch-case`结构的使用场景的理解
   `if-else`语句是最通用的，意思是能用三元的和能用`switch-case`的都能用`if-else`，反之不成立
   如果不是特别麻烦尽可能使用三元或者`switch-case`的话，因为执行效率稍微高一点点

4. 如何从控制台获取`String`和`int`型的变量，并输出？

   ```java
   import java.util.Scanner;
   Scanner scan = new Scanner(System.in);
   
   String str = scan.next();
   int n1 = scan.nextInt();
   ```

   

5. 使用`for`循环便利100以内的奇数，并计算所有的奇数的和并输出

   ```java
   int sum = 0;
   for(int i = 1; i < 101; i++){
     if (i % 2 == 1){
       sum += i;
     }
   }
   System.out.println("100以内所有奇数的和是 " + sum);
   ```

#### for循环例题

```java
/*
题目：输入两个正整数m和n，求其最大公约数和最小公倍数
说明：break关键词的使用
*/
import java.util.Scanner;

class ForTest{
  
  public static void main(String[] args){
    
    Scanner scan = new Scanner(System.in);
    System.out.println("请输入第一个正整数");
    int m = scan.nextInt();
    System.out.println("请输入第二个正整数");
    int n = scan.nextInt();
    
    //最大公约数：获取两个数中的最小值，从它开始往下走，找到（公约数）就停
    for(int i = (m < n )? m : n; i>0; i--){
      if (m % i == 0 && n % i == 0)
        System.out.println("最大公约数为：" + i);
      	break;
    }
    //最大公约数：获取两个数中的最小值，从它开始往下走，找到（公约数）就停
    int max = ( m < n) ? n : m;
    for (ing i = max;i <= m * n;i++){
      if (i % m == 0 && i % n == 0){
        System.out.println("最小公倍数为：" + i);
        break;
      }
    }
    
    
  }
  
}
```

#### while循环

```java
/*
while循环依然是有四个要素
1. 初始化条件
2. 循环条件 ==>是`boolean`类型
3. 循环体
4. 迭代条件

1
while(2){
3;
4;
}
*/
int i = 0;
while(i<100){
  //do something
  i++;
}
```

`for`循环和`while`循环是可以互相转换的。如果一定要说区别的，`while`循环指标（初始化条件的作用域）`i`在`while`循环外面也有用

#### do-while循环

```java
/*
do-while循环依然是有四个要素
1. 初始化条件
2. 循环条件 ==>是`boolean`类型
3. 循环体
4. 迭代条件
*/
1
do{
3;
4;
}while(2)
```

循环体至少会执行一次，这是跟`while`的主要区别。在实际开发中，还是`for`循环和`while`循环使用的 多一些。

#### 循环嵌套例题

```java
/* 
输出100以内的所有质数
从2开始到这个数-1开始，都不能被这个数整除
*/

class PrimeNumberTest{
  
  public static void main(String[] args){
    
    for (int i = 2; i < 101; i++){//遍历100以内自然数
      boolean ifPrime = true;
      
      for (int j = 2; j < i; j++){//j: 去被i除
        if (i % j == 0){
          isPrime = false;
        }
        
      }
      if(isPrime){
        System.out.println(i);
      }
    }
    
  }
}
```

写成上面这样，问题解决了但是效率比较低，下面考虑优化

```java
/* 
输出100以内的所有质数，以及优化
Java程序计时
*/

class PrimeNumberTest{
  
  public static void main(String[] args){
    boolean ifPrime = true;
    long start = System.currentTimeMillis();
    
    for (int i = 2; i < 101; i++){//遍历100以内自然数
      /* j 从 2 只需要到 sqrt i 即可*/
      for (int j = 2; j < Math.sqrt(i); j++){//j: 去被i除
        if (i % j == 0){
          isPrime = false;
          /* 优化一：这里加个break 对本身非质数的自然数是有效的*/
          break;
        }
      }
      if(isPrime){
        System.out.println(i);
      }
      //reset isPrime
      isPrime = true;
    }
    long end = System.currentTimeMillis();
    
    System.out.println("所花费的时间为" + (end - start) / 1000);
  }
}
```

|            | 使用范围                    | 循环中使用的作用 | 相同点                     |
| ---------- | --------------------------- | ---------------- | -------------------------- |
| `break`    | `switch-case`<br />循环结构 | 结束当前循环     | 关键字后面不能声明执行语句 |
| `continue` | 循环结构                    | 结束当次循环     | 关键字后面不能声明执行语句 |

```java
/*
带标签的break和continue语句
*/
label:for(int i = 1; i < 5; i++){
  
  for(int j = 1; j < 10; j++){
    
    //...
    break label;
    
  }
}

//直接来一个质数输出的实现方法二
class PrimeNumberTest2{
  
  public static void main(String[] args){
    long start = System.currentTimeMillis();
    
    label:for (int i = 2; i < 101; i++){//遍历100以内自然数
      /* 优化二 j 从 2 只需要到 sqrt i 即可*/
      for (int j = 2; j < Math.sqrt(i); j++){//j: 去被i除
        if (i % j == 0){
          continue label;
        }
      }
      //能执行到这里的都是质数
    }
    long end = System.currentTimeMillis();
    
    System.out.println("所花费的时间为" + (end - start) / 1000);
  }
}
```

---

here is May 23, 2021

#### 项目一

```java
class FamilyAccount{
  
  public static void main(String[] args){
    
    boolean isFlag = true;
    
    String details = "Income/Expense\tTotal\tAmount\tRemark\n";//Used for log use input
    //initial amount
    int balance = 1000;
    while(isFlag){
      
      System.out.println("------------Family Account------------\n");
      System.out.println("            1.\tDetails\n");
      System.out.println("            2.\tLog Income\n");
      System.out.println("            3.\tLog Expense\n");
      System.out.println("            4.\tQuit\n");
      
      //获取用户输入
      char selection = Utility.readMenuSelection();
      switch (selection){
        case '1':
          System.out.println("------------Account Summary------------");
          System.out.println(details);
          System.out.println("---------------------------------------");
          break;
        case '2':
          System.out.println("Enter income amount: ");
          int money = Utility.readNumber();
          System.out.print("Enter income detail: ");
          String info = Utility.readString();
          
          //process balance
          balance += money
          //process details
          details += ("income\t" + balance + "\t" + money + "\t" + info + "\n");
          
          System.out.print("------------Log Complete------------");
          break;
        case '3':
          System.out.println("Enter expense amount: ");
          int money = Utility.readNumber();
          System.out.print("Enter expense detail: ");
          String info = Utility.readString();
          
          //process balance
          if (balance >= money){
            balance -= money
          	//process details
          	details += ("expense\t" + balance + "\t" + money + "\t" + info + "\n");
            
          }else{
             System.out.print("------------Not Enough Blance------------");
          }

          
          System.out.print("------------Log Complete------------");
          break;
        case '4':
          System.out.println("Are you sure you want to quit? [Y/N]");
          char isExit = Utility.readConfirmSelecion();
          if (isExit == 'Y'){
            isFlag = false;
          }
      }
    }
    
  }
}
```



### Day 06 Eclipse与数组

#### 每日一考

1. 循环结构是如何最后退出循环的？有哪些不同情况，说明
   循环条件为`false`的时候、循环体内有`break`
   注意:`continue`不能算做结束循环，`return`和异常都会结束循环，但不是正常的方式

2. 程序题：

   ```java
   label: for (int i = 1; i <= 4; i++) {
   			for (int j = 1; j <= 10; j++) {
   				if (j % 4 == 0) {
   					continue label;
   				}
   				System.out.print(j);
   			}
   			System.out.println();
   }
   ```

   输出结果是：`123123123123`

3. 一个数如果恰好等于它的因子之和，这个数就称为"完数"。例如6=1＋2＋3。编程 找出1000以内的所有完数。（因子：除去这个数本身的其它约数）

   ```java 
   int factor = 0;
   for (int i = 1; i < 1001; i ++ ){
     
     for(int j = i; j <= i/2;j++){
       if (i % j == 0){
         factor += j;
       }
     }
     if ( i == factor ){
       
       System.out.println(i);
     }
       factor = 0;
   }
   ```

   

4. 说明break和continue使用上的相同点和不同点
   `break` 可以用在循环和`switch-case`但是`continue`只能用在循环结构中
   `continue`只能结束当次循环
   相同点：后面都不能再接语句了

5. 从控制台输出如下结构

   ```java
   /*
   
   ******
   *****
   ****	
   ***	
   **	
   *
   
   */
   for(int i = 6; i > 0; i--){
     
     for(int j = i; j > 0; j --)
       System.out.print('*');
     System.out.prinln();
   }
   U+2387
   &#9658;
   ```

#### Hello Eclipse

* 透视图的设置，已搞定
* 用Eclipse编写Hello World程序，已搞定
* Windows 下的`alt + /`现在在Mac下没有搞定
  * 现在搞定了，需要把默认的`contenct assist 改成⎇+/`&#9095; 
* 导入已有的工程
  `File > Import > Gneral > Existing Projects into Workspace`
  牵扯到改名的问题
  改已经Workspace里面的：`refactor > rename `
* 查看源代码的问题:
  * 按住`command` 加鼠标点击就可以进入源码
  * `command + o`可以开启搜索文档
  * &#8984; 8984

#### 数组

* 数组Array，是多个 同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对数据进行统一管理
* 数组的相关概念
  * 数组名
  * 元素
  * 角标、下标、索引 index
  * 数组的长度：数组元素的个数、一旦确定不能修改
* 数组的特点：
  * 有序排列的
  * 数组属于引用数据类型的变量；数组的元素既可以是基本数据类型，也可以是引用数据类型
  * 创建数组的时候是在内存中开辟一块连续的空间，而数组名中引用的是这块连续空间的首地址
* 数组的分类：
  * 按照维数
  * 按照元素的类型：基本数据类型元素的数组，引用数据类型元素的数组

#### 一维数组的使用

1. 声明和初始化

   ```java
   int[] ids; //声明
   		
   //静态初始化:数组的初始化和数组元素的初始化同时进行
   ids = new int[] {1001,1002,1003,10004};
   
   //动态初始化:数组的初始化和数组元素的初始化分开进行
   String[] names = new String[5];//声明和初始化一起做了
   ```

   数组一旦初始化完成了，长度就确定了

2. 调用指定位置的元素

   ```java
   ids[0] = 1;
   
   names[names.length -1] = "Chris Jin"
   ```

   数据库的表索引/数据库表的列索引是从1开始的

3. 获得数组的长度

   ```java
   int[] arr = new int[10];
   len = arr.length;
   ```

   

4. 遍历数组

   ```java
   int[] arr = new int[10];
   for(int i = 0; i < arr.length; i++){
     //process arr[i];
   }
   ```

   

5. 数组元素默认初始化值

   ```java
   /*
   基本数据类型的默认初始化值：
   
   */		
   //整型：0
   int [] arr = new int[4];
   for(int i = 0; i < arr.length; i++) {
     System.out.println(arr[i]);
   }
   	System.out.println("****************");
   //浮点型：0.0
   float [] arr2 = new float[4];
   for(int i = 0; i < arr2.length; i++) {
     System.out.println(arr2[i]);
   }
   	System.out.println("****************");
   //字符型：'\u0000'
   char [] arr3 = new char[4];
   for(int i = 0; i < arr3.length; i++) {
     System.out.println(arr3[i]);
   }
   	System.out.println("****************");
   //布尔型：false
   boolean [] arr4 = new boolean[4];
   for(int i = 0; i < arr4.length; i++) {
     System.out.println(arr4[i]);
   }
   /*
   引用数据类型的默认初始化值：
   */
   
   //引用数据类型：null
   String[] str = new String[5];
   System.out.println(str[0]);
   ```

6. 内存解析
   内存的结构是由JVM规范规定的
   ![JVM内存解析](/Users/chris/Coding Bootcamp/Notes/Backend/00. Java基础/Memory_Structure.png)

#### 二维数组的使用

我们可以看成是一维数组 array1又作为另一个一维数组array2的元素而存 在。从数组底层的运行机制来看，其实没 有多维数组。

1. 声明和初始化

   ```java
   //静态初始化
   int[][] arr1 = new int[][]{{1,2,3},{4,5},{6,7,8}};
   //动态初始化
   String[][] arr2 = new String[3][2];
   String[][] arr2 = new String[3][];//这么写也行
   
   //前面的方括号位置几乎可以随便放
   int[] arr3[] = new int[3][];
   //类型推断
   int[] arr4[] = {{1,2,3},{4,5},{6,7,8}};
   
   System.out.println(arr2[1][0]);//报错
   arr2[1] = new int
   ```

   

2. 调用指定位置的元素`arr1[0][1] = 6;  `

3. 获得数组的长度`arr1.length`是3，`arr1[0].length`是3

4. 遍历数组

   ```java
   for(int i = 0; i < arr4.length; i++){
     for(int j = 0; i < arr4[i].length; j++)
       //process arr4[i][j];
   }
   ```

   

5. 数组元素默认初始化值

   ```java
   	String[][] arr2 = new String[3][5];
   	
   	System.out.println(arr2);//[[Ljava.lang.String;@2a139a55
   	System.out.println(arr2[0]);//[Ljava.lang.String;@15db9742
   	System.out.println(arr2[0][0]);//null
   	
   	String[][] arr1 = new String[3][];
   	
   	System.out.println(arr1);//[[Ljava.lang.String;@6d06d69c
   	System.out.println(arr1[0]);//null
   	System.out.println(arr1[0][0]);//java.lang.NullPointerException
   ```

   

6. 内存解析
   略，图在心中

### Day 07数组

#### 每日一考

1. 一维数组初始化的两种方式

   ```java 
   //静态初始化
   int[] arr1 = new int[] {123};
   //支持类型推断
   int[] arr1 = {123};
   //动态初始化
   int arr1[] = new int[3];
   ```

   

2. 二维数组初始化的两种方式

   ```java
   //静态初始化
   int[][] arr2 = new int[][]{{123,456},{7,8}}
   //支持类型推断
   int[][] arr2 = {{123,456},{7,8}}
   //动态初始化
   int[][] arr3 = new int[4][3];
   int[][] arr4 = new int[4][];
   ```

   

3. 遍历如下的二维数组`int[][] arr = new int[][]{{1,2,3},{4,5},{6,7,8}};`

   ```java
   for(int i = 0; i < arr.length; i++){
     for(int j = 0; j <arr[i].length; j++){
       //process arr[i][j];
     }
   }
   ```

   

4. 不同类型的一维数组元素的默认初始化值是多少
   `int,short,long: 0`；`float,double: 0.0`；`boolean: false`；`char: \U0000`；引用数据类型`null`

5. 一维数组的内存解析：

   ```java 
   String[] strs = new String[5];
   str[2] = "Tom";
   strs = new String[3];
   
   //Stack: strs = 0x1212; Heap: 0x1212--连续五个地址值--0x1213,0x1214,0x1215,0x1216,全是null
   //Stack: strs = 0x1212; Heap: 0x1214 变成 Tom，其实Tom在字符串常量池中，所以其实还是个地址值
   //Stack: strs = 0x2121; Heap: 0x2121--连续三个地址值--0x2122,0x2123,全是null
   ```

   

#### 数据结构浅谈

数据结构解决两种问题：

1. 数据与数据之间的逻辑关系：集合、一对一（链表）、一对多（树）、多对多（网络、地图）
2. 数据的存储结构：
   线性表：刻画一对一的关系，顺序表（数组）、链表、栈、队列（消息队列）
   树形结构：二叉树（B tree、B+tree）
   图形结构：

算法：没有边界，排序算法，搜索算法等

---

here is May 24, 2021

#### 数组练习题

1. `int[] x, y[];`的结果是`x`是`int`型一维数组，`y`是`int`型二维数组`int[] x; int[] y[];`

2. 杨辉三角形

   ```java
   package com.atguigu.exer;
   
   public class YangHuiTest {
   public static void main(String[] args) {
   	//1. 声明并初始化二维数组
   	int[][] yanghui = new int[10][];
   	//2. 给数组的元素赋值
   	for(int i =0; i < yanghui.length; i++) {
   		yanghui[i] = new int[i+1];
   		//首末元素，连续赋值
   		yanghui[i][0] = yanghui[i][i] = 1;
   		//给首末元素赋值
   		//if(i > 1) {
   		for(int j = 1; j < yanghui[i].length - 1; j++) {// j < i 是i错的！
   			yanghui[i][j] = yanghui[i-1][j] + yanghui[i-1][j-1];
   		}
   		//}去掉也可以
   	}
   	//3. 遍历二维数组
   	for(int i = 0; i < yanghui.length; i++) {
   		for(int j = 0; j < yanghui[i].length; j++) {
   			System.out.print(yanghui[i][j] + "\t");
   		}
   		System.out.println();
   	}
   }
   }
   ```

   

#### 常用算法

1. 数组元素赋值（杨辉三角、回姓数）

   ```java
   package com.atguigu.java;
   /*
   回形数
   */
   import java.util.Scanner;
   
   public class HuiXingShu1 {
   	public static void main(String[] args) {
   		Scanner scan = new Scanner(System.in);
   		
   		System.out.print("Please Enter the Size of the problem:");
   		int size = scan.nextInt();
   		
   		int[][] arr = new int[size][size];
   		
   		int l = 0, top = 0, state = 0;// left and top limit
   		int num = 1;//the next number to fill in
   		int r = size -1, bot = size -1; // right and bottom limit 
   		int row, col;// current position
   		row = col = 0;
   		
   		while(num <= size * size) {
   			System.out.println("State is: " + state);
   			switch(state) {
   			
   			case 0:
   				//going right
   				while(col <= r) {
   					arr[row][col] = num;
   					num++;
   					col++;
   				}
   				col = (col > r)?r : col;
   				top ++;
   				row ++;
   				System.out.println("row index: " + row + " column index: " + col);
   				break;
   			case 1:
   				//going down
   				while(row <= bot) {
   					arr[row][col] = num;
   					num++;
   					row++;
   				}
   				row = (row > bot)?bot : row;
   				r--;
   				col--;
   				System.out.println("row index: " + row + " column index: " + col);
   				break;
   			case 2:
   				//going left
   				while(col >= l) {
   					arr[row][col] = num;
   					num++;
   					col--;
   				}
   				bot--;
   				row--;
   				col = (col < l)?l : col;
   				System.out.println("row index: " + row + " column index: " + col);
   				break;
   			case 3:
   				//going up
   				while(row >= top) {
   					arr[row][col] = num;
   					num++;
   					row--;
   				}
   				row = (row < top)?top : row;
   				l++;
   				col++;
   				System.out.println("row index: " + row + " column index: " + col);
   				break;
   			
   			}
   			
   			//update state
   			state = (state + 1) % 4;
   
   			for(int i = 0; i < arr.length; i++) {
   				for(int j=0; j<arr[i].length;j++) {
   					System.out.print(arr[i][j] + "\t");
   				}
   				System.out.println();
   		
   			}
   			System.out.println("********");
   		}
   		
   		scan.close();
   		System.out.print("Stopped");
   }
   }
   ```

   

2. 求数值型数组中元素的最大值、最小值、平均数、总和等
   随机数`(int) (Math.random() * (max - min + 1)) + min`

3. 数组的复制、反转、查找（Linear Search; Binary Search）

   ```java
   //数组的复制
   int[] arr1, arr2;
   arr1 = {1,2,4,45,5};
   arr2 = new int[arr1.length];
   for(int i = 0; i < arr1.length; i++){
     arr2[i] = arr1[i];
   }
   
   //数组的反转
   //方式一：注意别i的终止条件，别搞两遍了
   for(int i = 0; i < arr1.length / 2 ; i++) {
     String temp = arr[i];
     arr[i] = arr[arr.length - i - 1];
     arr[arr.length - i -1] = temp;
   }
   //方式二
   for(int i = 0, j = arr.length; i < j;i++,j--) {
     String temp = arr[i];
     arr[i] = arr[j];
     arr[j] = temp;
   }
   
   	//Binary Search
   	//prerequisite: sorted list
   	boolean isNotFind = true;
   	int[] arr2 = new int[] {-99, -34, 2,3,4,5,6,7,1234,12567,79345};
   	int dest1 = -34;
   	int head = 0;//初始的首索引
   	int end = arr2.length;//初始的末索引
   	
   	while(head <= end) {
   		int middle = (head + end)/2;
   		if(dest1 == arr2[middle]) {
   			System.out.println("Find item " + dest1 + " at " + middle);
   			isNotFind = false;
   			break;
   		}else if (arr2[middle] > dest1){
   			end = middle -1;
   		}else {
   			head = middle + 1;
   		}
   		
   	}
   	if(isNotFind){
   		System.out.println("item not found");
   	}
   ```

   

4. 数组元素的排序算法
   时间复杂度，空间复杂度，稳定性
   内部排序：内存中搞定的
   外部排序：数据量比较大，需要借助外部存储设备才能搞定
   <span style="color:red;">冒泡、快排</span>需要会手写
   <span style="color:orange;">堆排序、和并归</span>需要知道

5. 算法的特征
   5.1 输入(Input)：0个或者有多个输入数据，这些输入必须有清楚的描述和定义
   5.2 输出(Output)：至少1个或多个结果
   5.3 有穷性(Finiteness)：在有限步骤内结束，并在可接受的时间范围内完成
   5.4 确定性(Definiteness)：每一步都有确定的含义，没有二义性
   5.5 可行性(Effectiveness)：算法的每一步都是清楚且可行的，用纸笔也能搞定

```java
/*
冒泡
*/
for(int i = 0; i < arr.length - 1; i++) {
		
		for(int j = 0; j < arr.length - 1 -i; j++) {
			if (arr[j] > arr[j+1]) {
				int temp = arr[j];
				arr[j] = arr[j+1];
				arr[j + 1] = temp;
			}
			
		}
		
	}
	
	for (int i = 0; i < arr.length; i++) {
		
		System.out.print(arr[i] + "\t");
	}
```



#### Arrays工具类

`java.util.Arrays`

1. 判断两个数组是否相等`Arrays.equals(int[] a, int[] b)`
2. 输出数组的信息`Arrays.toString(int[] a );`底层用到`StringBuilder()`
3. 将指定值填充到数组之中`void fill(int[] a, int val);`
4. 对数组进行排序`void sort(int[] a)`底层用到快排
5. 对排序后的数组进行二分法搜索`int binarySearch(int[] a, int key)`找到返回索引，找不到返回一个负数

#### 常见异常

出现异常程序就终止了，后面的都不执行了

1. 角标越界异常`ArrayIndexOutOfBountException`
2. 空指针异常`NullPointerException`

---

here is May 24, 2021

### Day 08 OOP上

#### 每日一考

1. 使用冒泡排序，实现如下的数组从小到大排序。`int[] arr = new int[]{34,5,22,-98,6,-76,0,-3};`

   ```java
   public static void main(String[] args) {
   	
   	int[] arr = new int[]{34,5,22,-98,6,-76,0,-3};
   	
   	for(int i = arr.length - 1; i > 0; i--) {
   		for(int j = 0; j < i; j ++) {
   			if(arr[j] > arr[j+1]) {
   				int temp = arr[j];
   				arr[j] = arr[j+1];
   				arr[j+1] = temp;
   			}
   		}
   
   	}
   	for(int i = 0; i < arr.length; i++) {
   		System.out.print(arr[i] + " ");
   }
   }
   ```

   

2. 如何反转上面的数组。请代码实现

   ```java
   int temp = 0;
   for(int i = 0; i < arr.length / 2; i++) {
     temp = arr[i];
     arr[i] = arr[arr.length - i - 1];
     arr[arr.length - i - 1] = temp;
   }
   ```

   

3. 复制上述数组，得到一个新的数组

   ```java
   int[] arr2 = new int[arr.length];
   	for(int i = 0; i < arr.length; i++) {
       arr2[i] = arr[i];
     }
   System.out.println();
   System.out.println("***************");
   for(int i = 0; i < arr2.length; i++) {
     System.out.print(arr2[i] + " ");
     }
   ```

   

4. 使用线性查找，从上述数组中查找22是否存在。存在，返回所在位置的索引。不存在，输出提示信息。

   ```java
   	int tar = 22;
   	boolean isFound = false;
   	for(int i = 0; i < arr.length; i++) {
   		if(arr[i] == tar) {
   			System.out.println(tar + " is found at index " + i);
   			isFound = true;
   			break;
   		}
   	}
   	if(!isFound) {
   		System.out.println(tar + " is NOT found");
   	}
   ```

   

5. 数组中常见的异常有哪些？请举例说明
   角标越界异常`ArrayIndexOutOfBoundException`
   空指针异常`NullPointerException`

#### 面向对象概述

这部分是核心，后面基本都是应用；特点是内容多，细节多，都需要理解和记忆。

<span style="color:red;">大处着眼，小处着手</span>

学习的三条主线，并行推进

1. Java类及类的成员：
   属性、方法、构造器；代码块、内部类
2. 面向对象的三大特征：
   封装性、继承性、多态性；先把代码弄明白，思想层面的事情后面再体现；如果要说有四个就是抽象性
3. 其他关键字：
   `this`，`super`，`static`，`final`，`abstract`，`interface`，`package`，`import`，等

#### POP vs OOP

面向过程POP与面向对象OOP的对比:<span style="color:red;">大象装进冰箱</span>

面向过程强调的是功能行为，以函数为最小单位，考虑怎么做

1. 把冰箱门打开
2. 抬起大象，塞进冰箱
3. 把冰箱门关上

面向对象对功能进行封装，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做

```java
人{
  打开(冰箱){
    冰箱.打开();
  }
  抬起(大象){
    大象.进入(冰箱)
  }
  关闭(冰箱){
    冰箱.闭合;
  }
}
冰箱{
  打开(){}
  闭合(){}
  
}
大象{
  进入(冰箱){
  }
  
}
```

程序员：从面向过程的执行者转化成了面向对象的指挥者

思路及过程：

1. 分析需求，选择问题所针对的现实世界中的实体
2. 从实体中寻找解决问题相关的属性和功能，这些属性和功能形成了概念中的类
3. 把抽象的实体用计算机语言来表述，形成计算机世界中的类
4. 类实例化成计算机世界中的对象，对象是解决计算机世界中问题的最终工具

#### Java类和对象

`Class`和`Object`是面向对象核心概念

* **类**是对一类事物的描述，是抽象的、概念上的定义。相当于图纸、蓝图
* **对象**是实际存在的该类事物的每个个体，因为也成为**实例(instance)**。相当于产品
  * Java语言万物皆对象

面向对象程序设计的重点是类的设计，而类的设计就是类成员的设计。类的内部结构主要有两个：

* `属性 = 成员变量 = field = 域 = 字段` 对应类中的
* `方法 = 成员方法 = method = 函数` 功能和行为

类和对象的使用（面向对象思想落地实现）：

1. 创建类、设计类的成员（这一步是最花时间的）
2. 创建类的对象
3. 通过`对象.属性`或`对象.方法`调对象中的结构

每个对象有自己独立的一套属性，属性也有默认初始化值（非`static`）
![复杂版内存解析](/Users/chris/Coding Bootcamp/Notes/atguigu-notes/Backend/00. Java基础/内存解析.png)

属性（成员变量）和局部变量的异同

1. 相同点:
   1.1 都是变量，所以定义格式是一样的：数据类型 变量名 = 变量值；
   1.2 先声明，后使用
   1.3 都有其作用域
2. 不同点：
   2.1 声明位置不同：
   <span style="color:red">属性</span>：直接定义在类的一对`{}`内
   <span style="color:red">局部变量</span>：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
   2.2 权限修饰符不同：
   <span style="color:red">属性</span>：可以在声明时，指明其权限，使用权限修饰符
   例如`private, public, 缺省, protected` 封装性的时候再说
   目前，都是用缺省就可以了
   <span style="color:red">局部变量</span>：不能使用权限修饰符
   2.3 默认初始化值的不同
   <span style="color:red">属性</span>：类的属性，根据其类型，都有默认初始化值
   <span style="color:red">局部变量</span>：没有默认初始化值=> 使用前必须显式初始化
   特别的：形参在调用时赋值即可
   2.4 内存中加载的位置不一样
   <span style="color:red">属性</span>：加载到堆空间中（非`static`）
   <span style="color:red">局部变量</span>：加载到栈空间中

方法声明格式，按照有无形参，有无返回值分为4类

|        | 无返回值                   | 有返回值                     |
| :----: | :------------------------- | ---------------------------- |
| 无形参 | `void method1(){}`         | `String method2(){}`         |
| 有形参 | `void method3(形参列表){}` | `String method4(形参列表){}` |

`static, final, abstract`也可以用来修饰方法，但是后面再说

```java
/*方法声明：权限修饰符 返回值类型 方法名 (形参列表){

}
*/

//如果声明的时候有返回值，则一定要有返回值，带分支的话也是每个分支都要有
public int getNum(){
  
  return 5;
  
}
//如果声明的时候没有返回值，则仍可以使用return来结束方法体，但不是一定要有

//return 后面不能再有执行语句
```

**形参列表格式：**

`[数据类型1 形参1， 数据类型2 形参2， 数据类型3 形参3，...]`

**方法体：**最多的工作是在这个地方，方法内部可以调方法，但是不能定义新的方法；调用自己叫递归，用不好可能会栈溢出

---

here is May 26, 2021

### Day 09 OOP上

#### 每日一考

1. 面向对象思想编程内容的三条主线是什么？
   Java类及类的成员：属性，方法，<span style="color: red;">构造器</span>；代码块，内部类
   面向对象三大特征：封装性、继承性、多态性、如果要第四个就是抽象性
   其他关键字：`statci`,`final`,`abstract`,`this`,`super`

2. 谈谈你对面向对象中类和对象的理解，并指出二者的关系
   类是泛指是抽象的，对象是特指是具体的。类是蓝图，对象是实例。Java里面万物皆对象

3. 面向对象思想的体现一：类和对象的创建和执行操作有哪三步？
   3.1 设计类
   3.2 创建：实例化对象
   3.3 调用属性和方法

4. 画出如下代码在执行时的内存分配情况

   ```java
   class Car{
          String color = "red";
          int num = 4;
          void show(){
   			  int a = 10;
   	          System.out.println("color="+color+",num="+num);
          }
   }
   class CarTest {
   	public static void main(String[] args) {
   		Car c1 = new Car();   
   		Car c2 = new Car(); 
   		c1.color = "blue";  
   		c1.show();   
   		c2.show();
     }
   }
   
   ```

   

5. 类的方法内是否可以定义变量？是否可以调用属性？是否可以定义方法？是否可以调用方法？
   可、可、不可、可

JVM内存解析：编译完源程序以后，生成一个或多个字节码文件。我们使用JVM中的类加载器和解释器对生成的字节码文件进行解释运行。意味着：需要讲字节码文件对应的类加载到内存中，涉及到内存解析

栈：局部变量存储在虚拟机栈中
堆：`new`出来的结构，比如数组，对象，加载在堆空间中
方法区：类的加载信息、常量池、静态域

#### 万物皆对象的理解

1. 在`Java`语言的范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构
2. 涉及到`Java`语言跟前端的`HTML`和后端的数据库在`Java`层面交互时，都体现为类、对象

匿名对象
没有显示给某给变量名，只能调用一次，开发中用的多

举例：新对象的地址已经赋给形参了

```java
class Phone{
	double price;
	
	public void sendEmail() {
		System.out.println("send Email");
	}
	
	public void playGame() {
		System.out.println("Play Game.");
	}
  
  public void showPrice(){
    System.out.println("Price is " + price);
  }
}

class PhoneMall{
  public void show(Phone phone){
    phone.sendEmail();
    phone.playGame();
  }
  
}

//别的主方法中：
new Phone().sendEmail(); 
PhoneMall mall = new PhoneMall();
mall.show(new Phone());
```

自己写类的时候尽量不要用和系统自带类重名的结构

#### 方法的重载

1. 定义：在同一个类中，允许存在一个以上同名方法，只要他们的参数个数或者参数类型不同即可。同名方法之间叫做重载
   “两同一不同”：同一个类，同方法名、参数列表不同

2. 举例：下列四个都构成重载

   ```java
   	public void getSum(int i, int j) {
   		System.out.println("1");
   	}
   	public void getSum(double d1, double d2) {
   		System.out.println("2");
   	}
   	
   	public void getSum(String s, int i) {
   		System.out.println("3");
   	}
   	
   	public void getSum(int i, String s) {
   		System.out.println("4");
   	}
   ```

3. 返回值类型无所谓，权限无所谓，形参名无所谓，如果把第一个getSum干掉，此时调用`getSum(1,2)`会打印`2`因为自动类型提升

4. 通过对象调用方法时，如何确定某一个指定的方法
   方法名 ==还要看==> 参数列表

#### 可变个数形参

* `JavaSE 5.0`加入了Varargs，允许直接定义能和多个实参匹配的形参。
* 格式`数据类型 ...形参名`。当调用可变个数的方法时，传入的参数可以是0个，1个，2个...
* 与其他同方法名，不同形参列表的方法构成重载
* 跟同类型数组参数的同名方法被认为是同一个方法，下面这俩不行
  * `public void show(String ... args){}`
  * `public void show(String[] args){}`
* 参数`args`就当成数组就可以了
* 必须声明在末尾，也就意味着只能有一个

#### Java方法参数传递：值传递机制

Java的实参值是如何传递的？都是值传递

* 基本数据类型是将实际存储的值赋给被赋值的变量
* 引用数据类型是将变量存储的地址值赋给被复制的变量

方法的形参传递机制。

* 形参：方法定义时，小括号内的参数
* 实参：调用方法的时候实际传递给参数赋的数据

---

Here is May 27, 2021

### Day 10 OOP上

#### 每日一考

1. 什么是方法的重载？
   两同一不同，在同一个类下的，同方法名不同形参列表的两个或多个方法相互构成重载
2. 说明Java方法中的参数传递机制的具体体现？
   值传递机制：体现在基本数据类型的变量，将实参的所存储的数据值复制给被传递的形参。
   引用数据类型则是将实参所存储的地址值传递给被赋值的对象
3. 成员变量和局部变量在声明的位置上、是否有默认初始化值上、是否能有权限修饰符修饰上、内存分配的位置上有何不同？
   成员变量直接声明在类的一对`{}`内，具有默认初始化值，可以使用权限修饰符，非`static`的都在堆空间中
   局部变量声明在：方法内，方法形参列表，构造器内，构造器形参列表，以及代码块当中
4. 谈谈return关键字的使用
   用来结束方法调用，对于有返回值的方法，用`return`关键字指明所要返回的值
5. 提供如下代码的内存解析
   ![image-20210528140207977](/Users/chris/Coding Bootcamp/Notes/atguigu-notes/Backend/00. Java基础/练习题.png)

#### 面向对象特征之一：封装与隐藏

* 为什么要封装？封装的作用和含义？
  * 用洗衣机只需要按开关就可以了，不需要知道内部怎么运作的，没必要碰电动机
  * 要开车，没必要知道发动机和传动的原理
* ​	我们写代码搞开发也是一样，我们用的是别人的API
  * 高内聚：类内部数据操作细节自己完成，不允许外部干涉
  * 低耦合：进队外暴露少量的方法用于使用
* 隐藏对象内部的复杂性，之队外公开简单的接口（不是后面的`Interface`） 从而提高系统的可扩展性和可维护性

1. 问题的引入

   当我们创建一个类的对象以后，我们可以通过`对象.属性`的方式，对对象的属性进行复制，这里，复制操作要收到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件，但是在实际问题中，我们往往需要给属性赋值有其他方法。这个需求仅靠属性声明不能满足。除此之外我们要禁止用户用`对象.属性`的方式对属性进行赋值`private`的使用。

2. 封装性的体现(只是体现，不等于封装性)
   我们将类的属性xxx私有化`private`，同时提供公开的`public` `getter/setter `方法来获取和设置属性
   拓展:其他封装性的体现，类内部自己使用的（不对外暴露的）私有方法，高内聚，单例模式也是封装性的体现

3. 封装性的体现需要权限修饰符来配合

   Java一共有四种，从小到大排列`private < （缺省）default < protected < public`
   `private`： 类内部
   `缺省`：类内部、同一个包

   `protected`：类内部、同一个包、不同包的子类
   `public`：类内部、同一个包、不同包的子类、同一个工程

* 四种可以用来修饰类及类的内部结构：
  * 属性、方法、构造器、内部类，注意，代码块不行
* 用来修饰类：`class`只能用`public`和`缺省`
* 总结： `Java`提供了四种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小

#### 构造器`constructor`

1. 构造器的作用：创建类的对象`new + constructor`、可以初始化对象的属性
2. 任何一个类都有构造器，如果没有显示定义构造器，则系统默认提供一个空参的构造器(权限与类一样，public或者缺省)
   一旦我们显示定义了类的构造器之后，系统就不再提供默认空参构造器
3. 构造器的定义格式：`权限修饰符 类型名(形参列表){}`
4. 不建议将构造器理解为一种特殊的方法，主要是构造器的作用与方法不同，且二者发生作用的时间也不一样
5. 一个类中，至少会有一个构造器

属性赋值的先后顺序：目前为止，对象属性赋值的四种方法

1. 默认初始化
2. 显示初始化
3. 构造器中初始化
   ***前三种之所以叫初始化，是因为只有一次，后面这种可以反反复复调用***
4. 通过`对象.方法`/`对象.属性`的方式

`Java Bean`是一种`Java`语言写成的，可以重用的组建，满足三个条件的Java类叫做Java Bean：

1. 类是公共的
2. 有一个无参的公共构造器
3. 有属性及对应的`getter/setter`方法

使用`JavaBean`将功能、处理、值、数据库访问和其他任何可以用`Java`代码创造的怼心啊哥进行打包，并且其他的开发者可以通过内部的JSP页面，Servlet，其他JavaBean，applet程序或者应用来使用这些对象。

用户可以认为JavaBean提供了一种随时随地的复制粘贴功能，不用关心任何改变。

#### 关键字`this`

* `this`可以理解为当前对象（方法中）或者当前正在创建的对象（构造器中），可以用来修饰属性、构造器、方法。
  * 在类的方法中，我们可以使用`this.属性`或`this.方法`的方式调用当前的属性或者方法，但是，通常情况下，我们都选择省略。特殊情况下，如方法的形参和类的属性同名的时候我们必须显示使用`this.变量`的方式表明次变量是属性，而非形参
  * 在类的构造器中，我们可以使用`this.属性`或`this.方法`的方式调用当前的属性或者方法，但是，通常情况下，我们都选择省略。特殊情况下，如构造器的形参和类的属性同名的时候我们必须显示使用`this.变量`的方式表明次变量是属性，而非形参
* `this（形参列表）`修饰和调用本类中指定的<span style="color:red;">其他</span>构造器:
  * 比如调空参的：`this();`
  * 比如调带参的：`this(age);`
  * 注意构造器不能调自己，也不能形成“环”，换言之，如果一个类中有n个构造器，则至多有n-1个构造器使用`this(形参列表)`这种形式
  * 构造器内部的，`this(形参列表)`必须出现在<span style="color:red;">首行</span> ==所以==>一个构造器内部只能调用一个

#### 关键字`package`和`import`

`package`

* `package`叫做包，目的是为了更好的实现项目中类的管理
* 使用`package`声明类或接口所属的包，声明在源文件的<span style="color:red;">首行</span>
* 包名属于标识符，遵循标识符的命名规范，见名知意`com.atguigu.java`
* 每`.`点一次代表一层文件目录
  * 补充：同一个包下不能命名同名的接口或类
  * 不同包下可以命名同名的接口或类

JDK中主要的包介绍

1. `java.lang`Java语言的核心类`String,Math,Integer,System`
2. `java.net`网络编程
3. `java.io`输入输出
4. `java.uitl`定义系统特性，接口的结合，日期日历相关函数
5. `java.text`java格式化相关
6. `java.sql`JDBC进行数据库编程的相关类/接口
7. `java.awt`抽象窗口工具机，写GUI的，渐渐被浏览器取代

MVC是常用设计模式之一，是结构清晰，灵活，同时也描述了程序各个对象之间的通信方式，降低了程序的耦合度

* 视图模型层：view.utils
* 控制器层：controller.activity/controller.base
* 数据模型层：model.bean/domain/model.dao/model.db

`import`关键词，导入

* 在源文件中现实的使用`import`结构导入指定包下的类、接口
* 申明在包的声明和类的声明之间
* 如果需要导入多个包，则并列写出即可
* 也可以使用xxx.*的方式导入xxx包下的所有结构
* `java.lang`包下的可以省略`import`这个结构，本包下定义的类和接口结构可以省略
* 如果有同名的类，在不同的包下，只能`import`其中的一个，另一个只能用全类名的方式
  * `Date`就有可能同时出现`java.util`和`java.sql`下都有这个类
* 如果使用`xxx.*`的方式表明可以`xxx`下的所有结构，但是如果使用的是`xxx`子包心爱的接口，则仍需要显示导入
  * `java.lang.reflect.Field`
* `import static`：导入指定的类或者接口中的结构静态：属性或者方法，用的少

---

Here is May 28, 2021

### Day 11 OOP中

#### 每日一考

1. 构造器的作用是什么？使用中有哪些注意点(>=3条)
   构造器的作用：创建对象，初始化对象；注意名称与类名相同，如果不显示提供构造器的话系统默认提供一个空参构造器；如果显示提供了构造器则系统不再默认提供空参构造器；在构造器内可以调用其他结构，如属性和方法；<span style="color:red;">构造器没有返回值；每一个类都要有构造器；构造器不应该理解为特殊的方法，应该是跟方法并列的结构</span>

2. 关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序
   目前有四种：默认初始化 < 显示初始化  < 构造器初始化 < setter Method 赋值

3. this关键字可以用来调用哪些结构，简单说明一下其使用
   当前类或者当前正在创建的类的结构：属性`this.属性`、方法`this.方法名(方法形参)`、构造器`this(构造器形参)`。

4. Java中目前学习涉及到的四种权限修饰符都有什么？并说明
   由小到大：`private` < `缺省`< `protected`< `public`
   类内部，类和同一个包下，类和不同包下的字类，同一个工程
   出了工程都要用`import`来导入，import的时候要注意，`.`一次代表一层目录‘不同包内的同名类

5. 创建Circle类，提供私有的radius属性，提供相应的get和set方法，提供求圆面积的方法

   ```java
   public class Circle{
     private double radius;
     
     public void setRadius(double radius){
       this.radius = radius;
     }
     
     public double getRadius(){
       return this.radius;
     }
     
     public double findArea(){
       
       return Math.PI * this.radius * this.radius;
       
     }
     
   }
   ```


#### 项目二

写完了，跟了一下，比较简单。收获：

* 熟悉Eclipse 的快捷键，还有在Mac下熟悉指法。
* 建立自信
* MVC极简版初体验，有时间可以再反复品味一次

#### OOP特征，继承性，inheritance

* 好处：
  1. 减少了代码的冗余，提高了代码的复用性
  2. 便于扩展功能
  3. 为多态性的使用提供了前提
* 坏处：详见，*The Pragmatic Programmer*
* 继承的格式：`class A extends B{}`
  * `A` 子类、派生类`subclass`
  * `B`父类、超类、基类`superclass`
  * 体现：一旦子类`A`继承父类`B`以后，字类`A`中就获得了`B`中声明的所有的属性和方法
    * 父类中声明为`private`的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构，只是因为封装性的影戏那个，使子类不能直接调用父类中的结构。
  * 子类继承父类以后还可以声明自己的属性或方法：实现功能的拓展
    * 子类和父类的关系不同于，子集和集合的关系
* Java中关于继承行的规定：只支持单继承和多层继承
  * 一个类可以被多个子类继承
  * 一个类只能继承一个父类：`Java`中类的单继承性，不同于`c++`上的多继承性
  * 子父类是相对的概念，也就是可以多层继承。直接父类和间接父类
  * 子类继承父类以后，就获取了直接父类和所有间接父类中声明的属性和方法
* 如果我们没有显示地声明一个类的父类的话，则此类继承于`java.lang.Object`
  * 所有的`Java`类（除`java.lang.Object`外）都直接或间接继承于`java.lang.Object`。
  * 意味着，所有`Java`类都具有`java.lang.Object`类声明的功能。

---

Here is May 29, 2021

### Day 12 OOP中

#### 方法的重写(override)

#### 四种访问权限修饰符

#### 关键字`super`

#### 字类对象实例化过程

#### OOP特征，多态性

#### `Object`类的使用

#### 包装类的使用

## Java高级编程 

Java语言的具体应用



如果现在的配时不合理到一定程度



20秒绿灯，40秒红灯 => 过饱和

计划：Before / after 计划
