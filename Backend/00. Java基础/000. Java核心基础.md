## Java基础编程

JAVA语言的核心

### Day 00 编程入门

#### 学习的原则

* 学习编写代码的捷径：敲、狂敲
  * 一天的代码至少敲3遍：第一遍照着写，第二遍背着写，第三遍自己写
  * 三分看、七分练
* 先模仿好的编码习惯，有些东西需要背
* 每天30min复习整理
* 战略上藐视，战术上重视

艾宾浩斯遗忘曲线

### Day 01 Java语言概述

#### Roadmap

第一阶段：30天、Java基础、MySQL、JDBC等<span style="color:red">**（May 18, 2021 -- ）**</span>

第二阶段：15天、JavaWeb、HTML基础与CSS、XML与Tomcat、JSP等（组件）

第三阶段：16天、JavaEE框架、Spring、SpringMVC、MyBatis、Linux等

所谓框架：常用组件的集合，封装、使用组件开发效率比较低

互联网众筹项目：15天、规模不小，但是略掉重复性的功能滤掉了

第四阶段：15天、JaveEE高级、IDEA开发工具、Git与GitHub、MySQL高级、Nginx反向代理、Docker

电商项目：15天、电商项目包含其他各门类的业务场景的影子

电商项目总结与拓展：3天

在线教育项目：12天

总记127天左右，一周6天，共20个周左右

May 18, 2021 ---20 weeks---> Sep 14, 2021

#### Java学习

![Java知识图谱](/Users/chris/Coding Bootcamp/Notes/Backend/00. Java基础/知识图谱.png)

笔记不要太详细，概要记重要的是过程。

培养兴趣：两个周左右的时间建立编程的feel，敲、狂敲

#### 软件开发

软件有系统软件和应用软件之分、人机交互方式有GUI和CLI之分

#### 计算机编程语言简介

粗浅分为三代：

1. 机器语言：二进制代码

2. 汇编语言：助记符

3. 高级语言：可以分为两个阶段

   3.1. 面向过程

   3.2. 面向对象

#### Java语言概述

* SUN（Stanford University Network）公司开发的
  * Java小程序（applet）可以嵌入HTML当中，在Web浏览器中运行
* 后台开发：Java、PHP、Python
  * Java体量大，开发周期慢：绝对主力，首选语言
  * Python有替换PHP的趋势，开发周期短：一两个人两三个月也就搭起来了
  * Go语言、据说有Java的开发效率和C/C++的运行效率
  * Node.js
* Java简史
  * Java地名，是个岛，盛产咖啡
  * 1991年以Oak命名
  * 1996年，发布JDK 1.0
  * 2004年，发布JDK1.5，有突破性的重要版本，改名为JDK5.0
  * 2005年，J2SE -> JavaSE; J2EE -> JavaEE; J2ME -> JavaME
  * 2009年，SUN公司被Oracle公司收购了，74亿美元
  * 2014年，发布JDK 8.0，继JDK5.0以来变化最大的版本
* Java技术体系平台
  * JavaSE：桌面级应用，现在基本上已经不会出现了
  * JaveEE：企业级的应用Servelt、JSP
* Java语言的诞生
  * 类C语言、纯粹的面向对象语言
  * 舍弃C语言中容易引起错误的指针
  * 增加了垃圾回收器

#### Java语言运行机制和运行过程

Java语言特点：

1. 面向对象：

   1.1. 两个基本概念：类、对象

   1.2. 三大特性：封装、继承、多态

2. 健壮性：

   2.1. 吸收C/C++优点，舍去影响健壮性的部分（指针，申请、释放内存）

3. 跨平台性：

   3.1. 跨平台性：“Write once， Run anywhere”

   3.2. 原理： JVM安装好，JVM就负责Java程序在系统中的运行

4. Java核心机制：

   4.1. JVM

   4.2. 垃圾回收

#### Java语言的环境搭建：

* JDK（Java Development Kit Java开发工具包）

  * 给Java开发人员使用，包含JRE
  * 开发工具包括：编译工具javac，打包工具jar等

* JRE（Java Runtime Environment Java运行时环境）

  * 如果想运行开发好的Java程序，只需要JRE
  * Java程序需要的核心类库

* 三者关系：

  * Java 8.0![Java 8.0](/Users/chris/Coding Bootcamp/Notes/Backend/00. Java基础/Java8.0_platform.jpg)
  * 简化版![简化版](/Users/chris/Coding Bootcamp/Notes/Backend/00. Java基础/JVM,JRE,JDK.png)

* 我的环境：

  * OS: macOS 11.3 (20E232) Big Sur
  * JDK路径:
    * /Users/chris/Library/Java/JavaVirtualMachines/azul-1.8.0_282/Contents/Home
    * /Users/chris/Library/Java/JavaVirtualMachines/azul-1.8.0_292/Contents/Home
  * `JAVA_HOME`：bin目录的上层目录。这也是一个约定的变量，通常指JRE目录。上面的两个都可以事JAVA_HOME
    * 其实大部分Java程序不需要JDK，而是只需要其子集JRE，所以很多程序也会去取这个变量来用。
  * 为什么需要配置环境变量？
    * 希望在任何路径下都能够执行相应的程序

* HelloWorld

  ```java
  class HelloWorld{
    public sttic void main(String[] args){
      System.out.println("Hello World!");
    }
  }
  ```

* 源文件（.java文件）--javac编译--> 字节码文件（bytecode .class文件）--java运行-->结果

  * Windows路径名不是区分大小写
  * classpath：class文件的路径，不要配

#### Java注释  Comments

​	提高代码可读性、不参与运行，单行注释和多行注释的主要作用都是这样，方便别人也方便自己；另外也可以用来调试

##### 单行注释

```java
class HelloWorld{
  //单行注释
  public sttic void main(String[] args){
    System.out.println("Hello World!");
  }
}
```



##### 多行注释

```java
class HelloWorld{
  /*多行注释
  好多好多行
  */
  public sttic void main(String[] args){
    System.out.println("Hello World!");
  }
}
```

提高代码可读性、不参与运行，单行注释和多行注释的主要作用都是这样，方便别人也方便自己；另外也可以用来调试

##### 文档注释（Java特有）

```java
/**

文档注释，可以被javadoc解析的
@author fscj
@version v1.0
这是我重新起航的第一个Java程序，非常开心

*/
public class HelloWorld{
  /*多行注释
  好多好多行
  */
  public sttic void main(String[] args){
    System.out.println("Hello World!");
  }
}
```

```shell
javadoc -d DIR_NAME -author -version HellowWOrld.java
```

* 注意：多行注释不能嵌套，很简单的原理

#### Java API 文档

CHM是Windows上用的，macOS上再说吧，不行就看英文文档

#### Java 类和public 类

* 在以一个Java源文件中，可以声明多个`class`但是，只能有一个生命为`public`
* 而且要求声明为`public`的类，类名必须等于（源）文件名

#### Java编码习惯以及IDE说明

* 正确的注释和注释风格
  * 使用文档注释来注释整个类或整个方法
  * 如果注释方法中的某一个步骤，使用单行或者多行注释
* 一个`tab`进行缩进、运算符两边各加一个括号增强可读性
* 常用IDE，Eclipse和IntelliJ IDEA

---

Here is May 18, 2021

### Day 02 Java基本语法

#### 关键字和保留字

##### keyword定义

被Java语言赋予了特殊含义，用做专门用途的字符串。

* 特点：所有关键字都是小写的
* `true`, `false`,`null`严格意义上不算关键字，但还是当关键字来用。意思是自己定义标识符的时候还是不要用这些字

##### reserved word定义

现有Java版本尚未使用，但以后版本可能会作为关键字使用的。意思是自己定义标识符的时候还是不

* `goto`,`const`



#### 标识符

* Identifier: Java对各种变量、方法和类等要素命名时使用的字符序列成为标识符
  * 凡事自己起名的都叫标识符
* 规则：
  * `a-z | A-Z | 0-9 | _ | $`
  * 数字不能开头
  * 不能事关键字或者保留字，但是可以包含
  * Java中严格区分大小写，长度无限制
  * 标识符不能包含空格
* 规范：
  * 包名：多单词组成是所有字母都小写：`xxxyyyzzz`
  * 类名、接口名：大驼峰：`XxxYyyZzz`
  * 变量名、方法名：小驼峰：`xxxYyyZzz`
  * 常量名：所有字母大写，多单词时用下划线连接：`XXX_YYY_ZZZ`
* 使用meaningful的标识符，见名知意

#### 变量

* 变量的概念

  * 内存中的一个存储区域
  * 该区域的数据可以在同一类型范围内不断变化
  * 是程序中最基本的存储单元，包含**类型**、**名称**和**存储的值**

* 变量的作用

  * 在内存中存储数据

* 注意：

  * Java中每个变量必须先声明，后使用
  * 使用变量名访问数据
  * 作用域：一对大括号内`{}`
    * 变量只在其作用域内有效
    * 同一个作用域内不能出现同名变量

* 举例：

  ```java
  class VariableTest{
    public static void main(String[] args){
      //变量的定义
      int myAge = 12;
      //变量的使用
      System.out.println(myAge);
      //变量定义可以分为声明和赋值两步
      int myNumber;
      myNUmber = 10001;
    }
    
  }
  ```

* 变量的分类

  * 8种基本数据类型primitive type

    * 数值型

      * 整数型`short`,`int`,`long`,`byte`

      * 浮点型`float`,`double`

        ```java
        class VariableTest
          //基本数据类型的使用
          public static void main(String[] args){
          /* 整数型
          byte 8位 一个字节
          short 16位 两个字节
          int 32位 四个字节 表示范围最高约21亿
          long 64位 八个字节 声明时以"l"或者"L"结尾，不加的话，在数值不超过int型表达范围的时候编译也能通过
            通常使用 int 型
          */
          long l1 = 23123123l;
        
          /* 浮点型
          float 4字节 声明时以"f"或者"F"结尾，不加编译失败
          doulbe 8字节
          跟整型比起来，占用同样的存储空间，但是表示的范围也大，还带小数点，但是精度不行
          通常使用 double 型
          */
          double d1 = 1234.4;
          float f1 = 1234.5f;
          
          /* 字符型
          char 1字符=2字节 通常用一对单引号，内部不能写两个字符
          通常使用 double 型
          */
          char ch1 = 'a';
          
          //char ch2 = 'AB'; 编译不通过
          }
          
        }
        ```

    * 字符型`char` ，表示方式：

      * 声明一个字符`char ch1 = 'a';`必须是一个字符，空的不行`char ch2 = '';`编译失败
      * 转义字符`\n`,`\t`等
      * `Unicode` 值 `\u0123`
      * 字符集：计算机内部2进制和字符之间的对应关系，
        * 最早的就是`ASCII`码，其中`'a'` 对应到 `97`
        * `Unicode`要解决互联网发达以后不同国家的字符集之间通信的问题
        * `UTF-8`后面都用这个

    * 布尔型 `boolean`

  * 基本类型之间的运算规则：
    前提：不包含`boolean`，所以是7种数据类型之间的转换

    * 自动类型提升：当容量小的数据类型和容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。此时的容量大小指的是表示数的范围的大小，不是存储范围的大小
      `byte / char / short / int --> long  --> float --> double`
      特别的当`byte,char,short`三种做运算的时候，结果为`int`，即便是`byte + byte`结果也是`int`
    * 强制类型转换：自动类型提升运算的逆运算`int1 = (int) d1;//截断操作`

  * 3种引用数据类型reference type

    * 类`Class` 字符串`String` 属于这类
    * 接口`Interface`
    * 数组`[]`

  * 初见`String`类型

    * `String`，中文名字叫字符串，属于引用数据类型
    * 申明时用一对双引号`String str1 = "Hellow World";`
    * `String`类型可以和8种基本数据类型的变量做连接运算，且只能是连接运算。
      * `String str = "Hello World" + 1234;`，可见运算结果仍然是`String`类型

    ```java
    //练习1
    char c = 'a';
    int num = 10;
    String str = "hello";
    
    System.out.println(c + num + str);//"a10hello"!!!正确答案"107hello"
    System.out.println(c + str + num);//"ahello10"
    System.out.println(c + (num + str));//"ahello10"
    System.out.println((c + num) + str);//"107hello"
    System.out.println(str + num + c);//"hello10a"
    
    //练习2
    System.out.println("*   *");//OK
    System.out.println('*' + 't' + '*');//NOT OK
    System.out.println('*' + "t" + '*');//OK
    System.out.println('*' + 't' + "*");//NOT OK
    System.out.println('*' + ('t' + "*"));//OK
    ```

    

  ---

  Here is May 19, 2021

### Day 03 Java基本语法

#### 每日一考

1. 标识符的命名规则有哪些？
   26个字母大小写,$, _,[0-9]
   数字不能开头
   严格区分大小写
   不能是关键字和保留字，但是可以包含

2. 标识符的命名规范有哪些？
   包名：全小写
   类、接口名：大驼峰
   变量、方法：小驼峰 
   <span style="color:red">常量名，全大写，下划线分割</span>

3. Java变量找数据类型怎么分，并指出Java的基本数据类型有哪8种，并指出各自占用的内存空间大小
   基本数据类型：
   整型：`byte`，1个字节;`short`，2个字节;`int`，4个字节;`long`，8个字节;
   浮点型：`float`，4个字节;，`double`，8个字节;
   布尔型：`boolean`，1个字节，具体体层转化成`int`但是不同管
   字符型：`char`，2个字节
   引用数据类型：3种：类`Class`、接口`Interface`、数组`[]`

4. 说明基本数据类型之间的自动类型提升的运算规则

   按照该类型所能表示的数字范围的递增顺序
   `byte/char/short --> int --> long --> float -->double`

   特殊规则：前三种，之间运算，结果都是`int`；默认整型是`int`；默认浮点型是`double`

5. 说明基本数据类型之间的强制类型转换的使用规则和强转可能出现的问题。
   用法：`(int)`括号加类型
   问题：丢失数据精度，或者编译失败

#### 运算符

* 算数运算符

  * 单元：`+,-,++,--`
  * 双元：`+,-,*,/,%`
  * 连接运算符：`+`

  ```java
  class ArithmeticTest{
    
    public static void main(String[] args){
      /* 算数运算符的说明
      
      */
      // % 模运算符
      //如果出现负数，那么结果的符号与被模数相同
      int m1 = 12;
      int n1 = 5;
      System.out.println("m1 % n1 = " + m1 % n1);//2
  		int m1 = -12;
      int n1 = 5;
      System.out.println("m1 % n1 = " + m1 % n1);//-2
      int m1 = 12;
      int n1 = -5;
      System.out.println("m1 % n1 = " + m1 % n1);//2
      int m1 = -12;
      int n1 = -5;
      System.out.println("m1 % n1 = " + m1 % n1);//-2
    }
    /* 自增自减运算符不会改变数据的类型 */
    	short s1 = 10;
    	// short s1 = s1 + 1;//编译失败
    	short s1 = (short)(s1 + 1);//正确，但是相对低效
    	s1++;
    
    	byte b1 = 127;
    	byte++;
    	System.out.println("b1 = " + b1);//猜测：-128，猜测正确
  }
  ```

  ```java
  /*
  练习题：给定一个三位数，输出它的百位数，十位数，个位数：
  */
  
  class AriExer{
    
    public static void main(){
      int num = 187;
      
      int ge = num % 10;
      // int shi = (num/10) % 10;//这个不对
      int shi = num % 100 / 10;
      int bai = num / 100;
    }
    
    
    
  }
  ```

  

  题外话：代码量是评判程序员好坏的基本指标，干就完事儿了；代码积累过程中解决了多少个bug

* 赋值运算符
  `=, +=, -=, /=, %=`，支持连续赋值

  ```java
  //连续赋值的两种情况
  int i1, j1;
  i1 = j1 = 10;
  
  int i2 = 10, int j2 = 20;
  
  //复合赋值运算符不会改变变量的数据类型
  short s1 = 10;
  s1 = s1 + 2;//编译不通过
  s1 += 2;
  
  //开发中实现一个变量+2的操作 int num = 10;
  //方法1
  num = num + 2;
  //方法2(推荐)
  num += 2;
  
  //开发中实现一个变量+1的操作 int num = 10;
  //方法1
  num = num + 1;
  //方法2
  num += 1;
  //方法3（推荐）
  num++;
  
  //练习题：
  int i = 1;
  i *= 0.1;
  System.out.println(i);//0 注意，复合赋值运算不会改变数据类型
  
  //练习题：
  int n = 10;
  n += (n++) + (++n);//推理：25， 推理错误！
  /* 推导
  1: (n++)==> 10 n ==> 11;
  2: (++n)==> 12 n ==> 13;
  3: 10 + 12 ==> 22;
  4: 13 + 22 ==> 25;
  */
  
  /* 正确推导
  1: 10 + () + ()
  2: (n++)==> 10 n ==> 11;
  3: (++n)==> 12 n ==> 13;
  4: 13 + 22 ==> 25;
  */
  ```

  

* 比较（关系）运算符
  `==, !=, >, <, >=, <=, instanceof`
  要注意`==`和`=`的区分

* 逻辑运算符
  `&, &&, |, ||, !, ^`
  只能适用于布尔类型的变量,"单与"和"双与"的区别：

  ```java
  class LogicTest {
    public static void main(String[] args){
      //区分& 和 &&
      boolean b1 = false;
      int num1 = 10;
      if(b1 & (num1++ > 0)){
        System.out.printlin("我现在在北京");
      }else{
        System.out.printlin("我现在在南京");
      }
      
      System.out.println("num1 = " + num1);//11
      
      boolean b2 = false;
      int num2 = 10;
      if(b2 && (num2++ > 0)){
        System.out.printlin("我现在在北京");
      }else{
        System.out.printlin("我现在在南京");
      }
      System.out.println("num2 = " + num2);//10，说明num2没有进行++运算
    }
    
  }
  ```

  

* <span style="color:purple;">位运算符</span>
  `<<, >>, >>>, &, |, ^, ~`，注意，没有`<<<`
  位移运算都是对整数来说的，区分`&, |, ^`和逻辑运算符就看操作数的数据类型

  ```java
  /* 练习：交换两个变量的值
  
  */
  int num1 = 10;
  int num2 = 20;
  
  //两个只能站一个人的小岛，甲乙两人互换位置
  //好处：不用定义临时变量
  //弊端：有可能相加结果超出存储范围。局限性：只能作用在数值型的变量上面
  num1 = num1 + num2;
  num2 = num1 - num2;
  num1 = num1 - num2;
  
  //位运算符的方式，厉害了
  num1 = num1 ^ num2;
  num2 = num1 ^ num2;
  num1 = num1 ^ num2;
  ```

  

* 三元运算符
  `(condition) ? exp1 : exp2`
  表达式1和表达式2要求是一致的，三元运算符可以嵌套

* 关于三元运算符和`if-else`语句

  * 关系：能用三元运算符写的都可以用`if-else`语句来写，反之不成立
  * 取舍：如果既可以用三元运算符又可以用`if-else`语句，优先tenary，原因是简洁，执行效率高

#### 流程控制

来源于工业上的生产流程，代码的执行也是个流程。实际生产中需要用到如下三种基本流程结构

* 顺序结构

  * 程序从上到下顺序执行

* 分支结构

  * 三种`if-else`
    
    ```java
    /* 第一种*/
    if (exp) {}
    /* 第二种 二选一*/
    if (exp1){...}else{...}/* 第三种 多选一*/
    if (exp1){...}
    else if ()
    {...}
    ...
    else{}
    ```
    
  * `switch-case`结构
    
    ```java
    /* 
    switch 后面跟的exp只能是下列6种中的一个：
    byte, short, char, int, 枚举类型（JDK 5.0新增）, String类型(JDK 7.0新增)
    */
    switch(exp){
        
      case const0:
        System.out.println('Zero');
        break;
      case const1:
        System.out.println('One');
        break;
      default:
        System.out.println('Other');
    }
    ```

### Day 04 Java基本语法

#### 每日一考

1. `&`和`&&`的异同
     相同点：运算结果相同、都会执行左边的运算数（表达式）
     不同点：当`&&`左边的操作数已经是`false`的情况下，`&&`右边的表达式不会被计算

2. 程序输出题：

     ```java
     class OperatorTest {
     	public static void main(String[] args) {
     		boolean x = true;
     		boolean y = false;
     		short z = 40;
     		if ((z++ == 40) && (y = true)) {
     			z++;
     		}
     		if ((x = false) || (++z == 43)) {
     			z++;
     		}
     		System.out.println("z = " + z);
     	}
     }
     ```

     输出结果为：`z = 44`

3. 定义三个int型变量并赋值，使用三元运算符或者if-else获取这三个数中的较大数的实现

     ```java
     int n1 = 10, int n2 = 12; int n3 = 4;
     // 三元运算符
     int max;
     max = n1 > n2 ? (n1 > n3 ? n1 : n3) : n2; 
     // if-else
     int max;
     if (n1 >= n2 && n1 >= n3){
       max = n1;
     }else if (n1 < n2 && n2 >= n3) {
       max = n2;
     }else{
       max = n3;
     }
     ```

     

4. 编写程序，声明2个double型变量并赋值。判断第一个数大于10.0，且第2个数小于20.0，打印两数之和。否则，打印两数的乘积。

     ```java
     double d1 = 12.3, double d2 = 3.14;
     if (d1 > 10.0 && d2 < 20.0){
       System.out.println("d1 + d2 = " + (d1 + d2));
     }else{
       System.out.println("d1 * d2 = " + (d1 * d2));
     }
     ```

     

5. 交换两个变量值的代码的实现

     ```java
     String s1 = "北京";
     String s2 = "南京";
     String temp;
     temp = s1;
     s1 = s2;
     s2 = temp;
     ```

#### Scanner类的使用

```java
import java.util.Scanner;

class ScannerTest{
  
  public static void main(String[] args){
    
    Scanner scan = new Scanner(System.in);
    
    Systemout.println("请输入姓名");
    String name = scan.next();
    System.out.println(name);
    
    Systemout.println("请输入年龄");
    int age = scan.nextInt();
    System.out.println(age);
    
    Systemout.println("请输入年龄");
    double weight = scan.nextDouble();
    System.out.println(weight);
    
    Systemout.println("你是否相中我了呢？(true/false)");
    boolean isLove = scan.nextBoolean();
    System.out.println(isLove);
    
    //原生没有char型，但是可以先接受为String，后面用String的charAt()方法
    
    System.out.println("输入你的性别：（男/女）");
    String gener = scan.next();
    char genderChar = gener.charAt(0);
    Syste.out.println(genderChar);
  }
  
}
```

#### if-else例题

例题1: 键盘输入小鹏的成绩，给奖励

```java
import java.util.Scanner;

class IfTest{
  
  public static void main(String[] args){
    
    Scanner scan = new Scanner(System.in);
    
    Systemout.println("请输入岳小鹏期末成绩：(0,100]");
    
    int score = scan.nextInt();
    
    if(score == 100){
      System.out.println("BMW");
    }else if(score > 80 && score <= 99){
      System.out.println(iPhone xs max);
    }else if(score >= 60 && score <= 80){
      System.out.println("iPad");
    }else{
        System.out.println("Nothing");
      } 
  }
  /* 
  说明：
  >如果多个条件表达式之间是“互斥”关系，没有交集，判断和执行语句的顺序可以随便换，无所谓
  >如果多个条件表达式之间有交集，需要根据实际情况考虑
  >如果多个条件表达式之间是包含关系，通常情况下，范围小的写在上面
  */
}
```

例题2：输入三个数，排序

```java
import java.util.Scanner
  /* 
  从键盘输入三个整数用if-else排序，从小到大排序
  */
class IfTest2{
  
  public static void main(String[] args){
    
    Scanner scan = new Scanner(System.in);
    
    Systemout.println("请输入第一个整数：");
    int n1 = scan.nextInt();
    Systemout.println("请输入第二个整数：");
    int n2 = scan.nextInt();
    Systemout.println("请输入第三个整数：");
    int n3 = scan.nextInt();
    
    if (n1 > n2){
      if (n3 >= n1){
        System.out.println(n2 + "," + n1 + "," + n3);
      }else if(n3 <= n2){
        System.out.println(n3 + "," + n2 + "," + n1);
      }else{
        System.out.println(n2 + "," + n3 + "," + n1);
      }
    }else{
      if (n3 >= n2){
        System.out.println(n1 + "," + n2 + "," + n3);
      }else if(n3 <= n1){
        System.out.println(n3 + "," + n1 + "," + n2);
      }else{
        System.out.println(n1 + "," + n3 + "," + n2);
      }
      
    }
  }
  /* 
  说明：
  >如果多个条件表达式之间是“互斥”关系，没有交集，判断和执行语句的顺序可以随便换，无所谓
  >如果多个条件表达式之间有交集，需要根据实际情况考虑
  >如果多个条件表达式之间是包含关系，通常情况下，范围小的写在上面
  */
}
```

**重点：**`if-else`结构可以嵌套，实际开发中很少会用到超过3层的嵌套`if-else`

#### switch-case例题

```java
/* 
通过键盘输入month 和date，输出2019年的第几天
目的是展示Break不是一定要写的
*/
import java.util.Scanner;
class SwitchCaseTest2{
  
  public static void main(String[] args){
    Scanner scan = new Scanner(System.in);
    System.out.println("请输入2019年的month：");
    int month = scan.nextInt();
    System.out.println("请输入2019年的day：");
    int day = scan.nextInt();
    int sumDays = 0;
    switch(month){
      case 12:
        sumDays += 30;
      case 11:
        sumDays += 31;
      case 10:
        sumDays += 30;
      case 9:
        sumDays += 31;
      case 8:
        sumDays += 31;
      case 7:
        sumDays += 30;
      case 6:
        sumDays += 31;
      case 5:
        sumDays += 30;
      case 4:
        sumDays += 31;
      case 3:
        sumDays += 28;
      case 2:
        sumDays += 31;
      case 1:
        sumDays += day;
    }
    System.out.println("2019年" + month + "月" + day + "日是2019年的第" + sumDays + "天");
  }
}
```

凡可以用`switch-case`写的分支结构都可以用`if-else`写，反之不成立

#### 循环结构

* 循环结构的四个要素

  1. 初始化条件
  2. 循环条件 ==>是`boolean`类型
  3. 循环体
  4. 迭代条件

* `for`循环的结构

   ```java
   for(int i = 1; i < 10; i++){
     /* 循环体 */
   }
   
   /* 写程序循环1到150自然数，如果是3的倍数加上foo 如果是5的倍数打印biz 如果是7的倍数baz*/
   for(int i = 1; i < 151; i++){
     
     System.out.print(i + " ");
     if (i % 3 == 0){
       System.out.print("foo");
     }
     if (i % 5 == 0){
       System.out.print("biz");
     }
     if (i % 7 == 0){
       System.out.print("baz");
     }
     System.out.println();
   }
   ```

  真正工作的时候代码量没有现在这么大，可能一天是200--300行，也就是说我现在学习的过程中，一天至少要敲500行代码。我猜的

---

Here is May 22, 2021

### Day 05 Java基本语法

#### 每日一考

1. `switch` 后面使用的表达式可以是哪些类型的数据？
   6种：`byte, short, int, char, 枚举类型(JKD 5.0), String(JKD 7.0)`

2. 使用`switch`语句改写下列`if`语句：

   ```java
   int a = 3;
   int x = 100;
   if(a == 1)
     x += 5;
   else if(a == 2)
     x += 10;
   else if(a == 3)
     x += 16;
   else
     x += 34;
   
   //改写
   switch(a)
     case 1:
     x += 5;
   	break;
   	case 2:
     x += 10;
   	break;
   	case 3:
     x += 16;
   	break:
   default:
     x += 34;
   
   
   ```

   

3. 谈谈三元运算符、`if-else`语句、`switch-case`结构的使用场景的理解
   `if-else`语句是最通用的，意思是能用三元的和能用`switch-case`的都能用`if-else`，反之不成立
   如果不是特别麻烦尽可能使用三元或者`switch-case`的话，因为执行效率稍微高一点点

4. 如何从控制台获取`String`和`int`型的变量，并输出？

   ```java
   import java.util.Scanner;
   Scanner scan = new Scanner(System.in);
   
   String str = scan.next();
   int n1 = scan.nextInt();
   ```

   

5. 使用`for`循环便利100以内的奇数，并计算所有的奇数的和并输出

   ```java
   int sum = 0;
   for(int i = 1; i < 101; i++){
     if (i % 2 == 1){
       sum += i;
     }
   }
   System.out.println("100以内所有奇数的和是 " + sum);
   ```

#### for循环例题

```java
/*
题目：输入两个正整数m和n，求其最大公约数和最小公倍数
说明：break关键词的使用
*/
import java.util.Scanner;

class ForTest{
  
  public static void main(String[] args){
    
    Scanner scan = new Scanner(System.in);
    System.out.println("请输入第一个正整数");
    int m = scan.nextInt();
    System.out.println("请输入第二个正整数");
    int n = scan.nextInt();
    
    //最大公约数：获取两个数中的最小值，从它开始往下走，找到（公约数）就停
    for(int i = (m < n )? m : n; i>0; i--){
      if (m % i == 0 && n % i == 0)
        System.out.println("最大公约数为：" + i);
      	break;
    }
    //最大公约数：获取两个数中的最小值，从它开始往下走，找到（公约数）就停
    int max = ( m < n) ? n : m;
    for (ing i = max;i <= m * n;i++){
      if (i % m == 0 && i % n == 0){
        System.out.println("最小公倍数为：" + i);
        break;
      }
    }
    
    
  }
  
}
```

#### while循环

```java
/*
while循环依然是有四个要素
1. 初始化条件
2. 循环条件 ==>是`boolean`类型
3. 循环体
4. 迭代条件

1
while(2){
3;
4;
}
*/
int i = 0;
while(i<100){
  //do something
  i++;
}
```

`for`循环和`while`循环是可以互相转换的。如果一定要说区别的，`while`循环指标（初始化条件的作用域）`i`在`while`循环外面也有用

#### do-while循环

```java
/*
do-while循环依然是有四个要素
1. 初始化条件
2. 循环条件 ==>是`boolean`类型
3. 循环体
4. 迭代条件
*/
1
do{
3;
4;
}while(2)
```

循环体至少会执行一次，这是跟`while`的主要区别。在实际开发中，还是`for`循环和`while`循环使用的 多一些。

#### 循环嵌套例题

```java
/* 
输出100以内的所有质数
从2开始到这个数-1开始，都不能被这个数整除
*/

class PrimeNumberTest{
  
  public static void main(String[] args){
    
    for (int i = 2; i < 101; i++){//遍历100以内自然数
      boolean ifPrime = true;
      
      for (int j = 2; j < i; j++){//j: 去被i除
        if (i % j == 0){
          isPrime = false;
        }
        
      }
      if(isPrime){
        System.out.println(i);
      }
    }
    
  }
}
```

写成上面这样，问题解决了但是效率比较低，下面考虑优化

```java
/* 
输出100以内的所有质数，以及优化
Java程序计时
*/

class PrimeNumberTest{
  
  public static void main(String[] args){
    boolean ifPrime = true;
    long start = System.currentTimeMillis();
    
    for (int i = 2; i < 101; i++){//遍历100以内自然数
      /* j 从 2 只需要到 sqrt i 即可*/
      for (int j = 2; j < Math.sqrt(i); j++){//j: 去被i除
        if (i % j == 0){
          isPrime = false;
          /* 优化一：这里加个break 对本身非质数的自然数是有效的*/
          break;
        }
      }
      if(isPrime){
        System.out.println(i);
      }
      //reset isPrime
      isPrime = true;
    }
    long end = System.currentTimeMillis();
    
    System.out.println("所花费的时间为" + (end - start) / 1000);
  }
}
```

|            | 使用范围                    | 循环中使用的作用 | 相同点                     |
| ---------- | --------------------------- | ---------------- | -------------------------- |
| `break`    | `switch-case`<br />循环结构 | 结束当前循环     | 关键字后面不能声明执行语句 |
| `continue` | 循环结构                    | 结束当次循环     | 关键字后面不能声明执行语句 |

```java
/*
带标签的break和continue语句
*/
label:for(int i = 1; i < 5; i++){
  
  for(int j = 1; j < 10; j++){
    
    //...
    break label;
    
  }
}

//直接来一个质数输出的实现方法二
class PrimeNumberTest2{
  
  public static void main(String[] args){
    long start = System.currentTimeMillis();
    
    label:for (int i = 2; i < 101; i++){//遍历100以内自然数
      /* 优化二 j 从 2 只需要到 sqrt i 即可*/
      for (int j = 2; j < Math.sqrt(i); j++){//j: 去被i除
        if (i % j == 0){
          continue label;
        }
      }
      //能执行到这里的都是质数
    }
    long end = System.currentTimeMillis();
    
    System.out.println("所花费的时间为" + (end - start) / 1000);
  }
}
```

---

here is May 23, 2021

#### 项目一

```java
class FamilyAccount{
  
  public static void main(String[] args){
    
    boolean isFlag = true;
    
    String details = "Income/Expense\tTotal\tAmount\tRemark\n";//Used for log use input
    //initial amount
    int balance = 1000;
    while(isFlag){
      
      System.out.println("------------Family Account------------\n");
      System.out.println("            1.\tDetails\n");
      System.out.println("            2.\tLog Income\n");
      System.out.println("            3.\tLog Expense\n");
      System.out.println("            4.\tQuit\n");
      
      //获取用户输入
      char selection = Utility.readMenuSelection();
      switch (selection){
        case '1':
          System.out.println("------------Account Summary------------");
          System.out.println(details);
          System.out.println("---------------------------------------");
          break;
        case '2':
          System.out.println("Enter income amount: ");
          int money = Utility.readNumber();
          System.out.print("Enter income detail: ");
          String info = Utility.readString();
          
          //process balance
          balance += money
          //process details
          details += ("income\t" + balance + "\t" + money + "\t" + info + "\n");
          
          System.out.print("------------Log Complete------------");
          break;
        case '3':
          System.out.println("Enter expense amount: ");
          int money = Utility.readNumber();
          System.out.print("Enter expense detail: ");
          String info = Utility.readString();
          
          //process balance
          if (balance >= money){
            balance -= money
          	//process details
          	details += ("expense\t" + balance + "\t" + money + "\t" + info + "\n");
            
          }else{
             System.out.print("------------Not Enough Blance------------");
          }

          
          System.out.print("------------Log Complete------------");
          break;
        case '4':
          System.out.println("Are you sure you want to quit? [Y/N]");
          char isExit = Utility.readConfirmSelecion();
          if (isExit == 'Y'){
            isFlag = false;
          }
      }
    }
    
  }
}
```



### Day 06 Eclipse与数组

#### 每日一考

1. 循环结构是如何最后退出循环的？有哪些不同情况，说明
   循环条件为`false`的时候、循环体内有`break`
   注意:`continue`不能算做结束循环，`return`和异常都会结束循环，但不是正常的方式

2. 程序题：

   ```java
   label: for (int i = 1; i <= 4; i++) {
   			for (int j = 1; j <= 10; j++) {
   				if (j % 4 == 0) {
   					continue label;
   				}
   				System.out.print(j);
   			}
   			System.out.println();
   }
   ```

   输出结果是：`123123123123`

3. 一个数如果恰好等于它的因子之和，这个数就称为"完数"。例如6=1＋2＋3。编程 找出1000以内的所有完数。（因子：除去这个数本身的其它约数）

   ```java 
   int factor = 0;
   for (int i = 1; i < 1001; i ++ ){
     
     for(int j = i; j <= i/2;j++){
       if (i % j == 0){
         factor += j;
       }
     }
     if ( i == factor ){
       
       System.out.println(i);
     }
       factor = 0;
   }
   ```

   

4. 说明break和continue使用上的相同点和不同点
   `break` 可以用在循环和`switch-case`但是`continue`只能用在循环结构中
   `continue`只能结束当次循环
   相同点：后面都不能再接语句了

5. 从控制台输出如下结构

   ```java
   /*
   
   ******
   *****
   ****	
   ***	
   **	
   *
   
   */
   for(int i = 6; i > 0; i--){
     
     for(int j = i; j > 0; j --)
       System.out.print('*');
     System.out.prinln();
   }
   U+2387
   &#9658;
   ```

#### Hello Eclipse

* 透视图的设置，已搞定
* 用Eclipse编写Hello World程序，已搞定
* Windows 下的`alt + /`现在在Mac下没有搞定
  * 现在搞定了，需要把默认的`contenct assist 改成⎇+/`&#9095; 
* 导入已有的工程
  `File > Import > Gneral > Existing Projects into Workspace`
  牵扯到改名的问题
  改已经Workspace里面的：`refactor > rename `
* 查看源代码的问题:
  * 按住`command` 加鼠标点击就可以进入源码
  * `command + o`可以开启搜索文档
  * &#8984; 8984

#### 数组

* 数组Array，是多个 同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对数据进行统一管理
* 数组的相关概念
  * 数组名
  * 元素
  * 角标、下标、索引 index
  * 数组的长度：数组元素的个数、一旦确定不能修改
* 数组的特点：
  * 有序排列的
  * 数组属于引用数据类型的变量；数组的元素既可以是基本数据类型，也可以是引用数据类型
  * 创建数组的时候是在内存中开辟一块连续的空间，而数组名中引用的是这块连续空间的首地址
* 数组的分类：
  * 按照维数
  * 按照元素的类型：基本数据类型元素的数组，引用数据类型元素的数组

#### 一维数组的使用

1. 声明和初始化

   ```java
   int[] ids; //声明
   		
   //静态初始化:数组的初始化和数组元素的初始化同时进行
   ids = new int[] {1001,1002,1003,10004};
   
   //动态初始化:数组的初始化和数组元素的初始化分开进行
   String[] names = new String[5];//声明和初始化一起做了
   ```

   数组一旦初始化完成了，长度就确定了

2. 调用指定位置的元素

   ```java
   ids[0] = 1;
   
   names[names.length -1] = "Chris Jin"
   ```

   数据库的表索引/数据库表的列索引是从1开始的

3. 获得数组的长度

   ```java
   int[] arr = new int[10];
   len = arr.length;
   ```

   

4. 遍历数组

   ```java
   int[] arr = new int[10];
   for(int i = 0; i < arr.length; i++){
     //process arr[i];
   }
   ```

   

5. 数组元素默认初始化值

   ```java
   /*
   基本数据类型的默认初始化值：
   
   */		
   //整型：0
   int [] arr = new int[4];
   for(int i = 0; i < arr.length; i++) {
     System.out.println(arr[i]);
   }
   	System.out.println("****************");
   //浮点型：0.0
   float [] arr2 = new float[4];
   for(int i = 0; i < arr2.length; i++) {
     System.out.println(arr2[i]);
   }
   	System.out.println("****************");
   //字符型：'\u0000'
   char [] arr3 = new char[4];
   for(int i = 0; i < arr3.length; i++) {
     System.out.println(arr3[i]);
   }
   	System.out.println("****************");
   //布尔型：false
   boolean [] arr4 = new boolean[4];
   for(int i = 0; i < arr4.length; i++) {
     System.out.println(arr4[i]);
   }
   /*
   引用数据类型的默认初始化值：
   */
   
   //引用数据类型：null
   String[] str = new String[5];
   System.out.println(str[0]);
   ```

6. 内存解析
   内存的结构是由JVM规范规定的
   ![JVM内存解析](/Users/chris/Coding Bootcamp/Notes/Backend/00. Java基础/Memory_Structure.png)

#### 二维数组的使用

我们可以看成是一维数组 array1又作为另一个一维数组array2的元素而存 在。从数组底层的运行机制来看，其实没 有多维数组。

1. 声明和初始化

   ```java
   //静态初始化
   int[][] arr1 = new int[][]{{1,2,3},{4,5},{6,7,8}};
   //动态初始化
   String[][] arr2 = new String[3][2];
   String[][] arr2 = new String[3][];//这么写也行
   
   //前面的方括号位置几乎可以随便放
   int[] arr3[] = new int[3][];
   //类型推断
   int[] arr4[] = {{1,2,3},{4,5},{6,7,8}};
   
   System.out.println(arr2[1][0]);//报错
   arr2[1] = new int
   ```

   

2. 调用指定位置的元素`arr1[0][1] = 6;  `

3. 获得数组的长度`arr1.length`是3，`arr1[0].length`是3

4. 遍历数组

   ```java
   for(int i = 0; i < arr4.length; i++){
     for(int j = 0; i < arr4[i].length; j++)
       //process arr4[i][j];
   }
   ```

   

5. 数组元素默认初始化值

   ```java
   	String[][] arr2 = new String[3][5];
   	
   	System.out.println(arr2);//[[Ljava.lang.String;@2a139a55
   	System.out.println(arr2[0]);//[Ljava.lang.String;@15db9742
   	System.out.println(arr2[0][0]);//null
   	
   	String[][] arr1 = new String[3][];
   	
   	System.out.println(arr1);//[[Ljava.lang.String;@6d06d69c
   	System.out.println(arr1[0]);//null
   	System.out.println(arr1[0][0]);//java.lang.NullPointerException
   ```

   

6. 内存解析
   略，图在心中

### Day 07数组

#### 每日一考

1. 一维数组初始化的两种方式

   ```java 
   //静态初始化
   int[] arr1 = new int[] {123};
   //支持类型推断
   int[] arr1 = {123};
   //动态初始化
   int arr1[] = new int[3];
   ```

   

2. 二维数组初始化的两种方式

   ```java
   //静态初始化
   int[][] arr2 = new int[][]{{123,456},{7,8}}
   //支持类型推断
   int[][] arr2 = {{123,456},{7,8}}
   //动态初始化
   int[][] arr3 = new int[4][3];
   int[][] arr4 = new int[4][];
   ```

   

3. 遍历如下的二维数组`int[][] arr = new int[][]{{1,2,3},{4,5},{6,7,8}};`

   ```java
   for(int i = 0; i < arr.length; i++){
     for(int j = 0; j <arr[i].length; j++){
       //process arr[i][j];
     }
   }
   ```

   

4. 不同类型的一维数组元素的默认初始化值是多少
   `int,short,long: 0`；`float,double: 0.0`；`boolean: false`；`char: \U0000`；引用数据类型`null`

5. 一维数组的内存解析：

   ```java 
   String[] strs = new String[5];
   str[2] = "Tom";
   strs = new String[3];
   
   //Stack: strs = 0x1212; Heap: 0x1212--连续五个地址值--0x1213,0x1214,0x1215,0x1216,全是null
   //Stack: strs = 0x1212; Heap: 0x1214 变成 Tom，其实Tom在字符串常量池中，所以其实还是个地址值
   //Stack: strs = 0x2121; Heap: 0x2121--连续三个地址值--0x2122,0x2123,全是null
   ```

   

#### 数据结构浅谈

数据结构解决两种问题：

1. 数据与数据之间的逻辑关系：集合、一对一（链表）、一对多（树）、多对多（网络、地图）
2. 数据的存储结构：
   线性表：刻画一对一的关系，顺序表（数组）、链表、栈、队列（消息队列）
   树形结构：二叉树（B tree、B+tree）
   图形结构：

算法：没有边界，排序算法，搜索算法等

---

here is May 24, 2021

#### 数组练习题

1. `int[] x, y[];`的结果是`x`是`int`型一维数组，`y`是`int`型二维数组`int[] x; int[] y[];`

2. 杨辉三角形

   ```java
   package com.atguigu.exer;
   
   public class YangHuiTest {
   public static void main(String[] args) {
   	//1. 声明并初始化二维数组
   	int[][] yanghui = new int[10][];
   	//2. 给数组的元素赋值
   	for(int i =0; i < yanghui.length; i++) {
   		yanghui[i] = new int[i+1];
   		//首末元素，连续赋值
   		yanghui[i][0] = yanghui[i][i] = 1;
   		//给首末元素赋值
   		//if(i > 1) {
   		for(int j = 1; j < yanghui[i].length - 1; j++) {// j < i 是i错的！
   			yanghui[i][j] = yanghui[i-1][j] + yanghui[i-1][j-1];
   		}
   		//}去掉也可以
   	}
   	//3. 遍历二维数组
   	for(int i = 0; i < yanghui.length; i++) {
   		for(int j = 0; j < yanghui[i].length; j++) {
   			System.out.print(yanghui[i][j] + "\t");
   		}
   		System.out.println();
   	}
   }
   }
   ```

   

#### 常用算法

1. 数组元素赋值（杨辉三角、回姓数）

   ```java
   package com.atguigu.java;
   /*
   回形数
   */
   import java.util.Scanner;
   
   public class HuiXingShu1 {
   	public static void main(String[] args) {
   		Scanner scan = new Scanner(System.in);
   		
   		System.out.print("Please Enter the Size of the problem:");
   		int size = scan.nextInt();
   		
   		int[][] arr = new int[size][size];
   		
   		int l = 0, top = 0, state = 0;// left and top limit
   		int num = 1;//the next number to fill in
   		int r = size -1, bot = size -1; // right and bottom limit 
   		int row, col;// current position
   		row = col = 0;
   		
   		while(num <= size * size) {
   			System.out.println("State is: " + state);
   			switch(state) {
   			
   			case 0:
   				//going right
   				while(col <= r) {
   					arr[row][col] = num;
   					num++;
   					col++;
   				}
   				col = (col > r)?r : col;
   				top ++;
   				row ++;
   				System.out.println("row index: " + row + " column index: " + col);
   				break;
   			case 1:
   				//going down
   				while(row <= bot) {
   					arr[row][col] = num;
   					num++;
   					row++;
   				}
   				row = (row > bot)?bot : row;
   				r--;
   				col--;
   				System.out.println("row index: " + row + " column index: " + col);
   				break;
   			case 2:
   				//going left
   				while(col >= l) {
   					arr[row][col] = num;
   					num++;
   					col--;
   				}
   				bot--;
   				row--;
   				col = (col < l)?l : col;
   				System.out.println("row index: " + row + " column index: " + col);
   				break;
   			case 3:
   				//going up
   				while(row >= top) {
   					arr[row][col] = num;
   					num++;
   					row--;
   				}
   				row = (row < top)?top : row;
   				l++;
   				col++;
   				System.out.println("row index: " + row + " column index: " + col);
   				break;
   			
   			}
   			
   			//update state
   			state = (state + 1) % 4;
   
   			for(int i = 0; i < arr.length; i++) {
   				for(int j=0; j<arr[i].length;j++) {
   					System.out.print(arr[i][j] + "\t");
   				}
   				System.out.println();
   		
   			}
   			System.out.println("********");
   		}
   		
   		scan.close();
   		System.out.print("Stopped");
   }
   }
   ```

   

2. 求数值型数组中元素的最大值、最小值、平均数、总和等
   随机数`(int) (Math.random() * (max - min + 1)) + min`

3. 数组的复制、反转、查找（Linear Search; Binary Search）

   ```java
   //数组的复制
   int[] arr1, arr2;
   arr1 = {1,2,4,45,5};
   arr2 = new int[arr1.length];
   for(int i = 0; i < arr1.length; i++){
     arr2[i] = arr1[i];
   }
   
   //数组的反转
   //方式一：注意别i的终止条件，别搞两遍了
   for(int i = 0; i < arr1.length / 2 ; i++) {
     String temp = arr[i];
     arr[i] = arr[arr.length - i - 1];
     arr[arr.length - i -1] = temp;
   }
   //方式二
   for(int i = 0, j = arr.length; i < j;i++,j--) {
     String temp = arr[i];
     arr[i] = arr[j];
     arr[j] = temp;
   }
   
   	//Binary Search
   	//prerequisite: sorted list
   	boolean isNotFind = true;
   	int[] arr2 = new int[] {-99, -34, 2,3,4,5,6,7,1234,12567,79345};
   	int dest1 = -34;
   	int head = 0;//初始的首索引
   	int end = arr2.length;//初始的末索引
   	
   	while(head <= end) {
   		int middle = (head + end)/2;
   		if(dest1 == arr2[middle]) {
   			System.out.println("Find item " + dest1 + " at " + middle);
   			isNotFind = false;
   			break;
   		}else if (arr2[middle] > dest1){
   			end = middle -1;
   		}else {
   			head = middle + 1;
   		}
   		
   	}
   	if(isNotFind){
   		System.out.println("item not found");
   	}
   ```

   

4. 数组元素的排序算法
   时间复杂度，空间复杂度，稳定性
   内部排序：内存中搞定的
   外部排序：数据量比较大，需要借助外部存储设备才能搞定
   <span style="color:red;">冒泡、快排</span>需要会手写
   <span style="color:orange;">堆排序、和并归</span>需要知道

5. 算法的特征
   5.1 输入(Input)：0个或者有多个输入数据，这些输入必须有清楚的描述和定义
   5.2 输出(Output)：至少1个或多个结果
   5.3 有穷性(Finiteness)：在有限步骤内结束，并在可接受的时间范围内完成
   5.4 确定性(Definiteness)：每一步都有确定的含义，没有二义性
   5.5 可行性(Effectiveness)：算法的每一步都是清楚且可行的，用纸笔也能搞定

```java
/*
冒泡
*/
for(int i = 0; i < arr.length - 1; i++) {
		
		for(int j = 0; j < arr.length - 1 -i; j++) {
			if (arr[j] > arr[j+1]) {
				int temp = arr[j];
				arr[j] = arr[j+1];
				arr[j + 1] = temp;
			}
			
		}
		
	}
	
	for (int i = 0; i < arr.length; i++) {
		
		System.out.print(arr[i] + "\t");
	}
```



#### Arrays工具类

`java.util.Arrays`

1. 判断两个数组是否相等`Arrays.equals(int[] a, int[] b)`
2. 输出数组的信息`Arrays.toString(int[] a );`底层用到`StringBuilder()`
3. 将指定值填充到数组之中`void fill(int[] a, int val);`
4. 对数组进行排序`void sort(int[] a)`底层用到快排
5. 对排序后的数组进行二分法搜索`int binarySearch(int[] a, int key)`找到返回索引，找不到返回一个负数

#### 常见异常

出现异常程序就终止了，后面的都不执行了

1. 角标越界异常`ArrayIndexOutOfBountException`
2. 空指针异常`NullPointerException`

---

here is May 24, 2021

### Day 08 OOP上

#### 每日一考

1. 使用冒泡排序，实现如下的数组从小到大排序。`int[] arr = new int[]{34,5,22,-98,6,-76,0,-3};`

   ```java
   public static void main(String[] args) {
   	
   	int[] arr = new int[]{34,5,22,-98,6,-76,0,-3};
   	
   	for(int i = arr.length - 1; i > 0; i--) {
   		for(int j = 0; j < i; j ++) {
   			if(arr[j] > arr[j+1]) {
   				int temp = arr[j];
   				arr[j] = arr[j+1];
   				arr[j+1] = temp;
   			}
   		}
   
   	}
   	for(int i = 0; i < arr.length; i++) {
   		System.out.print(arr[i] + " ");
   }
   }
   ```

   

2. 如何反转上面的数组。请代码实现

   ```java
   int temp = 0;
   for(int i = 0; i < arr.length / 2; i++) {
     temp = arr[i];
     arr[i] = arr[arr.length - i - 1];
     arr[arr.length - i - 1] = temp;
   }
   ```

   

3. 复制上述数组，得到一个新的数组

   ```java
   int[] arr2 = new int[arr.length];
   	for(int i = 0; i < arr.length; i++) {
       arr2[i] = arr[i];
     }
   System.out.println();
   System.out.println("***************");
   for(int i = 0; i < arr2.length; i++) {
     System.out.print(arr2[i] + " ");
     }
   ```

   

4. 使用线性查找，从上述数组中查找22是否存在。存在，返回所在位置的索引。不存在，输出提示信息。

   ```java
   	int tar = 22;
   	boolean isFound = false;
   	for(int i = 0; i < arr.length; i++) {
   		if(arr[i] == tar) {
   			System.out.println(tar + " is found at index " + i);
   			isFound = true;
   			break;
   		}
   	}
   	if(!isFound) {
   		System.out.println(tar + " is NOT found");
   	}
   ```

   

5. 数组中常见的异常有哪些？请举例说明
   角标越界异常`ArrayIndexOutOfBoundException`
   空指针异常`NullPointerException`

#### 面向对象概述

这部分是核心，后面基本都是应用；特点是内容多，细节多，都需要理解和记忆。

<span style="color:red;">大处着眼，小处着手</span>

学习的三条主线，并行推进

1. Java类及类的成员：
   属性、方法、构造器；代码块、内部类
2. 面向对象的三大特征：
   封装性、继承性、多态性；先把代码弄明白，思想层面的事情后面再体现；如果要说有四个就是抽象性
3. 其他关键字：
   `this`，`super`，`static`，`final`，`abstract`，`interface`，`package`，`import`，等

#### POP vs OOP

面向过程POP与面向对象OOP的对比:<span style="color:red;">大象装进冰箱</span>

面向过程强调的是功能行为，以函数为最小单位，考虑怎么做

1. 把冰箱门打开
2. 抬起大象，塞进冰箱
3. 把冰箱门关上

面向对象对功能进行封装，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做

```java
人{
  打开(冰箱){
    冰箱.打开();
  }
  抬起(大象){
    大象.进入(冰箱)
  }
  关闭(冰箱){
    冰箱.闭合;
  }
}
冰箱{
  打开(){}
  闭合(){}
  
}
大象{
  进入(冰箱){
  }
  
}
```

程序员：从面向过程的执行者转化成了面向对象的指挥者

思路及过程：

1. 分析需求，选择问题所针对的现实世界中的实体
2. 从实体中寻找解决问题相关的属性和功能，这些属性和功能形成了概念中的类
3. 把抽象的实体用计算机语言来表述，形成计算机世界中的类
4. 类实例化成计算机世界中的对象，对象是解决计算机世界中问题的最终工具

#### Java类和对象

`Class`和`Object`是面向对象核心概念

* **类**是对一类事物的描述，是抽象的、概念上的定义。相当于图纸、蓝图
* **对象**是实际存在的该类事物的每个个体，因为也成为**实例(instance)**。相当于产品
  * Java语言万物皆对象

面向对象程序设计的重点是类的设计，而类的设计就是类成员的设计。类的内部结构主要有两个：

* `属性 = 成员变量 = field = 域 = 字段` 对应类中的
* `方法 = 成员方法 = method = 函数` 功能和行为

类和对象的使用（面向对象思想落地实现）：

1. 创建类、设计类的成员（这一步是最花时间的）
2. 创建类的对象
3. 通过`对象.属性`或`对象.方法`调对象中的结构

每个对象有自己独立的一套属性，属性也有默认初始化值（非`static`）
![复杂版内存解析](/Users/chris/Coding Bootcamp/Notes/atguigu-notes/Backend/00. Java基础/内存解析.png)

属性（成员变量）和局部变量的异同

1. 相同点:
   1.1 都是变量，所以定义格式是一样的：数据类型 变量名 = 变量值；
   1.2 先声明，后使用
   1.3 都有其作用域
2. 不同点：
   2.1 声明位置不同：
   <span style="color:red">属性</span>：直接定义在类的一对`{}`内
   <span style="color:red">局部变量</span>：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
   2.2 权限修饰符不同：
   <span style="color:red">属性</span>：可以在声明时，指明其权限，使用权限修饰符
   例如`private, public, 缺省, protected` 封装性的时候再说
   目前，都是用缺省就可以了
   <span style="color:red">局部变量</span>：不能使用权限修饰符
   2.3 默认初始化值的不同
   <span style="color:red">属性</span>：类的属性，根据其类型，都有默认初始化值
   <span style="color:red">局部变量</span>：没有默认初始化值=> 使用前必须显式初始化
   特别的：形参在调用时赋值即可
   2.4 内存中加载的位置不一样
   <span style="color:red">属性</span>：加载到堆空间中（非`static`）
   <span style="color:red">局部变量</span>：加载到栈空间中

方法声明格式，按照有无形参，有无返回值分为4类

|        | 无返回值                   | 有返回值                     |
| :----: | :------------------------- | ---------------------------- |
| 无形参 | `void method1(){}`         | `String method2(){}`         |
| 有形参 | `void method3(形参列表){}` | `String method4(形参列表){}` |

`static, final, abstract`也可以用来修饰方法，但是后面再说

```java
/*方法声明：权限修饰符 返回值类型 方法名 (形参列表){

}
*/

//如果声明的时候有返回值，则一定要有返回值，带分支的话也是每个分支都要有
public int getNum(){
  
  return 5;
  
}
//如果声明的时候没有返回值，则仍可以使用return来结束方法体，但不是一定要有

//return 后面不能再有执行语句
```

**形参列表格式：**

`[数据类型1 形参1， 数据类型2 形参2， 数据类型3 形参3，...]`

**方法体：**最多的工作是在这个地方，方法内部可以调方法，但是不能定义新的方法；调用自己叫递归，用不好可能会栈溢出

---

here is May 26, 2021

### Day 09 OOP上

#### 每日一考

1. 面向对象思想编程内容的三条主线是什么？
   Java类及类的成员：属性，方法，<span style="color: red;">构造器</span>；代码块，内部类
   面向对象三大特征：封装性、继承性、多态性、如果要第四个就是抽象性
   其他关键字：`statci`,`final`,`abstract`,`this`,`super`

2. 谈谈你对面向对象中类和对象的理解，并指出二者的关系
   类是泛指是抽象的，对象是特指是具体的。类是蓝图，对象是实例。Java里面万物皆对象

3. 面向对象思想的体现一：类和对象的创建和执行操作有哪三步？
   3.1 设计类
   3.2 创建：实例化对象
   3.3 调用属性和方法

4. 画出如下代码在执行时的内存分配情况

   ```java
   class Car{
          String color = "red";
          int num = 4;
          void show(){
   			  int a = 10;
   	          System.out.println("color="+color+",num="+num);
          }
   }
   class CarTest {
   	public static void main(String[] args) {
   		Car c1 = new Car();   
   		Car c2 = new Car(); 
   		c1.color = "blue";  
   		c1.show();   
   		c2.show();
     }
   }
   
   ```

   

5. 类的方法内是否可以定义变量？是否可以调用属性？是否可以定义方法？是否可以调用方法？
   可、可、不可、可

JVM内存解析：编译完源程序以后，生成一个或多个字节码文件。我们使用JVM中的类加载器和解释器对生成的字节码文件进行解释运行。意味着：需要讲字节码文件对应的类加载到内存中，涉及到内存解析

栈：局部变量存储在虚拟机栈中
堆：`new`出来的结构，比如数组，对象，加载在堆空间中
方法区：类的加载信息、常量池、静态域

#### 万物皆对象的理解

1. 在`Java`语言的范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构
2. 涉及到`Java`语言跟前端的`HTML`和后端的数据库在`Java`层面交互时，都体现为类、对象

匿名对象
没有显示给某给变量名，只能调用一次，开发中用的多

举例：新对象的地址已经赋给形参了

```java
class Phone{
	double price;
	
	public void sendEmail() {
		System.out.println("send Email");
	}
	
	public void playGame() {
		System.out.println("Play Game.");
	}
  
  public void showPrice(){
    System.out.println("Price is " + price);
  }
}

class PhoneMall{
  public void show(Phone phone){
    phone.sendEmail();
    phone.playGame();
  }
  
}

//别的主方法中：
new Phone().sendEmail(); 
PhoneMall mall = new PhoneMall();
mall.show(new Phone());
```

自己写类的时候尽量不要用和系统自带类重名的结构

#### 方法的重载

1. 定义：在同一个类中，允许存在一个以上同名方法，只要他们的参数个数或者参数类型不同即可。同名方法之间叫做重载
   “两同一不同”：同一个类，同方法名、参数列表不同

2. 举例：下列四个都构成重载

   ```java
   	public void getSum(int i, int j) {
   		System.out.println("1");
   	}
   	public void getSum(double d1, double d2) {
   		System.out.println("2");
   	}
   	
   	public void getSum(String s, int i) {
   		System.out.println("3");
   	}
   	
   	public void getSum(int i, String s) {
   		System.out.println("4");
   	}
   ```

3. 返回值类型无所谓，权限无所谓，形参名无所谓，如果把第一个getSum干掉，此时调用`getSum(1,2)`会打印`2`因为自动类型提升

4. 通过对象调用方法时，如何确定某一个指定的方法
   方法名 ==还要看==> 参数列表

#### 可变个数形参

* `JavaSE 5.0`加入了Varargs，允许直接定义能和多个实参匹配的形参。
* 格式`数据类型 ...形参名`。当调用可变个数的方法时，传入的参数可以是0个，1个，2个...
* 与其他同方法名，不同形参列表的方法构成重载
* 跟同类型数组参数的同名方法被认为是同一个方法，下面这俩不行
  * `public void show(String ... args){}`
  * `public void show(String[] args){}`
* 参数`args`就当成数组就可以了
* 必须声明在末尾，也就意味着只能有一个

#### Java方法参数传递：值传递机制

Java的实参值是如何传递的？都是值传递

* 基本数据类型是将实际存储的值赋给被赋值的变量
* 引用数据类型是将变量存储的地址值赋给被复制的变量

方法的形参传递机制。

* 形参：方法定义时，小括号内的参数
* 实参：调用方法的时候实际传递给参数赋的数据

---

Here is May 27, 2021

### Day 10 OOP上

#### 每日一考

1. 什么是方法的重载？
   两同一不同，在同一个类下的，同方法名不同形参列表的两个或多个方法相互构成重载
2. 说明Java方法中的参数传递机制的具体体现？
   值传递机制：体现在基本数据类型的变量，将实参的所存储的数据值复制给被传递的形参。
   引用数据类型则是将实参所存储的地址值传递给被赋值的对象
3. 成员变量和局部变量在声明的位置上、是否有默认初始化值上、是否能有权限修饰符修饰上、内存分配的位置上有何不同？
   成员变量直接声明在类的一对`{}`内，具有默认初始化值，可以使用权限修饰符，非`static`的都在堆空间中
   局部变量声明在：方法内，方法形参列表，构造器内，构造器形参列表，以及代码块当中
4. 谈谈return关键字的使用
   用来结束方法调用，对于有返回值的方法，用`return`关键字指明所要返回的值
5. 提供如下代码的内存解析
   ![image-20210528140207977](/Users/chris/Coding Bootcamp/Notes/atguigu-notes/Backend/00. Java基础/练习题.png)

#### 面向对象特征之一：封装与隐藏

* 为什么要封装？封装的作用和含义？
  * 用洗衣机只需要按开关就可以了，不需要知道内部怎么运作的，没必要碰电动机
  * 要开车，没必要知道发动机和传动的原理
* ​	我们写代码搞开发也是一样，我们用的是别人的API
  * 高内聚：类内部数据操作细节自己完成，不允许外部干涉
  * 低耦合：进队外暴露少量的方法用于使用
* 隐藏对象内部的复杂性，之队外公开简单的接口（不是后面的`Interface`） 从而提高系统的可扩展性和可维护性

1. 问题的引入

   当我们创建一个类的对象以后，我们可以通过`对象.属性`的方式，对对象的属性进行复制，这里，复制操作要收到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件，但是在实际问题中，我们往往需要给属性赋值有其他方法。这个需求仅靠属性声明不能满足。除此之外我们要禁止用户用`对象.属性`的方式对属性进行赋值`private`的使用。

2. 封装性的体现(只是体现，不等于封装性)
   我们将类的属性xxx私有化`private`，同时提供公开的`public` `getter/setter `方法来获取和设置属性
   拓展:其他封装性的体现，类内部自己使用的（不对外暴露的）私有方法，高内聚，单例模式也是封装性的体现

3. 封装性的体现需要权限修饰符来配合

   Java一共有四种，从小到大排列`private < （缺省）default < protected < public`
   `private`： 类内部
   `缺省`：类内部、同一个包

   `protected`：类内部、同一个包、不同包的子类
   `public`：类内部、同一个包、不同包的子类、同一个工程

* 四种可以用来修饰类及类的内部结构：
  * 属性、方法、构造器、内部类，注意，代码块不行
* 用来修饰类：`class`只能用`public`和`缺省`
* 总结： `Java`提供了四种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小

#### 构造器`constructor`

1. 构造器的作用：创建类的对象`new + constructor`、可以初始化对象的属性
2. 任何一个类都有构造器，如果没有显示定义构造器，则系统默认提供一个空参的构造器(权限与类一样，public或者缺省)
   一旦我们显示定义了类的构造器之后，系统就不再提供默认空参构造器
3. 构造器的定义格式：`权限修饰符 类型名(形参列表){}`
4. 不建议将构造器理解为一种特殊的方法，主要是构造器的作用与方法不同，且二者发生作用的时间也不一样
5. 一个类中，至少会有一个构造器

属性赋值的先后顺序：目前为止，对象属性赋值的四种方法

1. 默认初始化
2. 显示初始化
3. 构造器中初始化
   ***前三种之所以叫初始化，是因为只有一次，后面这种可以反反复复调用***
4. 通过`对象.方法`/`对象.属性`的方式

`Java Bean`是一种`Java`语言写成的，可以重用的组建，满足三个条件的Java类叫做Java Bean：

1. 类是公共的
2. 有一个无参的公共构造器
3. 有属性及对应的`getter/setter`方法

使用`JavaBean`将功能、处理、值、数据库访问和其他任何可以用`Java`代码创造的怼心啊哥进行打包，并且其他的开发者可以通过内部的JSP页面，Servlet，其他JavaBean，applet程序或者应用来使用这些对象。

用户可以认为JavaBean提供了一种随时随地的复制粘贴功能，不用关心任何改变。

#### 关键字`this`

* `this`可以理解为当前对象（方法中）或者当前正在创建的对象（构造器中），可以用来修饰属性、构造器、方法。
  * 在类的方法中，我们可以使用`this.属性`或`this.方法`的方式调用当前的属性或者方法，但是，通常情况下，我们都选择省略。特殊情况下，如方法的形参和类的属性同名的时候我们必须显示使用`this.变量`的方式表明次变量是属性，而非形参
  * 在类的构造器中，我们可以使用`this.属性`或`this.方法`的方式调用当前的属性或者方法，但是，通常情况下，我们都选择省略。特殊情况下，如构造器的形参和类的属性同名的时候我们必须显示使用`this.变量`的方式表明次变量是属性，而非形参
* `this（形参列表）`修饰和调用本类中指定的<span style="color:red;">其他</span>构造器:
  * 比如调空参的：`this();`
  * 比如调带参的：`this(age);`
  * 注意构造器不能调自己，也不能形成“环”，换言之，如果一个类中有n个构造器，则至多有n-1个构造器使用`this(形参列表)`这种形式
  * 构造器内部的，`this(形参列表)`必须出现在<span style="color:red;">首行</span> ==所以==>一个构造器内部只能调用一个

#### 关键字`package`和`import`

`package`

* `package`叫做包，目的是为了更好的实现项目中类的管理
* 使用`package`声明类或接口所属的包，声明在源文件的<span style="color:red;">首行</span>
* 包名属于标识符，遵循标识符的命名规范，见名知意`com.atguigu.java`
* 每`.`点一次代表一层文件目录
  * 补充：同一个包下不能命名同名的接口或类
  * 不同包下可以命名同名的接口或类

JDK中主要的包介绍

1. `java.lang`Java语言的核心类`String,Math,Integer,System`
2. `java.net`网络编程
3. `java.io`输入输出
4. `java.uitl`定义系统特性，接口的结合，日期日历相关函数
5. `java.text`java格式化相关
6. `java.sql`JDBC进行数据库编程的相关类/接口
7. `java.awt`抽象窗口工具机，写GUI的，渐渐被浏览器取代

MVC是常用设计模式之一，是结构清晰，灵活，同时也描述了程序各个对象之间的通信方式，降低了程序的耦合度

* 视图模型层：view.utils
* 控制器层：controller.activity/controller.base
* 数据模型层：model.bean/domain/model.dao/model.db

`import`关键词，导入

* 在源文件中现实的使用`import`结构导入指定包下的类、接口
* 申明在包的声明和类的声明之间
* 如果需要导入多个包，则并列写出即可
* 也可以使用xxx.*的方式导入xxx包下的所有结构
* `java.lang`包下的可以省略`import`这个结构，本包下定义的类和接口结构可以省略
* 如果有同名的类，在不同的包下，只能`import`其中的一个，另一个只能用全类名的方式
  * `Date`就有可能同时出现`java.util`和`java.sql`下都有这个类
* 如果使用`xxx.*`的方式表明可以`xxx`下的所有结构，但是如果使用的是`xxx`子包心爱的接口，则仍需要显示导入
  * `java.lang.reflect.Field`
* `import static`：导入指定的类或者接口中的结构静态：属性或者方法，用的少，落点是类而不是包

---

Here is May 28, 2021

### Day 11 OOP中

#### 每日一考

1. 构造器的作用是什么？使用中有哪些注意点(>=3条)
   构造器的作用：创建对象，初始化对象；注意名称与类名相同，如果不显示提供构造器的话系统默认提供一个空参构造器；如果显示提供了构造器则系统不再默认提供空参构造器；在构造器内可以调用其他结构，如属性和方法；<span style="color:red;">构造器没有返回值；每一个类都要有构造器；构造器不应该理解为特殊的方法，应该是跟方法并列的结构</span>

2. 关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序
   目前有四种：默认初始化 < 显示初始化  < 构造器初始化 < setter Method 赋值

3. this关键字可以用来调用哪些结构，简单说明一下其使用
   当前类或者当前正在创建的类的结构：属性`this.属性`、方法`this.方法名(方法形参)`、构造器`this(构造器形参)`。

4. Java中目前学习涉及到的四种权限修饰符都有什么？并说明
   由小到大：`private` < `缺省`< `protected`< `public`
   类内部，类和同一个包下，类和不同包下的字类，同一个工程
   出了工程都要用`import`来导入，import的时候要注意，`.`一次代表一层目录‘不同包内的同名类

5. 创建Circle类，提供私有的radius属性，提供相应的get和set方法，提供求圆面积的方法

   ```java
   public class Circle{
     private double radius;
     
     public void setRadius(double radius){
       this.radius = radius;
     }
     
     public double getRadius(){
       return this.radius;
     }
     
     public double findArea(){
       
       return Math.PI * this.radius * this.radius;
       
     }
     
   }
   ```


#### 项目二

写完了，跟了一下，比较简单。收获：

* 熟悉Eclipse 的快捷键，还有在Mac下熟悉指法。
* 建立自信
* MVC极简版初体验，有时间可以再反复品味一次

#### OOP特征，继承性，inheritance

* 好处：
  1. 减少了代码的冗余，提高了代码的复用性
  2. 便于扩展功能
  3. 为多态性的使用提供了前提
* 坏处：详见，*The Pragmatic Programmer*
* 继承的格式：`class A extends B{}`
  * `A` 子类、派生类`subclass`
  * `B`父类、超类、基类`superclass`
  * 体现：一旦子类`A`继承父类`B`以后，字类`A`中就获得了`B`中声明的所有的属性和方法
    * 父类中声明为`private`的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构，只是因为封装性的影戏那个，使子类不能直接调用父类中的结构。
  * 子类继承父类以后还可以声明自己的属性或方法：实现功能的拓展
    * 子类和父类的关系不同于，子集和集合的关系
* Java中关于继承行的规定：只支持单继承和多层继承
  * 一个类可以被多个子类继承
  * 一个类只能继承一个父类：`Java`中类的单继承性，不同于`c++`上的多继承性
  * 子父类是相对的概念，也就是可以多层继承。直接父类和间接父类
  * 子类继承父类以后，就获取了直接父类和所有间接父类中声明的属性和方法
* 如果我们没有显示地声明一个类的父类的话，则此类继承于`java.lang.Object`
  * 所有的`Java`类（除`java.lang.Object`外）都直接或间接继承于`java.lang.Object`。
  * 意味着，所有`Java`类都具有`java.lang.Object`类声明的功能。

---

Here is May 29, 2021

### Day 12 OOP中

后面项目大了以后，先跑起来，各种插件配置什么的弄好，然后再一个模块一个模块一点点写。

Eclipse macOS下点击行数设置断电需要双击

这里有`step into`失灵问题的解决

#### 方法的重写(override)

* 定义：子类中对从父类中继承来的方法进行该做，也称为方法的重置、覆盖。在执行过程中，子类的方法将覆盖父类的方法

* 应用：重写以后，当创建子类对象以后，通过子类对象调用父类中的同名同参的方法时，实际执行的是父类中被重写的方法 

* 要求：子类中交重写的方法，父类中的叫被重写的方法

  * 子类重写的方法和父类被重写的方法必须有相同的方法名称、形参列表
  * 子类重写的方法的返回值类型<span style="color:red;">不能大于</span>父类被重写的方法的返回值类型
    * 父类被重写的返回值类型是`void`的，则子类中重写的方法的返回值类型也只能是`void`
    * 父类被重写的返回值类型是`A`,则子类中重写的方法的返回值类型可以是`A`或者`A`的子类。这就意味着，如果父类中被重写的方法返回值是基本数据类型，则子类中重写的方法也必须是相同的基本数据类型
  * 子类重写的防范的访问权限<span style="color:red;">不能小于</span>父类被重写的方法的访问权限（摊煎饼）
    * 子类不能重写父类中声明为`private`权限的方法（不构成重写）
  * 子类抛出的异常<span style="color:red;">不能大于</span>父类被重写方法的异常

* 实际开发中，不用搞这么细致，需要重写的时候直接把父类的方法声明复制粘贴过来完事儿；或者用IDE自带的override提示功能

* 注意：子类与父类同名同参数的方法必须同时声明为非`static`的（此时是重写），或者同时声明为`static`的（此时不是重写）。因为`static`方法是属于类的，子类无法覆盖父类的方法。`static`一定不能被重写，为什么？因为不合理呀，类和子类各自是自己的类，所以有自己的`static`结构。井水不犯河水

* 方法声明的完全体

  ```java
  /*
  权限修饰符 返回值类型 方法名（形参列表）[throws 异常类型]{
  
  }
  */
  
  ```

#### 关键字`super`

`super`可以理解为“父类的”（包括间接父类），可以用来调用：属性、方法、构造器。

* 我们可以再子类的方法和构造器中通过`super.属性`或者`super.方法`的方式，显式调用父类中声明的属性或方法，但是，通常情况下我们习惯性省略`super.`
* 如果子父类中出现了同名的属性，可以用`super.属性`和`this.属性`来做区分。
* 特殊情况：当子类重写了父类的方法以后，我们想在子类的方法中调用父类中被重写的方法是，则必须显示的使用`super.`的方式
* `super(形参列表)`调用父类构造器的情况
  * 我们可以在子类的构造器中，使用`super(形参列表)`的方式，调用父类中声明的指定的构造器。
  * `super(形参列表)`的使用，必须声明在子类构造器的首行
  * 我们在类的构造器中，针对于`this(形参列表)`或`super(形参列表)`只能二选一，不能同时出现
    * 在类的所有构造器中，至少有一个类的构造器中是使用了`super(形参列表)`，调用了父类的构造器
    * 原因：回忆以前说过，一个类的`n`个构造器中，至多有`n - 1 `个使用了`this(形参列表)`的形式
  * 如果在构造器的首行没有显示的舍命，则默认调用的是`super()`,空参构造器

#### 字类对象实例化过程

1. 从结果上来看：（这就是继承性）
   1.1 子类继承父类以后，子类就获得了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。
2. 从过程上来看：
   2.1  继承性底层的实现跟直接或者间接调用父类的构造器有关，如果父类中的构造器被调用了，父类中声明的结构就被加载到内存中，子类也就继承到了
   2.2 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接地调用父类的构造器，直到`java.lang.Object`为止。正因为加载过所有父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。
3. 加载构造器不等于创建对象
   3.1 明确：虽然创建子类对象的时候调用了父类的构造器，但是！自始至终，只创建了一个对象，即为子类`new`的对象

类的继承课后练习题，super自己搞定了

#### OOP特征，多态性，Polymorphism

既是重点，也是难点。是面向对象中最重要的概念，在Java中的体现是：

<span style="color:red;">对象的多态性：父类的引用指向子类的的对象</span>

Java引用变量有两个类型：

* <span style="color:red;">编译时类型</span>：由声明该变量是使用的类型决定

* <span style="color:red;">运行时类型</span>：由实际赋给该变量的对象决定
* 口诀：<span style="color:red;">编译时，看左边；运行时，看右边（虚拟方法调用）</span>

如果编译时类型和运行时类型不一致，就出现了对象的多态性。

多态情况下：<span style="color:red;">看左边</span>看的是，父类的引用（父类中不具备子类的特有的方法）<span style="color:red;">看右边</span>看的是，子类的对象（实际运行的是子类重写父类的方法）

多态是的使用：虚拟方法调用

有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期我们实际执行的是子类重写父类的方法。

多态性的使用前提：

1. 类的继承关系
2. 有方法的重写

虚拟方法调用：子类中重写了父类中的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。

多态是<span style="color:red;">运行时行为</span>

---

May 30, 2021

### Day13 OOP中

#### 每日一考

1. 什么是多态性？什么是虚拟方法调用？
   多态：在Java中主要体现为对象的多态性，父类的引用指向子类的对象 == 子类的对象赋给父类的引用
   虚拟方法调用：编译看左边，运行看右边
2. 一个类可以有几个父类？（只能有一个）一个父类可以有多少个子类？（Java语言层面没有限制）子类能获取直接父类中的结构吗？（可以的，而且是一定可以的，连`private`都可以的）
3. 方法的重写(override/overwrite)的具体规则有哪些？
   子类中重写父类中同名同参数列表的方法
   private的不构成重写
   子类中重写的方法权限修饰符不小于父类中被重写的方法
   子类中重写的方法的返回值类型不大于父类中被重写的方法，意思是：如果是引用数据类型，则子类重写的方法返回值是被重写方法返回值类型或者它的子类
   子类中重写的方法抛出的异常类型不大于父类中被重写的抛出的异常。
4. super调用构造器，有哪些具体的注意点
   每一个类中，都至少有一个构造器调用了`super()`。`super(形参列表)`必须在构造器的首行，意思是，只能二选一而且必须二选一。一定会调用（所有）父类的构造器，一直到`java.lang.Object`
5. 在下面的代码结构中：使用关键字：this,super;方法的重写;继承;

<span style="color:red;">为什么规定`super()/this()`必须出现在构造器首行？</span>无论通过那个构造器创建子类对象，需要先保证先初始化父类。目的是当子类继承父类后，“继承”父类中所有的属性和方法，因此子类必须要知道父类如何对对象进行初始化.

#### 多态练习和理解

* 多态的重要性的体现：如果`Java`不支持多态性，抽象类和接口都没有意义了。

* 多态性只适用于方法，不适用于属性。

* 在多态存在下，不能调用子类特有的方法：编译时认为引用只是父类的类型，所以不能调用子类中特有的结构。但是子类中特有的结构肯定已经加载到内存中了。

  * 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于比纳凉声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。
  * 如何才能调用子类特有的属性和方法？使用强制类型转换符`Man m1 = (Man) p1;`(向下转型)
  * 向上转型其实就是多态性

* 使用强转时，可能出现异常的。为了避免出现`ClassCastException`问题，我们使用关键字`instanceof`进行判断，一旦返回`true`我们就强转，如果返回false就不进行向下转型。

  ```java
  if(p2 instanceof Woman){
    Woman w1 = (Woman)p2;
    w1.goShopping();
    System.out.println("********");
  }
  ```

  * 另外如果`class A extends B{}`，则，当`a instanseof A`返回`true`时，`a instanceof B`也一定是`true`

* 向下转型用的比较少，开发当中90%用的还是多态。

若子类重写了父类方法， 就意味着子类里定义的方法彻底覆盖了父类里的同名方法；对于实例变量则不纯在这样的现象，既是子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量；编译运行都看左边

#### `Object`类的使用

* 是所有`Java`类的根父类，如果在类声明的时候没有使用`extends`关键字指明其父类，则默认父类是`java.lang.Object`
  * 属性：无
  * `equals()`，`toString()`，`getClass()`，`hashCode()`，`clone()`，`finalize()`，`wait()`，`notify()`，`notifyall()`，
* 只声明了一个空参构造器
* 在对象被垃圾回收之前，垃圾回收器会调对象的`finalize()`方法。我们不要主动调取，留给垃圾回收器

`==`和`equals()`的区别：

1. `==`是运算符，可以使用在基本书据类型变量和引用数据类型变量中使用

2. 如果比较的是基本数据类型，比较两个变量保存的数据是否相等（类型不一定要一样）；如果比较的是引用数据类型的变量，则比较的是连个变量的地址值是否相等，即两个引用是否指向同一个对象实体。

3. `equals()`是一个方法，而非运算符

4. 只能适用于引用数据类型

5. `java.lang.Object`类中`equals()`的定义：

   ```java
   public boolean equals(Object obj){
     return (this == obj);
   }
   ```

   跟`==`的作用是相同的

6. 像`String`，`Date`，`File`，包装类等都重写了`Object`类中的`equals()`方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同。

7. 通常情况下，我们定义的类如果使用`equals()`的话，也通常是比较两个对象的实体内容是否相同，那我们需要重写`equals()`方法。可以仿写`String.equals()`，也可以用代码生成。

8. 注意，对称性、自反性、传递性、一致性、`x.equals(null)`永远返回`false`，类型不一样永远返回`false`

`toString()` 方法：

1. 当我们输出一个对象的引用时，实际上就是调用当前对象的`toString()`方法

2. `Object`类中`toString()`方法的定义：

   ```java
   public String toString(){
     reutnr getClass().getName() + "@" + Integer.toHexString(hashCode());
   }
   //comg.atguigu.java.Person@14f7e
   ```

   像`String`，`Date`，`File`，包装类等都重写了`Object`类中的`toString()`方法。使得在调用对象的`toString()`方法时，返回"实体内容"

3. 自定义类也可以重写`toString()`方法，调用次方法时，返回"实体内容"。

   ```java
   @Override
   public String toString(){
     return "Circle [radius=" + radius + "]";
   }
   ```

   

####  包装类的使用

单元测试的说明`JUnit`测试：

1. `当前工程 ==> 右键选择 build path ==> add libraries ==> JUnit4 ==> 下一步` 

2. 创建一个`Java`类，进行单元测试。要求：public的类，提供公共的无参构造器

3. 在此类中声明单元测试方法。
   此时的单元测试方法：要求权限是`public`，没有返回值，没有形参

4. 此单元测试方法上需要声明注解：`@Test`，并在单元测试类中导入`org.junit.Test`

   ```java
   import org.junit.Test;
   
   public class JUnitTest{
     
     @Test
     public void testEquals(){
       String s1 = "MM";
       String s2 = "MM";
       System.out.println(s1.equals(s2));
     }
       
   }
   ```

5. 声明好单元测试以后就可以在方法体内进行测试相关的代码

6. 写完代码以后，左键双击单元测试方法名，右键：`run as - JUnit Test`

说明：

1. 如果执行结果没有任何异常：绿条
2. 如果执行结果出现异常：红条

 包装类的使用：

1. java提供了8中基本数据类型对应的包装类（封装类），使得基本数据类型的变量具有类的特征（方法调用，继承，多态等）
2. 掌握的：基本数据类型、包装类、String三者之间的互相转换 
   2.1 基本数据类型 ==> 包装类：调用`包装类的构造器`
   2.2 包装类==>基本数据类型：调用`包装类的xxxValue()`
   2.3 `JDK5.0`新特性：自动装箱与自动拆箱
   自动装箱: `int num2 = 10;Integer in1 = num2;`
   自动拆箱： `int number3 = in1;`
3. 既然如此，基本数据类型和其对应的包装类可以看做是同一个类型。我们只需要掌握它和String之间的相互转换即可
   3.1 基本数据类型、包装类 ==> String类型：调用`String`重载的`valueOf(Xxx xxx)`方法，或者和空字符串`""`做链接运算
   3.2 `String` 类型 ==> 基本数据类型、包装类：调用`包装类的parseXxx()`方法，可能会报`NumberFormatException`

练习题：

```java
Object o1 = true ? new Integer(1) : new Double(2.0);
System.out.println(o1);// 1.0
```

因为三元运算符要求统一类型，所以会做自动类型提升

一道阴题：

```java
public void test(){
  
  Integer i = new Integer(1);
  Integer j = new Integer(1);
  System.out.println(i == j);//false
  
  Integer m = 1;
  Integer n = 1;
  System.out.println(m == n);//true;
  
  Integer x = 128;
  Integer y = 128;
  System.out.println(x == y);//false
}
```

`Integer`内部定义了`IntegerCache`结构，`IntegerCache`定义了`Integer[]`，保存了`-128-127`范围内的整数，需要用的时候直接用数组里面的整数就可以了，不用去`new`了
目的是提高效率

---

Here is June 1, 2021

### Day 14 OOP下

#### 每日一考

1. 如何实现向下转型？需要注意什么问题？如何解决此问题？
   使用强制类型转换符`m1 = (Man) p1`，可能转不成`ClassCastException`，异常处理的时候再具体说，使用instanceof 判断再进行向下转型。

2. == 和 equals()有何区别？
   `==`是运算符，可以作用于基本数据类型和引用数据类型，用于引用数据类型的时候比较的是地址值。`equals()`是方法，只能运用于类
   重写过的`equals()`方法比较的是对象的实际内容是否相同。

3. ```java
   class User{
   String name;
   int age;
   		//重写其equals()方法
     @Override
     public boolean equals(Object obj){
       if(obj == User){
         return true;
       }
       if(obj instanceof User){
         User u = (User)obj;
         return this.age == u.age && this.name.equals(u.name);
       }
       
       return false;
     }
   }
   
   ```

   

4. 写出8种基本数据类型及其对应的包装类
   `int ==> Integer`;`short ==> Short`;`byte ==> Byte`; `long ==> Long`; `boolean ==> Boolean`; `char ==> Character`; `float ==> Float`; `double ==> Double`

5. 基本数据类型、包装类与String三者之间如何转换:

   基本数据类型和其包装类之间：自动装箱、自动拆箱
   基本数据类型和其包装类 <==> String，调用后面那个家伙的方法

   基本数据类型、包装类 ===> `String`: `String.valueOf(new Long(13))`
   `String` ===>基本数据类型、包装类: `Long.parseLong(String s)`

数组也可以认为是一种特殊的类，也作为Object 的子类

#### `static`关键字的引入

以前：new一个对象，有一份属性和行为。有时候希望无论是否产生了对象或无论产生了多少对象，<span style="color:red">某些特定数据在内存里只有一份</span>。不归具体对象所有，没有必要每个对象一份

1. `static`可以用来修饰后：属性、方法、代码块、内部类，构造器不行

2. 使用`static`修饰属性：静态变量（它也修饰不了局部变量，所以只要修饰变量就是属性，所以就叫局部变量了）
   属性，按是否使用`static`修饰，有可以分为：类变量（静态属性） vs 实例变量 (非静态属性)
   实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性，彼此互相不干扰。随着对象的创建而加载。
   静态变量：我们创建了类的多个对象，多个对象共用那个同一个静态变量。随着类的加载而加载，早于对象的创建。可以通过`类.静态变量`的方式进行调用。
   由于类只加载一次，则静态变量也在内存中只存在一份：存在方法区的静态域中

   |      | 类变量 | 实例变量 |
   | ---- | ------ | -------- |
   | 类   | 可以   | 不可以   |
   | 对象 | 可以   | 可以     |

   `System.out`；`Math.PI`

3. 使用`static`修饰方法：静态方法
   3.1 随着类的加载而加载，可以通过`类.方法名来调用`
   3.2 能否调用的表同上
   3.3 静态方法中只能调用静态的方法和属性； 非静态方法中既可以调用非静态的方法也可以调用静态的方法

4.  `static`注意点：
   在静态的方法内，不能使用`this`关键字，`super`关键字

5. 属性和方法该不该用`static`修饰属性和方法的经验之谈：
   5.1 属性：可以被多个对象所共享的，不会随着对象的不同而不同的。类中的常量也常常声明为`static`
   5.2 方法：操作静态属性的方法，通常设置为`static`；工具类中的方法，习惯上声明为`static`。

#### 设计模式：单例模式Singleton

设计模式<span style="color:red;">是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式</span>，简称，套路

所谓单例模式，就是采取一定的方法保证在整个软件系统中，对某个类的智能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。

1. 将类的构造器私有化`private`
   在类的外部不能`new `该类的对象了，但是在类的内部还是可以造对象的
2. 调用该类的某个静态方法可以返回类内部创建的对象
3. 静态方法只能访问静态变量，所以只想类内部产生的该类对象的变量也必须是静态的 

如何实现？

```java
package com.atguigu.java1;
//饿汉式
public class SingletonTest1 {
	public static void main(String[] args) {
		Bank bank1 = Bank.getInstance();
		Bank bank2 = Bank.getInstance();
		
		System.out.println(bank1 == bank2);
	}

}

class Bank{
	
	//1. 私有化构造器
	private Bank() {
		
	}
	
	//2. 内部创建类的对象
	//4. 要求此对象也必须声明为静态的
	private static Bank instance = new Bank();
	
	//3. 提供公共的方法，返回类的对象
	public static Bank getInstance() {
		return instance;
	}
}

package com.atguigu.java1;
//懒汉式
public class SingletonTest1 {
	public static void main(String[] args) {
		Bank bank1 = Bank.getInstance();
		Bank bank2 = Bank.getInstance();
		
		System.out.println(bank1 == bank2);
	}

}

class Bank{
	
	//1. 私有化构造器/Users/chris/Downloads/SingletonTest2.java
	private Bank() {
		
	}
	
	//2. 只是声明对象的实例，不初始化
	//4. 要求此对象也必须声明为静态的
	private static Bank instance = null;
	
	//3. 提供公共的方法，返回类的对象
	public static Bank getInstance() {
    if(instance == null){
      instance = new Bank();
    }
		return instance;
	}
}
```

懒汉式和饿汉式的区分

饿汉式：坏处：对象加载时间过长
				好处：饿汉式式线程安全的

懒汉式：好处：延迟对象的创建。
				坏处：目前写法线程不安全 ==> 多线程的时候改成线程安全的写法

应用模式：

* 网站的计数器
* 应用程序的日志应用
* 数据库连接池
* 项目中，读取配置文件的类
* Application也是单例的典型应用
* Windows的Task Manager 和 Recycle Bin

#### `public static void main()`方法的语法

1. `main()`方法作为程序的入口，改名不行
2. `main()`方法也是一个普通的静态方法
3. `main()`也可以作为我们与控制台交互的方式。之前是用(`Scanner`) main方法获取到的形参都认为是String

#### 类的成员：代码块

```java
{
  //这就是代码块
  //就是一段大括号
  //功能上来说，就是初始化类或者是对象
  //如果要修饰，只能用static修饰
  
}
static{
  
}
```

1. 静态代码块
   内部可以用输出语句
   随着类的加载而执行，不能主动去调代码块的，一般都是自动调的。而且只执行一次
   作用：初始化类的信息/对静态变量
   如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行
   只能调用静态的属性和方法，不能调用非静态的结构
2. 非静态代码块
   内部可以用输出语句
   随着对象的创建而执行，而且每创建一个对象就执行一次。作用：可以在创建对象的时候对对象的属性进行初始化
   非静态代码块可以调用静态的属性、和方法，或非静态的属性和方法
3. 举例：虽然实际开发中使用频率不高
   总结一下：由父及子，静态先行；非静态代码块的执行在构造器之前
4. 跟显示初始化是平行的：具体看在代码层面谁出现在前面

#### 关键字：`final`

可以修饰的结构：类、方法、变量

* 类：`final class FinalA{}` 该类不能被其他的类继承
  * 如`String`，`System`，`StringBuffer`
* 方法：`public void final finalMethod(){}`
  * 如`java.lang.Object.getClass()`
* 变量：此时的"变量"就变成常量了
  * 属性：可以考虑赋值的有：显示初始化/代码块中；构造器中（如果要搞，就所有构造器都要搞）
  * 为什么用方法来赋值不靠谱？因为在方法是用对象来调用的，在构造器运行完了以后对象就已经出来了，这时候属性就应该有值了
  * 局部变量：方法内、形参。尤其是`final`形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。
* `static final`:修饰属性，全局常量； 修饰方法：不能重写的静态方法（少见）



### Day 15 OOP下

#### 每日一考

1. static 修饰的属性，相较于实例变量，有哪些特别之处(>=3点)
   随着类的加载而加载，可以通过类名来调用，所有类的的对象共用一份（内存中只有一份）

2. final 可以用来修饰哪些结构，分别表示什么意思
   类：不能被继承
   变量：初始化以后不能再赋值
   方法：不能被重写

3. 代码实现单例模式的饿汉式 

   ```java
   public class Singleton1{
     //1. 私有化构造器
     private Singleton1(){
       
     }
     //2. 该类的内部提供一个对象
     //4. 这个对象也得是静态的
     private static Singleton1 instance = new Singleton1();
     //3. 提供返回该对象的公共 方法（静态的）
     private static getInstance(){
       return instance;
     }
     
   }
   ```

   

4. 代码实现单例模式的懒汉式 -目前还是线程不安全的

   ```java
   public class Singleton1{
     //1. 私有化构造器
     private Singleton1(){
       
     }
     //2. 该类的内部提供一个对象
     //4. 这个对象也得是静态的
     private static Singleton1 instance = null;
     //3. 提供返回该对象的公共 方法（静态的）
     private static getInstance(){
       if(instance == null)
         instance = new Singleton1();
       return instance;
     }
     
   }
   ```

   

5. 类的属性赋值的位置有哪些？先后顺序为何？
   默认初始化 < 显示初始化/代码块 < 构造器 < 对象.属性 / 对象.方法

#### 抽象类与抽象方法

随着继承层次中一个个新子类的定义，类变得越来越具体，二父类则更一般，更通用。类的设计应该保证父类和子类的能够给共享特征。有时将一个父类设计的非常抽象，以至于它没有具体的实例，这样的类叫做<span style="color:red;">抽象类</span>。

* 用`abstract`关键词修饰类以后，该类不能造对象了
* 但是该类仍然有构造器。便于子类对象实例化时调用（涉及：子类对象实例化的全过程）
* 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作

抽象方法：`public abstract void eat();`用abstract 修饰方法，只有方法的声明，没有方法体。

* 包含抽象方法的类，一定是抽象类
  * 没有方法体就不应该被调用，但是如果能造对象，就有可能会被调用。反之，
* 抽象类中，可以没有抽象方法。
* 若子类重写了父类的所有抽象方法后，此子类方可实例化
  * 反过来说，若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要用`abstract`修饰 

`abstract`关键词注意点：

* 不能用来修饰：属性、构造器等结构
* 不能用来修饰私有方法、静态方法、final的方法、final的类

抽象类的匿名子类：

```java
package com.atguigu.java;

public class PersonTest {
	public static void main(String[] args) {
		method(new Student());
		
		Worker worker = new Worker();
		method1(worker);//非匿名的类非匿名的对象
		
		method1(new Worker());//非匿名的类匿名的对象
		
		//创建了一个匿名字类的对象：P
		Person p = new Person() {

			@Override
			public void eat() {
				System.out.println("eat something");
			}
			@Override
			public void breath() {
				System.out.println("Breath hardly");
			}};
			
//			method1(p);
			
			//还能更懒：匿名字类的匿名对象
			method1(new Person() {
				@Override
				public void eat() {
					System.out.println("eat something");
				}
				@Override
				public void breath() {
					System.out.println("Breath hardly");
				}
			});
	}
	public static void method1(Person p) {
		p.eat();
		p.breath();
	}
	public static void method(Student s) {
	}
}

class Worker extends Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}

	@Override
	public void breath() {
		// TODO Auto-generated method stub
	}
}

```



---

Here is June 3, 2021

多态的应用之：模版方法设计模式(TemplateMethod)

要解决的问题是，当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。

换句话说，<span style="color:red;">在软件开发中实现一个算法时，整体步骤很固定，通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模版模 式。</span>

回调(callback)方法钩子方法是开发中常用的手段，我们搞

#### 接口`Interface`

* 一方面，有时必须从几个类中派生出一个子类，继承他们所有的属性和方法。但是，Java不支持多重继承，有了接口就可以得到多重继承的效果。
* 另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有`is-a`的关系，仅仅是具有相同的行为特征而已。举例：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3、手机、数码相机、移动硬盘、等！USB
* 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要...则必须能..”的思想<span style="color:red;">继承是一个“是不是”的关系，而接口实现则是“能不能”的关系。</span>
* <span style="color:red;">接口的本质是契约，标准，规范</span>就像我们的法律一样，制定好以后，大家都要遵守。

接口使用`interface`关键字来定义，`interface`和`class`是两个并列的结构

* 如何定义接口：

  * `JDK7.0`及以前：只能定义全局常量和抽象方法
    * `public static final`的但是可以省略不写，不写人家也认为是`public static final`的
    * `public abstract`的方法，也可以省略`public abstract`
  * `JDK8.0`：除了全局常量和抽象方法以外，还可以定义静态方法、默认方法

* 接口中不能定义构造器，意味着接口不能实例化

* `Java`开发中，接口都通过类去实现(`implements`)

  * 如果实现类覆盖了接口中所有的抽象方法，则此实现类就可以实例化
  * 如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍然是抽象类

* Java类可以实现多个接口，多实现 ==> 弥补了`Java`单继承的局限性

  * 格式：`class AA extends BB implements CC, DD, EE{}`

* 接口与接口之间构成继承关系，而且可以多继承。  

* 接口的具体使用，体现多态性：抽象类和接口有什么异同？

  ```java
  //USB 是个接口
  class Computer {
    public void transferData(USB usb){
      usb.start();
      code();
      usb.stop();
    }
  }
  
  class USBTest{
    
    Computer com = new Computer();
    Flash flash = new Flash();
    com.transferData(flash);
  }
  ```

  

* 接口实际上可以看作是一种规范

* 开发中体会面向接口编程

再体会一下，接口的匿名实现类 

```java
com.transferData(new USB(){
  @Override
  public void start(){
    System.out.println("Anonymous USB device started working");
  }
  
  @Override
  public void stopped(){
    System.out.println("Anonymous USB device stopped working");
  }
  
});
```

体会后面慢慢体会，先多写代码。

**接口的应用：代理模式**

代理模式是`Java`开发中使用比较多的一种设计模式。代理设计就是为其他对象提供一种代理控制对这个对象的访问。 按说应该是被代理的对象自己去执行某些功能，但是在代码层面上只能看到代理类调用该方法。

代理还有静态代理和动态代理，动态代理跟反射有关系。

**接口的应用：工厂模式**

体会无工厂模式、简单工厂模式、工厂方法模式、抽象工厂模式，还是需要反射

工厂模式要把对象的创建和调用分开来，简单工厂和工厂方法模式都不能有效的必将改添加功能需要改代码的问题（开闭原则）

一道阴题：

```java
interface A{
  int x = 0;
}

class B {
  int x = 1;
}

class C extends B implements A{
  public void px(){
    //编译器报错，因为不知道是哪里的x
    System.out.println(x);
  }
  public static void main(String[] args){
    new C().px();
  }
}
```

`Java 8.0`接口的新特性：

 除了全局常量和抽象方法以外，还可以定义静态方法、默认方法

知识点1: 接口中的静态方法，只能用接口来调用

知识点2: 通过实现类的对象，可以调用接口中的默认方法 

知识点3:如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法（类优先原则）

知识点4:如果实现类实现了多个接口，而这个接口中定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，报错==> 接口冲突。解决办法：必须在实现类中重写此方法

知识点5:在实现类中调用接口中的默认方法`CompareA.super.method3();`

#### 类的成员：内部类

当一个事物的内部，还有一个部分需要一个完整的结构进行描述，二这个内部的完整的结构有职位外部事物提供服务，那么整个内部的完整结构最好使用内部类。

在`Java`中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类(`Inner class`)。

* 内部类的分类：成员内部类（静态、非静态） vs 局部内部类(方法内，代码块内，构造器内 )

* 成员内部类：

  * 一方面，作为成员：
    * 调用外部类的结构
    * 可以用`static` 修饰
    * 可以被四种不同的权限修饰符修饰
  * 另一方面，作为类：
    * 类的内部可以定义属性、方法、构造器
    * 可以被`final`修饰，表示此类不能被继承。言外之意，不使用`final`就可以被继承
    * 可以被`abstarct`修饰
  * 关注如下问题：
    * 如何实例化成员内部类的对象
    * 如何在成员内部类中区分调用外部类的结构

* 开发中局部内部类的使用

  ```java
  public class InnerClassTest{
    
    //开发中很少见
    public void method(){
      class AA{
        
      }
    }
    
    //返回一个实现了Comparable 接口的类的对象
    public Comparable getComparable(){
      
      //创建一个实现了Comparable 接口的类
      
      class Mycomparable implements Comparable{
        @Override
        public int comparaTo(Object o){
          return 0;
        }
      }
      
      return new MyComparable();
    }// getComparable()
  }//InnerClassTest
  ```

  

### Day 16 异常处理

#### 每日一考

1. `abstract`可以修饰那些结构？修饰以后，有什么特点？
   方法：没有方法体，子类必须重写，含有抽象方法的类必须是抽象类；继承的子类如果没有重写所有的抽象方法也必须是抽象类。只定义了一种功能的标准，具体的执行需要子类去实现。
   类：不能实例化，要想实例化必须由子类重写所有抽象方法；不一定含有抽象方法，但是含有抽象方法的必须是抽象类

2. 接口是否能继承接口？抽象类是否能实现(implements)接口？抽象类能否继承非抽象的类？
   可以，还可以多继承。可以。可以，没有直接说明父类的抽象类父类是`java.lang.Object`，那不就OK了吗

3. 声明抽象类，并包含抽象方法。测试类中创建一个继承抽象类的匿名子类的对象。

   ```java
   abstract class Employee{
     
     public abstract void Work();
     
   }
   
   public class EmployeeTest{
     
     public static void main(String[] args ){
       Employee aEmp = new Employee(){
         public void Work(){
         	System.out.println("Anonymous SubClass working"); 
         }
       };
     }
     
   }
   ```

   

4. 抽象类和接口有哪些共同点和区别？
   共同点：不能实例化，都可以被继承，
   区别：抽象类有构造器，接口不能声明构造器；接口可以多继承，类只能单继承；

5. 如何创建静态成员内部类和非静态成员内部类的对象？

   ```java
   class Peron{
     
     private static class StaticInner{
       
     }
     
     private class InstanceInner{
          
     }
     
   }
   
   public class PersonTest{
     
     public static void main(String[] args){
     //静态  
   	Person.StaticInner sin = new Person.StaticInner;
     //非静态
     Person p = new Person();
     Person.InstanceInner iin = p.new InstanceInner();
       
     }
   }
   ```

#### 异常处理概述

在使用计算机语言进行项目开发的过程中，既是程序员吧代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是考代码能够避免的，如：
<span style="color:blue;">用户输入数据格式、读取文件是否存在、网络是否始终保持通畅</span>等

在`Java`语言中，将程序执行中发生的不正常情况称为“异常”。那么，**什么不算异常？**：语法错误饿逻辑错误不是异常。Java程序在执行过程中所发生的异常事件可以分为两类：

* **Error**:JVM解决不了的重大问题，比如`StackOverflowError`，`OOM`
* **Exception**:其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理：例如：
  * `NullPointerException`
  * `ArrayIndexOutOfBountException`

#### 常见异常

```java
java.lang.Throwable
  	|----java.lang.Error:一般不编写针对性的代码进行处理。
    |----java.lang.Exception:可以进行异常的处理
      |-----编译时异常（checked）
      	|----IOException
      		|----FileNotFoundException
      	|----ClassNotFountException
      |-----运行时时异常（unchecked）
      	|----NullPointerException
      	|----ArrayIndexOutOfBountException
      	|----ClassCastException
      	|----NumberFormatException
      	|----InputMismatchException
      	|----ArithmaticException
```

#### 异常处理机制一 `try-catch-finally`

在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。过多的`if-else`分支会导致程序的代码加长、臃肿，可读性差，因此采用异常处理机制。

`Java`采用的异常处理机制，是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅、便于维护

**抓抛模型：**

1. “抛”：程序在正常执行过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。
   一旦抛出对象以后，其后的代码就不在执行。
2. “抓”：可以理解为异常处理的方式`try-catch-finally`：尝试把异常干掉；`throws`上报

```java
try{
  //可能出现异常的代码
}catch (异常类型1 变量名1){
  //处理异常的方式1
}catch (异常类型2 变量名2){
  //处理异常的方式2
}catch (异常类型3 变量名3){
  //处理异常的方式3
}finally{
  //可选的不是一定要写的
  //一定会执行的代码
}
```

* 使用`try`将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常的对象，根据此对象的类型，去`catch`中进行匹配
* 一旦`try`中的异常怼心啊哥匹配到某一个`catch`时，就进入`catch`中进行异常的处理。一旦处理完成，就跳出当前的`try-catch`结构（在没有写`finally`的情况下），继续执行其后的代码
* `catch`中的异常类型，如果没有子父类关系，声明的顺序无所谓。如果满足子父类关系，则要求子类一定声明在父类的上面，否则报错。
* 常用的异常对象处理的方式
  * `String getMessage()`
  * `void printStackTrace()`
* 在`try`结构中声明的变量在除了`try`以后就不能再调用

体会一个问题：使用`try-catch-finally`处理编译时异常，使得程序在编译时就不再报错，但是在运行时仍可能报错。相当于将一个编译时异常延迟到运行时出现

开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写`try-catch-finall`了。对于编译时异常，必须要处理

finally中声明的事一定会被执行的代码。既是`catch`中又出现异常了，`try`中有`return`语句，`catch`中有`return`语句等情况

像数据库连接， 输入输出流，网络编程`Socket`资源，JVM事不能自动回收的，我们需要自己手动进行资源的释放。此时的资源释放，就需要声明在`finally`中。

#### 异常处理机制二`throws`

1. `throws + Exceptioin`写在方法的声明处。指明执行此方式时，可能会抛出的异常类型。一旦方法体执行出现异常的时候，仍会在异常代码处出现一个异常类的对象，此对象满足`throws`后异常类的对象时，此对象就是会被抛出。异常后续的代码就不再执行
2. 体会`try-catch-finally`：真正的将异常处理掉了
   `throws`的方式只是把异常抛给了方法的调用者。并没有真正将异常处理掉

```java
package com.atguigu.java;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

import org.junit.Test;

public class ExceptionTest2 {

	public static void main(String[] args) {
		try {
			test2();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@Test
	public static void test2() throws FileNotFoundException, IOException {
		test1();
	}

	@Test
	public static void test1() throws FileNotFoundException, IOException {
		File file = new File("hello.txt");
		FileInputStream fis = new FileInputStream(file);

		int data = fis.read();
		while (data != -1) {
			System.out.println((char) data);
			data = fis.read();
		}
		fis.close();
	}
}

```



#### 手动抛出异常`throw`

异常对象的产生有两种方式：

1. 系统自动生成的异常对象
2. 手动的生成一个异常对象，并抛出：`throw`

#### 用户自定义异常类

三步走

1. 继承与现有的异常结构：`RuntimeException`，`Exception`
2. 提供全局常量：序列号`static final long seriesVersionUID = -12312341234 L`
3. 提供重载的构造器

---

Here is June 6

### Day 17 项目三

#### 小技巧

`p.getStatus().getNAME.equals("BUSY")`对比`"BUSY".equals(p.getStatus().getNAME())`后者更要，因为可以避免空指针异常

体会子父类的toString方法需要改变类名的时候，把基本信息抽象出来这个问题，期待用反射的方式更漂亮地去解决这个问题

到处体会cascade `if-else`的时候注意范围从小到大的过程，体会这两个的区别，前对后错

```java
Programmer p = (Programmer)e;
//正确写法：
if(p instanceof Architect){
  if(nArchitect >= 1){
    throw new TeamExcpetion("At most one architect in one team");
  }
}else if (p instanceof Designer){
  if(nDesigner >= 2){
    throw new TeamExcpetion("At most two designers in one team");
  }
}else if (p instanceof Programmer){
  if(nProgrammer >= 3){
    throw new TeamExcpetion("At most three programmers in one team");
  }
}

//错误写法
if(p instanceof Architect && nArchitect >= 1){
    throw new TeamExcpetion("At most one architect in one team");
}else if (p instanceof Designer && nDesigner >= 2){
    throw new TeamExcpetion("At most two designers in one team");
}else if (p instanceof Programmer && nProgrammer >= 3){
    throw new TeamExcpetion("At most three programmers in one team");
}

//反例：当Team中有两个Designer的时候，想要添加一个Architect的时候出bug
```



开发中还有一个判断数组是否为空的小技巧：

```java
Employee[] employees = NameListService.getAllEmployee();
if(employees == null || employees.length() ==0){
  //注意排查非空的情况，除非看过源码
}
```



要求：对着需求PPT自己敲一遍

---

Here is June 7, 2021

## Java高级编程 

Java语言的具体应用



### Day 18 IDEA的使用与多线程

#### 前情提要

June 8， 2021，项目3对着需求自己敲了一下，view没有敲，但是其他的两个类搞完了

#### IDEA Hello World

`psvm + enter`： 主函数

`sout + enter`： `System.out.println()`，也可以先写一个String literal 然后点出来这个结构

#### Module的理解

IDEA官网上说的，：
`Eclipse`中的`workspace`相当于IDEA中的`Project`

`Eclipse`中的`Project`相当于IDEA中的`Moduel`

一些不同点：

`Eclipse`的一个窗口可以管理很多个项目，但是IDEA是不行的，IDEA提供的解决方案是打开多个窗口，每个窗口可以搞不同的项目。

IDEA中Project是最顶级的级别，其次是Module。

如果要干掉一个Module 要先从Project里面剔除出来，然后再从文件系统中删除掉文件夹



#### 基本概念：程序、进程、线程

* 程序programm：是为完成特定任务、用某种语言编写的一组指令的集合，<span style="color:red;">一段静态的代码</span>，静态对象。
* 进程process：是程序的一次执行过程，或者是<span style="color:red;">内存中正在运行的一个程序</span>，是一个动态的过程。它有产生，存在，消亡的过程--声明周期。资源分配的单位，系统给不同的进程分配不同的内存空间。
* 线程thread：进程可以进一步细化称为线程，是一个程序内部的一条执行路径。
  如果一个进程同一时间并行执行多个线程，就是支持多线程的。
  <span style="color:red;">线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器PC</span>，线程切换开销比较小。多线程共享内存空间，所以存在线程安全问题

单核CPU和多核CPU：

* 单核CPU时代，多线程是假的，只是看似多线程，同时运行
* 真正的多核才能更好的发挥多线程的效率
* 一个Java应用程序`java.exe`至少有三个线程：主线程`main()`，垃圾回收线程`gc()`，异常处理线程
* 并行：多个CPU同时执行多个任务：多个人同时做不同的时parallel
* 并发：一个CPU采用时间片同时执行多个任务concurrence

多线程的优点：

单核CPU之使用单核线程先后完成多个任务，肯定比用多个线程来完成总用时更短，那么为什么要多线程？

1. 提高应用程序的响应，对图形化界面更有意义，可增祺那个用户体验。
2. 提高计算机系统CPU的使用率
3. 改善程序结构，将既长又复杂的进程氛围多个线程，独立运行，利于理解和修改

---

Here is June 8, 2021

#### 线程的创建和使用

**方式一：**继承`Thread`类

1. 创建一个继承于`Thread`类的子类
2. 重写`Thread`类的`run()`方法
3. 创建`Thread`类的子类的对象
4. 通过对象调用`start()`
   有两个作用：1. 启动当前线程； 2. 调用当前线程的`run()`

两个小问题：

问题一：如果我不调用`start()`，直接调`run()`发生什么？

```java
public class ThreadTest {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
      //这行干掉
      //t1.start();
      //改成run()
	      t1.run()
        for (int i = 0; i < 100; i++) {
            if( i % 2 == 0){
                System.out.println(i + "main()");
            }
        }
    }
}
/*
结果是会在主线程中执行Thread子类中的run方法，然后继续执行主线程中后面的语句，换言之，只有一个线程在做
*/
```

问题二：再启动一个线程，遍历100以内的偶数，能否再`start()`一次？
答案是不能，因为start以后状态不是0了，会报错，需要再创建一个对象来调

```java
//t1.start();
//上面这种调法会报错，正确做法是再创建一个对象
MyThread t2 = new MyThread();
t2.start();
```

**Thread 类的常用方法**

1. `start()`方法：启动当前线程，调用当前线程的`run()`
2. `run()`方法：通常需要重写Thread类中的次方法，将创建的线程要执行的操作声明在此方法中
3. `currentThread()`方法：是个静态方法，返回当前代码执行的线程
4. `getName()`：过去当前线程的名字
5. `setName()`：设置当前线程的名字
   也可以重写构造器，因为Thread()有一个构造器
6. `yield()`：释放当前cpu执行权
7. `join`：在线程a中，调用线程b的`join()`方法，此时线程`a`进入阻塞状态，直到线程`b`完全执行完之后线程`a`才结束阻塞状态
   ![线程join方法](/Users/chris/Coding Bootcamp/Notes/atguigu-notes/Backend/00. Java基础/a.join().png)
8. `stop()`：强制线程生命周期结束
9. `sleep(long millitime)`：让当前线程睡眠制定的millitime毫秒，在睡眠时间内，当前线程进入阻塞状态。
10. `isAlive()`：当前线程是否存活

**线程的优先级**

1. 常量`MAX_PRIORITY: 10`，`MIN_PRIORITY: 1`，`NORM_PRIORITY: 5`
2. 如何获取和设置当前线程的优先级：
   `getPriority()` vs `setPriority(int p)`
   高优先级的线程要抢占低优先级cpu的执行权，但只是从概率上来将的，高优先级的线程高高绿的情况下被执行。并不意味着只有高优先级的线程执行完以后，低优先级的线程才执行。

**方式二：**实现`Runnable`接口

1. 创建一个实现了`Runnable`接口的类
2. 实现类去实现`Runnable`中的抽象方法`run()`
3. 创建实现类的对象
4. 将此对象作为参数传递到`Thread`类的构造器中，创建Thread类的对象
5. 通过`Thread`类的对象调用`start()`

比较创建多线程的两种方式：由于`Java`单继承，如果继承Thread就不能继承别的类了，但是我们有时候它应该有自己的父类

开发中，优先选择实现`Ruannable`接口的方式，原因：

1. 实现的方式没有类的单继承性的限制

2. 实现的方式更适合来处理多个线程有共享数据的情况

   联系：Thread类也实现了Runnable。不管是继承的方式还是实现的方式都需要重写`run()`，将线程要执行的逻辑声明在`run()`中

#### 线程的声明周期

#### 线程的同步

#### 线程的通信

#### JDK5.0新增线程创建方式

