## Java基础编程

JAVA语言的核心

### Day 00 编程入门

#### 学习的原则

* 学习编写代码的捷径：敲、狂敲
  * 一天的代码至少敲3遍：第一遍照着写，第二遍背着写，第三遍自己写
  * 三分看、七分练
* 先模仿好的编码习惯，有些东西需要背
* 每天30min复习整理
* 战略上藐视，战术上重视

艾宾浩斯遗忘曲线

### Day 01 Java语言概述

#### Roadmap

第一阶段：30天、Java基础、MySQL、JDBC等<span style="color:red">**（May 18, 2021 -- ）**</span>

第二阶段：15天、JavaWeb、HTML基础与CSS、XML与Tomcat、JSP等（组件）

第三阶段：16天、JavaEE框架、Spring、SpringMVC、MyBatis、Linux等

所谓框架：常用组件的集合，封装、使用组件开发效率比较低

互联网众筹项目：15天、规模不小，但是略掉重复性的功能滤掉了

第四阶段：15天、JaveEE高级、IDEA开发工具、Git与GitHub、MySQL高级、Nginx反向代理、Docker

电商项目：15天、电商项目包含其他各门类的业务场景的影子

电商项目总结与拓展：3天

在线教育项目：12天

总记127天左右，一周6天，共20个周左右

May 18, 2021 ---20 weeks---> Sep 14, 2021

#### Java学习

![Java知识图谱](/Users/chris/Coding Bootcamp/Notes/Backend/00. Java基础/知识图谱.png)

笔记不要太详细，概要记重要的是过程。

培养兴趣：两个周左右的时间建立编程的feel，敲、狂敲

#### 软件开发

软件有系统软件和应用软件之分、人机交互方式有GUI和CLI之分

#### 计算机编程语言简介

粗浅分为三代：

1. 机器语言：二进制代码

2. 汇编语言：助记符

3. 高级语言：可以分为两个阶段

   3.1. 面向过程

   3.2. 面向对象

#### Java语言概述

* SUN（Stanford University Network）公司开发的
  * Java小程序（applet）可以嵌入HTML当中，在Web浏览器中运行
* 后台开发：Java、PHP、Python
  * Java体量大，开发周期慢：绝对主力，首选语言
  * Python有替换PHP的趋势，开发周期短：一两个人两三个月也就搭起来了
  * Go语言、据说有Java的开发效率和C/C++的运行效率
  * Node.js
* Java简史
  * Java地名，是个岛，盛产咖啡
  * 1991年以Oak命名
  * 1996年，发布JDK 1.0
  * 2004年，发布JDK1.5，有突破性的重要版本，改名为JDK5.0
  * 2005年，J2SE -> JavaSE; J2EE -> JavaEE; J2ME -> JavaME
  * 2009年，SUN公司被Oracle公司收购了，74亿美元
  * 2014年，发布JDK 8.0，继JDK5.0以来变化最大的版本
* Java技术体系平台
  * JavaSE：桌面级应用，现在基本上已经不会出现了
  * JaveEE：企业级的应用Servelt、JSP
* Java语言的诞生
  * 类C语言、纯粹的面向对象语言
  * 舍弃C语言中容易引起错误的指针
  * 增加了垃圾回收器

#### Java语言运行机制和运行过程

Java语言特点：

1. 面向对象：

   1.1. 两个基本概念：类、对象

   1.2. 三大特性：封装、继承、多态

2. 健壮性：

   2.1. 吸收C/C++优点，舍去影响健壮性的部分（指针，申请、释放内存）

3. 跨平台性：

   3.1. 跨平台性：“Write once， Run anywhere”

   3.2. 原理： JVM安装好，JVM就负责Java程序在系统中的运行

4. Java核心机制：

   4.1. JVM

   4.2. 垃圾回收

#### Java语言的环境搭建：

* JDK（Java Development Kit Java开发工具包）

  * 给Java开发人员使用，包含JRE
  * 开发工具包括：编译工具javac，打包工具jar等

* JRE（Java Runtime Environment Java运行时环境）

  * 如果想运行开发好的Java程序，只需要JRE
  * Java程序需要的核心类库

* 三者关系：

  * Java 8.0![Java 8.0](/Users/chris/Coding Bootcamp/Notes/Backend/00. Java基础/Java8.0_platform.jpg)
  * 简化版![简化版](/Users/chris/Coding Bootcamp/Notes/Backend/00. Java基础/JVM,JRE,JDK.png)

* 我的环境：

  * OS: macOS 11.3 (20E232) Big Sur
  * JDK路径:
    * /Users/chris/Library/Java/JavaVirtualMachines/azul-1.8.0_282/Contents/Home
    * /Users/chris/Library/Java/JavaVirtualMachines/azul-1.8.0_292/Contents/Home
  * `JAVA_HOME`：bin目录的上层目录。这也是一个约定的变量，通常指JRE目录。上面的两个都可以事JAVA_HOME
    * 其实大部分Java程序不需要JDK，而是只需要其子集JRE，所以很多程序也会去取这个变量来用。
  * 为什么需要配置环境变量？
    * 希望在任何路径下都能够执行相应的程序

* HelloWorld

  ```java
  class HelloWorld{
    public sttic void main(String[] args){
      System.out.println("Hello World!");
    }
  }
  ```

* 源文件（.java文件）--javac编译--> 字节码文件（bytecode .class文件）--java运行-->结果

  * Windows路径名不是区分大小写
  * classpath：class文件的路径，不要配

#### Java注释  Comments

​	提高代码可读性、不参与运行，单行注释和多行注释的主要作用都是这样，方便别人也方便自己；另外也可以用来调试

##### 单行注释

```java
class HelloWorld{
  //单行注释
  public sttic void main(String[] args){
    System.out.println("Hello World!");
  }
}
```



##### 多行注释

```java
class HelloWorld{
  /*多行注释
  好多好多行
  */
  public sttic void main(String[] args){
    System.out.println("Hello World!");
  }
}
```

提高代码可读性、不参与运行，单行注释和多行注释的主要作用都是这样，方便别人也方便自己；另外也可以用来调试

##### 文档注释（Java特有）

```java
/**

文档注释，可以被javadoc解析的
@author fscj
@version v1.0
这是我重新起航的第一个Java程序，非常开心

*/
public class HelloWorld{
  /*多行注释
  好多好多行
  */
  public sttic void main(String[] args){
    System.out.println("Hello World!");
  }
}
```

```shell
javadoc -d DIR_NAME -author -version HellowWOrld.java
```

* 注意：多行注释不能嵌套，很简单的原理

#### Java API 文档

CHM是Windows上用的，macOS上再说吧，不行就看英文文档

#### Java 类和public 类

* 在以一个Java源文件中，可以声明多个`class`但是，只能有一个生命为`public`
* 而且要求声明为`public`的类，类名必须等于（源）文件名

#### Java编码习惯以及IDE说明

* 正确的注释和注释风格
  * 使用文档注释来注释整个类或整个方法
  * 如果注释方法中的某一个步骤，使用单行或者多行注释
* 一个`tab`进行缩进、运算符两边各加一个括号增强可读性
* 常用IDE，Eclipse和IntelliJ IDEA

---

Here is May 18, 2021

### Day 02 Java基本语法

#### 关键字和保留字

##### keyword定义

被Java语言赋予了特殊含义，用做专门用途的字符串。

* 特点：所有关键字都是小写的
* `true`, `false`,`null`严格意义上不算关键字，但还是当关键字来用。意思是自己定义标识符的时候还是不要用这些字

##### reserved word定义

现有Java版本尚未使用，但以后版本可能会作为关键字使用的。意思是自己定义标识符的时候还是不

* `goto`,`const`



#### 标识符

* Identifier: Java对各种变量、方法和类等要素命名时使用的字符序列成为标识符
  * 凡事自己起名的都叫标识符
* 规则：
  * `a-z | A-Z | 0-9 | _ | $`
  * 数字不能开头
  * 不能事关键字或者保留字，但是可以包含
  * Java中严格区分大小写，长度无限制
  * 标识符不能包含空格
* 规范：
  * 包名：多单词组成是所有字母都小写：`xxxyyyzzz`
  * 类名、接口名：大驼峰：`XxxYyyZzz`
  * 变量名、方法名：小驼峰：`xxxYyyZzz`
  * 常量名：所有字母大写，多单词时用下划线连接：`XXX_YYY_ZZZ`
* 使用meaningful的标识符，见名知意

#### 变量

* 变量的概念

  * 内存中的一个存储区域
  * 该区域的数据可以在同一类型范围内不断变化
  * 是程序中最基本的存储单元，包含**类型**、**名称**和**存储的值**

* 变量的作用

  * 在内存中存储数据

* 注意：

  * Java中每个变量必须先声明，后使用
  * 使用变量名访问数据
  * 作用域：一对大括号内`{}`
    * 变量只在其作用域内有效
    * 同一个作用域内不能出现同名变量

* 举例：

  ```java
  class VariableTest{
    public static void main(String[] args){
      //变量的定义
      int myAge = 12;
      //变量的使用
      System.out.println(myAge);
      //变量定义可以分为声明和赋值两步
      int myNumber;
      myNUmber = 10001;
    }
    
  }
  ```

* 变量的分类

  * 8种基本数据类型primitive type

    * 数值型

      * 整数型`short`,`int`,`long`,`byte`

      * 浮点型`float`,`double`

        ```java
        class VariableTest
          //基本数据类型的使用
          public static void main(String[] args){
          /* 整数型
          byte 8位 一个字节
          short 16位 两个字节
          int 32位 四个字节 表示范围最高约21亿
          long 64位 八个字节 声明时以"l"或者"L"结尾，不加的话，在数值不超过int型表达范围的时候编译也能通过
            通常使用 int 型
          */
          long l1 = 23123123l;
        
          /* 浮点型
          float 4字节 声明时以"f"或者"F"结尾，不加编译失败
          doulbe 8字节
          跟整型比起来，占用同样的存储空间，但是表示的范围也大，还带小数点，但是精度不行
          通常使用 double 型
          */
          double d1 = 1234.4;
          float f1 = 1234.5f;
          
          /* 字符型
          char 1字符=2字节 通常用一对单引号，内部不能写两个字符
          通常使用 double 型
          */
          char ch1 = 'a';
          
          //char ch2 = 'AB'; 编译不通过
          }
          
        }
        ```

    * 字符型`char` ，表示方式：

      * 声明一个字符`char ch1 = 'a';`必须是一个字符，空的不行`char ch2 = '';`编译失败
      * 转义字符`\n`,`\t`等
      * `Unicode` 值 `\u0123`
      * 字符集：计算机内部2进制和字符之间的对应关系，
        * 最早的就是`ASCII`码，其中`'a'` 对应到 `97`
        * `Unicode`要解决互联网发达以后不同国家的字符集之间通信的问题
        * `UTF-8`后面都用这个

    * 布尔型 `boolean`

  * 基本类型之间的运算规则：
    前提：不包含`boolean`，所以是7种数据类型之间的转换

    * 自动类型提升：当容量小的数据类型和容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。此时的容量大小指的是表示数的范围的大小，不是存储范围的大小
      `byte / char / short / int --> long  --> float --> double`
      特别的当`byte,char,short`三种做运算的时候，结果为`int`，即便是`byte + byte`结果也是`int`
    * 强制类型转换：自动类型提升运算的逆运算`int1 = (int) d1;//截断操作`

  * 3种引用数据类型reference type

    * 类`Class` 字符串`String` 属于这类
    * 接口`Interface`
    * 数组`[]`

  * 初见`String`类型

    * `String`，中文名字叫字符串，属于引用数据类型
    * 申明时用一对双引号`String str1 = "Hellow World";`
    * `String`类型可以和8种基本数据类型的变量做连接运算，且只能是连接运算。
      * `String str = "Hello World" + 1234;`，可见运算结果仍然是`String`类型

    ```java
    //练习1
    char c = 'a';
    int num = 10;
    String str = "hello";
    
    System.out.println(c + num + str);//"a10hello"!!!正确答案"107hello"
    System.out.println(c + str + num);//"ahello10"
    System.out.println(c + (num + str));//"ahello10"
    System.out.println((c + num) + str);//"107hello"
    System.out.println(str + num + c);//"hello10a"
    
    //练习2
    System.out.println("*   *");//OK
    System.out.println('*' + 't' + '*');//NOT OK
    System.out.println('*' + "t" + '*');//OK
    System.out.println('*' + 't' + "*");//NOT OK
    System.out.println('*' + ('t' + "*"));//OK
    ```

    

  ---

  Here is May 19, 2021

### Day 03 Java基本语法

#### 每日一考

1. 标识符的命名规则有哪些？
   26个字母大小写,$, _,[0-9]
   数字不能开头
   严格区分大小写
   不能是关键字和保留字，但是可以包含

2. 标识符的命名规范有哪些？
   包名：全小写
   类、接口名：大驼峰
   变量、方法：小驼峰 
   <span style="color:red">常量名，全大写，下划线分割</span>

3. Java变量找数据类型怎么分，并指出Java的基本数据类型有哪8种，并指出各自占用的内存空间大小
   基本数据类型：
   整型：`byte`，1个字节;`short`，2个字节;`int`，4个字节;`long`，8个字节;
   浮点型：`float`，4个字节;，`double`，8个字节;
   布尔型：`boolean`，1个字节，具体体层转化成`int`但是不同管
   字符型：`char`，2个字节
   引用数据类型：3种：类`Class`、接口`Interface`、数组`[]`

4. 说明基本数据类型之间的自动类型提升的运算规则

   按照该类型所能表示的数字范围的递增顺序
   `byte/char/short --> int --> long --> float -->double`

   特殊规则：前三种，之间运算，结果都是`int`；默认整型是`int`；默认浮点型是`double`

5. 说明基本数据类型之间的强制类型转换的使用规则和强转可能出现的问题。
   用法：`(int)`括号加类型
   问题：丢失数据精度，或者编译失败

#### 运算符

* 算数运算符

  * 单元：`+,-,++,--`
  * 双元：`+,-,*,/,%`
  * 连接运算符：`+`

  ```java
  class ArithmeticTest{
    
    public static void main(String[] args){
      /* 算数运算符的说明
      
      */
      // % 模运算符
      //如果出现负数，那么结果的符号与被模数相同
      int m1 = 12;
      int n1 = 5;
      System.out.println("m1 % n1 = " + m1 % n1);//2
  		int m1 = -12;
      int n1 = 5;
      System.out.println("m1 % n1 = " + m1 % n1);//-2
      int m1 = 12;
      int n1 = -5;
      System.out.println("m1 % n1 = " + m1 % n1);//2
      int m1 = -12;
      int n1 = -5;
      System.out.println("m1 % n1 = " + m1 % n1);//-2
    }
    /* 自增自减运算符不会改变数据的类型 */
    	short s1 = 10;
    	// short s1 = s1 + 1;//编译失败
    	short s1 = (short)(s1 + 1);//正确，但是相对低效
    	s1++;
    
    	byte b1 = 127;
    	byte++;
    	System.out.println("b1 = " + b1);//猜测：-128，猜测正确
  }
  ```

  ```java
  /*
  练习题：给定一个三位数，输出它的百位数，十位数，个位数：
  */
  
  class AriExer{
    
    public static void main(){
      int num = 187;
      
      int ge = num % 10;
      // int shi = (num/10) % 10;//这个不对
      int shi = num % 100 / 10;
      int bai = num / 100;
    }
    
    
    
  }
  ```

  

  题外话：代码量是评判程序员好坏的基本指标，干就完事儿了；代码积累过程中解决了多少个bug

* 赋值运算符
  `=, +=, -=, /=, %=`，支持连续赋值

  ```java
  //连续赋值的两种情况
  int i1, j1;
  i1 = j1 = 10;
  
  int i2 = 10, int j2 = 20;
  
  //复合赋值运算符不会改变变量的数据类型
  short s1 = 10;
  s1 = s1 + 2;//编译不通过
  s1 += 2;
  
  //开发中实现一个变量+2的操作 int num = 10;
  //方法1
  num = num + 2;
  //方法2(推荐)
  num += 2;
  
  //开发中实现一个变量+1的操作 int num = 10;
  //方法1
  num = num + 1;
  //方法2
  num += 1;
  //方法3（推荐）
  num++;
  
  //练习题：
  int i = 1;
  i *= 0.1;
  System.out.println(i);//0 注意，复合赋值运算不会改变数据类型
  
  //练习题：
  int n = 10;
  n += (n++) + (++n);//推理：25， 推理错误！
  /* 推导
  1: (n++)==> 10 n ==> 11;
  2: (++n)==> 12 n ==> 13;
  3: 10 + 12 ==> 22;
  4: 13 + 22 ==> 25;
  */
  
  /* 正确推导
  1: 10 + () + ()
  2: (n++)==> 10 n ==> 11;
  3: (++n)==> 12 n ==> 13;
  4: 13 + 22 ==> 25;
  */
  ```

  

* 比较（关系）运算符
  `==, !=, >, <, >=, <=, instanceof`
  要注意`==`和`=`的区分

* 逻辑运算符
  `&, &&, |, ||, !, ^`
  只能适用于布尔类型的变量,"单与"和"双与"的区别：

  ```java
  class LogicTest {
    public static void main(String[] args){
      //区分& 和 &&
      boolean b1 = false;
      int num1 = 10;
      if(b1 & (num1++ > 0)){
        System.out.printlin("我现在在北京");
      }else{
        System.out.printlin("我现在在南京");
      }
      
      System.out.println("num1 = " + num1);//11
      
      boolean b2 = false;
      int num2 = 10;
      if(b2 && (num2++ > 0)){
        System.out.printlin("我现在在北京");
      }else{
        System.out.printlin("我现在在南京");
      }
      System.out.println("num2 = " + num2);//10，说明num2没有进行++运算
    }
    
  }
  ```

  

* <span style="color:purple;">位运算符</span>
  `<<, >>, >>>, &, |, ^, ~`，注意，没有`<<<`
  位移运算都是对整数来说的，区分`&, |, ^`和逻辑运算符就看操作数的数据类型

  ```java
  /* 练习：交换两个变量的值
  
  */
  int num1 = 10;
  int num2 = 20;
  
  //两个只能站一个人的小岛，甲乙两人互换位置
  //好处：不用定义临时变量
  //弊端：有可能相加结果超出存储范围。局限性：只能作用在数值型的变量上面
  num1 = num1 + num2;
  num2 = num1 - num2;
  num1 = num1 - num2;
  
  //位运算符的方式，厉害了
  num1 = num1 ^ num2;
  num2 = num1 ^ num2;
  num1 = num1 ^ num2;
  ```

  

* 三元运算符
  `(condition) ? exp1 : exp2`
  表达式1和表达式2要求是一致的，三元运算符可以嵌套

* 关于三元运算符和`if-else`语句

  * 关系：能用三元运算符写的都可以用`if-else`语句来写，反之不成立
  * 取舍：如果既可以用三元运算符又可以用`if-else`语句，优先tenary，原因是简洁，执行效率高

#### 流程控制

来源于工业上的生产流程，代码的执行也是个流程。实际生产中需要用到如下三种基本流程结构

* 顺序结构

  * 程序从上到下顺序执行

* 分支结构

  * 三种`if-else`
    
    ```java
    /* 第一种*/
    if (exp) {}
    /* 第二种 二选一*/
    if (exp1){...}else{...}/* 第三种 多选一*/
    if (exp1){...}
    else if ()
    {...}
    ...
    else{}
    ```
    
  * `switch-case`结构
    
    ```java
    /* 
    switch 后面跟的exp只能是下列6种中的一个：
    byte, short, char, int, 枚举类型（JDK 5.0新增）, String类型(JDK 7.0新增)
    */
    switch(exp){
        
      case const0:
        System.out.println('Zero');
        break;
      case const1:
        System.out.println('One');
        break;
      default:
        System.out.println('Other');
    }
    ```

### Day 04 Java基本语法

#### 每日一考

1. `&`和`&&`的异同
     相同点：运算结果相同、都会执行左边的运算数（表达式）
     不同点：当`&&`左边的操作数已经是`false`的情况下，`&&`右边的表达式不会被计算

2. 程序输出题：

     ```java
     class OperatorTest {
     	public static void main(String[] args) {
     		boolean x = true;
     		boolean y = false;
     		short z = 40;
     		if ((z++ == 40) && (y = true)) {
     			z++;
     		}
     		if ((x = false) || (++z == 43)) {
     			z++;
     		}
     		System.out.println("z = " + z);
     	}
     }
     ```

     输出结果为：`z = 44`

3. 定义三个int型变量并赋值，使用三元运算符或者if-else获取这三个数中的较大数的实现

     ```java
     int n1 = 10, int n2 = 12; int n3 = 4;
     // 三元运算符
     int max;
     max = n1 > n2 ? (n1 > n3 ? n1 : n3) : n2; 
     // if-else
     int max;
     if (n1 >= n2 && n1 >= n3){
       max = n1;
     }else if (n1 < n2 && n2 >= n3) {
       max = n2;
     }else{
       max = n3;
     }
     ```

     

4. 编写程序，声明2个double型变量并赋值。判断第一个数大于10.0，且第2个数小于20.0，打印两数之和。否则，打印两数的乘积。

     ```java
     double d1 = 12.3, double d2 = 3.14;
     if (d1 > 10.0 && d2 < 20.0){
       System.out.println("d1 + d2 = " + (d1 + d2));
     }else{
       System.out.println("d1 * d2 = " + (d1 * d2));
     }
     ```

     

5. 交换两个变量值的代码的实现

     ```java
     String s1 = "北京";
     String s2 = "南京";
     String temp;
     temp = s1;
     s1 = s2;
     s2 = temp;
     ```

#### Scanner类的使用

```java
import java.util.Scanner;

class ScannerTest{
  
  public static void main(String[] args){
    
    Scanner scan = new Scanner(System.in);
    
    Systemout.println("请输入姓名");
    String name = scan.next();
    System.out.println(name);
    
    Systemout.println("请输入年龄");
    int age = scan.nextInt();
    System.out.println(age);
    
    Systemout.println("请输入年龄");
    double weight = scan.nextDouble();
    System.out.println(weight);
    
    Systemout.println("你是否相中我了呢？(true/false)");
    boolean isLove = scan.nextBoolean();
    System.out.println(isLove);
    
    //原生没有char型，但是可以先接受为String，后面用String的charAt()方法
    
    System.out.println("输入你的性别：（男/女）");
    String gener = scan.next();
    char genderChar = gener.charAt(0);
    Syste.out.println(genderChar);
  }
  
}
```

#### if-else例题

例题1: 键盘输入小鹏的成绩，给奖励

```java
import java.util.Scanner;

class IfTest{
  
  public static void main(String[] args){
    
    Scanner scan = new Scanner(System.in);
    
    Systemout.println("请输入岳小鹏期末成绩：(0,100]");
    
    int score = scan.nextInt();
    
    if(score == 100){
      System.out.println("BMW");
    }else if(score > 80 && score <= 99){
      System.out.println(iPhone xs max);
    }else if(score >= 60 && score <= 80){
      System.out.println("iPad");
    }else{
        System.out.println("Nothing");
      } 
  }
  /* 
  说明：
  >如果多个条件表达式之间是“互斥”关系，没有交集，判断和执行语句的顺序可以随便换，无所谓
  >如果多个条件表达式之间有交集，需要根据实际情况考虑
  >如果多个条件表达式之间是包含关系，通常情况下，范围小的写在上面
  */
}
```

例题2：输入三个数，排序

```java
import java.util.Scanner
  /* 
  从键盘输入三个整数用if-else排序，从小到大排序
  */
class IfTest2{
  
  public static void main(String[] args){
    
    Scanner scan = new Scanner(System.in);
    
    Systemout.println("请输入第一个整数：");
    int n1 = scan.nextInt();
    Systemout.println("请输入第二个整数：");
    int n2 = scan.nextInt();
    Systemout.println("请输入第三个整数：");
    int n3 = scan.nextInt();
    
    if (n1 > n2){
      if (n3 >= n1){
        System.out.println(n2 + "," + n1 + "," + n3);
      }else if(n3 <= n2){
        System.out.println(n3 + "," + n2 + "," + n1);
      }else{
        System.out.println(n2 + "," + n3 + "," + n1);
      }
    }else{
      if (n3 >= n2){
        System.out.println(n1 + "," + n2 + "," + n3);
      }else if(n3 <= n1){
        System.out.println(n3 + "," + n1 + "," + n2);
      }else{
        System.out.println(n1 + "," + n3 + "," + n2);
      }
      
    }
  }
  /* 
  说明：
  >如果多个条件表达式之间是“互斥”关系，没有交集，判断和执行语句的顺序可以随便换，无所谓
  >如果多个条件表达式之间有交集，需要根据实际情况考虑
  >如果多个条件表达式之间是包含关系，通常情况下，范围小的写在上面
  */
}
```

**重点：**`if-else`结构可以嵌套，实际开发中很少会用到超过3层的嵌套`if-else`

#### switch-case例题

```java
/* 
通过键盘输入month 和date，输出2019年的第几天
目的是展示Break不是一定要写的
*/
import java.util.Scanner;
class SwitchCaseTest2{
  
  public static void main(String[] args){
    Scanner scan = new Scanner(System.in);
    System.out.println("请输入2019年的month：");
    int month = scan.nextInt();
    System.out.println("请输入2019年的day：");
    int day = scan.nextInt();
    int sumDays = 0;
    switch(month){
      case 12:
        sumDays += 30;
      case 11:
        sumDays += 31;
      case 10:
        sumDays += 30;
      case 9:
        sumDays += 31;
      case 8:
        sumDays += 31;
      case 7:
        sumDays += 30;
      case 6:
        sumDays += 31;
      case 5:
        sumDays += 30;
      case 4:
        sumDays += 31;
      case 3:
        sumDays += 28;
      case 2:
        sumDays += 31;
      case 1:
        sumDays += day;
    }
    System.out.println("2019年" + month + "月" + day + "日是2019年的第" + sumDays + "天");
  }
}
```

凡可以用`switch-case`写的分支结构都可以用`if-else`写，反之不成立

#### 循环结构

* 循环结构的四个要素

  1. 初始化条件
  2. 循环条件 ==>是`boolean`类型
  3. 循环体
  4. 迭代条件

* `for`循环的结构

   ```java
   for(int i = 1; i < 10; i++){
     /* 循环体 */
   }
   
   /* 写程序循环1到150自然数，如果是3的倍数加上foo 如果是5的倍数打印biz 如果是7的倍数baz*/
   for(int i = 1; i < 151; i++){
     
     System.out.print(i + " ");
     if (i % 3 == 0){
       System.out.print("foo");
     }
     if (i % 5 == 0){
       System.out.print("biz");
     }
     if (i % 7 == 0){
       System.out.print("baz");
     }
     System.out.println();
   }
   ```

  真正工作的时候代码量没有现在这么大，可能一天是200--300行，也就是说我现在学习的过程中，一天至少要敲500行代码。我猜的

---

Here is May 22, 2021

### Day 05 Java基本语法

#### 每日一考

1. `switch` 后面使用的表达式可以是哪些类型的数据？
   6种：`byte, short, int, char, 枚举类型(JKD 5.0), String(JKD 7.0)`

2. 使用`switch`语句改写下列`if`语句：

   ```java
   int a = 3;
   int x = 100;
   if(a == 1)
     x += 5;
   else if(a == 2)
     x += 10;
   else if(a == 3)
     x += 16;
   else
     x += 34;
   
   //改写
   switch(a)
     case 1:
     x += 5;
   	break;
   	case 2:
     x += 10;
   	break;
   	case 3:
     x += 16;
   	break:
   default:
     x += 34;
   
   
   ```

   

3. 谈谈三元运算符、`if-else`语句、`switch-case`结构的使用场景的理解
   `if-else`语句是最通用的，意思是能用三元的和能用`switch-case`的都能用`if-else`，反之不成立
   如果不是特别麻烦尽可能使用三元或者`switch-case`的话，因为执行效率稍微高一点点

4. 如何从控制台获取`String`和`int`型的变量，并输出？

   ```java
   import java.util.Scanner;
   Scanner scan = new Scanner(System.in);
   
   String str = scan.next();
   int n1 = scan.nextInt();
   ```

   

5. 使用`for`循环便利100以内的奇数，并计算所有的奇数的和并输出

   ```java
   int sum = 0;
   for(int i = 1; i < 101; i++){
     if (i % 2 == 1){
       sum += i;
     }
   }
   System.out.println("100以内所有奇数的和是 " + sum);
   ```

#### for循环例题

```java
/*
题目：输入两个正整数m和n，求其最大公约数和最小公倍数
说明：break关键词的使用
*/
import java.util.Scanner;

class ForTest{
  
  public static void main(String[] args){
    
    Scanner scan = new Scanner(System.in);
    System.out.println("请输入第一个正整数");
    int m = scan.nextInt();
    System.out.println("请输入第二个正整数");
    int n = scan.nextInt();
    
    //最大公约数：获取两个数中的最小值，从它开始往下走，找到（公约数）就停
    for(int i = (m < n )? m : n; i>0; i--){
      if (m % i == 0 && n % i == 0)
        System.out.println("最大公约数为：" + i);
      	break;
    }
    //最大公约数：获取两个数中的最小值，从它开始往下走，找到（公约数）就停
    int max = ( m < n) ? n : m;
    for (ing i = max;i <= m * n;i++){
      if (i % m == 0 && i % n == 0){
        System.out.println("最小公倍数为：" + i);
        break;
      }
    }
    
    
  }
  
}
```

#### while循环

```java
/*
while循环依然是有四个要素
1. 初始化条件
2. 循环条件 ==>是`boolean`类型
3. 循环体
4. 迭代条件

1
while(2){
3;
4;
}
*/
int i = 0;
while(i<100){
  //do something
  i++;
}
```

`for`循环和`while`循环是可以互相转换的。如果一定要说区别的，`while`循环指标（初始化条件的作用域）`i`在`while`循环外面也有用

#### do-while循环

```java
/*
do-while循环依然是有四个要素
1. 初始化条件
2. 循环条件 ==>是`boolean`类型
3. 循环体
4. 迭代条件
*/
1
do{
3;
4;
}while(2)
```

循环体至少会执行一次，这是跟`while`的主要区别。在实际开发中，还是`for`循环和`while`循环使用的 多一些。

#### 循环嵌套例题

```java
/* 
输出100以内的所有质数
从2开始到这个数-1开始，都不能被这个数整除
*/

class PrimeNumberTest{
  
  public static void main(String[] args){
    
    for (int i = 2; i < 101; i++){//遍历100以内自然数
      boolean ifPrime = true;
      
      for (int j = 2; j < i; j++){//j: 去被i除
        if (i % j == 0){
          isPrime = false;
        }
        
      }
      if(isPrime){
        System.out.println(i);
      }
    }
    
  }
}
```

写成上面这样，问题解决了但是效率比较低，下面考虑优化

```java
/* 
输出100以内的所有质数，以及优化
Java程序计时
*/

class PrimeNumberTest{
  
  public static void main(String[] args){
    boolean ifPrime = true;
    long start = System.currentTimeMillis();
    
    for (int i = 2; i < 101; i++){//遍历100以内自然数
      /* j 从 2 只需要到 sqrt i 即可*/
      for (int j = 2; j < Math.sqrt(i); j++){//j: 去被i除
        if (i % j == 0){
          isPrime = false;
          /* 优化一：这里加个break 对本身非质数的自然数是有效的*/
          break;
        }
      }
      if(isPrime){
        System.out.println(i);
      }
      //reset isPrime
      isPrime = true;
    }
    long end = System.currentTimeMillis();
    
    System.out.println("所花费的时间为" + (end - start) / 1000);
  }
}
```

|            | 使用范围                    | 循环中使用的作用 | 相同点                     |
| ---------- | --------------------------- | ---------------- | -------------------------- |
| `break`    | `switch-case`<br />循环结构 | 结束当前循环     | 关键字后面不能声明执行语句 |
| `continue` | 循环结构                    | 结束当次循环     | 关键字后面不能声明执行语句 |

```java
/*
带标签的break和continue语句
*/
label:for(int i = 1; i < 5; i++){
  
  for(int j = 1; j < 10; j++){
    
    //...
    break label;
    
  }
}

//直接来一个质数输出的实现方法二
class PrimeNumberTest2{
  
  public static void main(String[] args){
    long start = System.currentTimeMillis();
    
    label:for (int i = 2; i < 101; i++){//遍历100以内自然数
      /* 优化二 j 从 2 只需要到 sqrt i 即可*/
      for (int j = 2; j < Math.sqrt(i); j++){//j: 去被i除
        if (i % j == 0){
          continue label;
        }
      }
      //能执行到这里的都是质数
    }
    long end = System.currentTimeMillis();
    
    System.out.println("所花费的时间为" + (end - start) / 1000);
  }
}
```

---

here is May 23, 2021

#### 项目一

```java
class FamilyAccount{
  
  public static void main(String[] args){
    
    boolean isFlag = true;
    
    String details = "Income/Expense\tTotal\tAmount\tRemark\n";//Used for log use input
    //initial amount
    int balance = 1000;
    while(isFlag){
      
      System.out.println("------------Family Account------------\n");
      System.out.println("            1.\tDetails\n");
      System.out.println("            2.\tLog Income\n");
      System.out.println("            3.\tLog Expense\n");
      System.out.println("            4.\tQuit\n");
      
      //获取用户输入
      char selection = Utility.readMenuSelection();
      switch (selection){
        case '1':
          System.out.println("------------Account Summary------------");
          System.out.println(details);
          System.out.println("---------------------------------------");
          break;
        case '2':
          System.out.println("Enter income amount: ");
          int money = Utility.readNumber();
          System.out.print("Enter income detail: ");
          String info = Utility.readString();
          
          //process balance
          balance += money
          //process details
          details += ("income\t" + balance + "\t" + money + "\t" + info + "\n");
          
          System.out.print("------------Log Complete------------");
          break;
        case '3':
          System.out.println("Enter expense amount: ");
          int money = Utility.readNumber();
          System.out.print("Enter expense detail: ");
          String info = Utility.readString();
          
          //process balance
          if (balance >= money){
            balance -= money
          	//process details
          	details += ("expense\t" + balance + "\t" + money + "\t" + info + "\n");
            
          }else{
             System.out.print("------------Not Enough Blance------------");
          }

          
          System.out.print("------------Log Complete------------");
          break;
        case '4':
          System.out.println("Are you sure you want to quit? [Y/N]");
          char isExit = Utility.readConfirmSelecion();
          if (isExit == 'Y'){
            isFlag = false;
          }
      }
    }
    
  }
}
```



### Day 06 Eclipse与数组

#### 每日一考

1. 循环结构是如何最后退出循环的？有哪些不同情况，说明
   循环条件为`false`的时候、循环体内有`break`
   注意:`continue`不能算做结束循环，`return`和异常都会结束循环，但不是正常的方式

2. 程序题：

   ```java
   label: for (int i = 1; i <= 4; i++) {
   			for (int j = 1; j <= 10; j++) {
   				if (j % 4 == 0) {
   					continue label;
   				}
   				System.out.print(j);
   			}
   			System.out.println();
   }
   ```

   输出结果是：`123123123123`

3. 一个数如果恰好等于它的因子之和，这个数就称为"完数"。例如6=1＋2＋3。编程 找出1000以内的所有完数。（因子：除去这个数本身的其它约数）

   ```java 
   int factor = 0;
   for (int i = 1; i < 1001; i ++ ){
     
     for(int j = i; j <= i/2;j++){
       if (i % j == 0){
         factor += j;
       }
     }
     if ( i == factor ){
       
       System.out.println(i);
     }
       factor = 0;
   }
   ```

   

4. 说明break和continue使用上的相同点和不同点
   `break` 可以用在循环和`switch-case`但是`continue`只能用在循环结构中
   `continue`只能结束当次循环
   相同点：后面都不能再接语句了

5. 从控制台输出如下结构

   ```java
   /*
   
   ******
   *****
   ****	
   ***	
   **	
   *
   
   */
   for(int i = 6; i > 0; i--){
     
     for(int j = i; j > 0; j --)
       System.out.print('*');
     System.out.prinln();
   }
   U+2387
   &#9658;
   ```

#### Hello Eclipse

* 透视图的设置，已搞定
* 用Eclipse编写Hello World程序，已搞定
* Windows 下的`alt + /`现在在Mac下没有搞定
  * 现在搞定了，需要把默认的`contenct assist 改成⎇+/`&#9095; 
* 导入已有的工程
  `File > Import > Gneral > Existing Projects into Workspace`
  牵扯到改名的问题
  改已经Workspace里面的：`refactor > rename `
* 查看源代码的问题:
  * 按住`command` 加鼠标点击就可以进入源码
  * `command + o`可以开启搜索文档
  * &#8984; 8984

#### 数组

* 数组Array，是多个 同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对数据进行统一管理
* 数组的相关概念
  * 数组名
  * 元素
  * 角标、下标、索引 index
  * 数组的长度：数组元素的个数、一旦确定不能修改
* 数组的特点：
  * 有序排列的
  * 数组属于引用数据类型的变量；数组的元素既可以是基本数据类型，也可以是引用数据类型
  * 创建数组的时候是在内存中开辟一块连续的空间，而数组名中引用的是这块连续空间的首地址
* 数组的分类：
  * 按照维数
  * 按照元素的类型：基本数据类型元素的数组，引用数据类型元素的数组

#### 一维数组的使用

1. 声明和初始化

   ```java
   int[] ids; //声明
   		
   //静态初始化:数组的初始化和数组元素的初始化同时进行
   ids = new int[] {1001,1002,1003,10004};
   
   //动态初始化:数组的初始化和数组元素的初始化分开进行
   String[] names = new String[5];//声明和初始化一起做了
   ```

   数组一旦初始化完成了，长度就确定了

2. 调用指定位置的元素

   ```java
   ids[0] = 1;
   
   names[names.length -1] = "Chris Jin"
   ```

   数据库的表索引/数据库表的列索引是从1开始的

3. 获得数组的长度

   ```java
   int[] arr = new int[10];
   len = arr.length;
   ```

   

4. 遍历数组

   ```java
   int[] arr = new int[10];
   for(int i = 0; i < arr.length; i++){
     //process arr[i];
   }
   ```

   

5. 数组元素默认初始化值

   ```java
   /*
   基本数据类型的默认初始化值：
   
   */		
   //整型：0
   int [] arr = new int[4];
   for(int i = 0; i < arr.length; i++) {
     System.out.println(arr[i]);
   }
   	System.out.println("****************");
   //浮点型：0.0
   float [] arr2 = new float[4];
   for(int i = 0; i < arr2.length; i++) {
     System.out.println(arr2[i]);
   }
   	System.out.println("****************");
   //字符型：'\u0000'
   char [] arr3 = new char[4];
   for(int i = 0; i < arr3.length; i++) {
     System.out.println(arr3[i]);
   }
   	System.out.println("****************");
   //布尔型：false
   boolean [] arr4 = new boolean[4];
   for(int i = 0; i < arr4.length; i++) {
     System.out.println(arr4[i]);
   }
   /*
   引用数据类型的默认初始化值：
   */
   
   //引用数据类型：null
   String[] str = new String[5];
   System.out.println(str[0]);
   ```

6. 内存解析
   内存的结构是由JVM规范规定的
   ![JVM内存解析](/Users/chris/Coding Bootcamp/Notes/Backend/00. Java基础/Memory_Structure.png)

#### 二维数组的使用

我们可以看成是一维数组 array1又作为另一个一维数组array2的元素而存 在。从数组底层的运行机制来看，其实没 有多维数组。

1. 声明和初始化

   ```java
   //静态初始化
   int[][] arr1 = new int[][]{{1,2,3},{4,5},{6,7,8}};
   //动态初始化
   String[][] arr2 = new String[3][2];
   String[][] arr2 = new String[3][];//这么写也行
   
   //前面的方括号位置几乎可以随便放
   int[] arr3[] = new int[3][];
   //类型推断
   int[] arr4[] = {{1,2,3},{4,5},{6,7,8}};
   
   System.out.println(arr2[1][0]);//报错
   arr2[1] = new int
   ```

   

2. 调用指定位置的元素`arr1[0][1] = 6;  `

3. 获得数组的长度`arr1.length`是3，`arr1[0].length`是3

4. 遍历数组

   ```java
   for(int i = 0; i < arr4.length; i++){
     for(int j = 0; i < arr4[i].length; j++)
       //process arr4[i][j];
   }
   ```

   

5. 数组元素默认初始化值

   ```java
   	String[][] arr2 = new String[3][5];
   	
   	System.out.println(arr2);//[[Ljava.lang.String;@2a139a55
   	System.out.println(arr2[0]);//[Ljava.lang.String;@15db9742
   	System.out.println(arr2[0][0]);//null
   	
   	String[][] arr1 = new String[3][];
   	
   	System.out.println(arr1);//[[Ljava.lang.String;@6d06d69c
   	System.out.println(arr1[0]);//null
   	System.out.println(arr1[0][0]);//java.lang.NullPointerException
   ```

   

6. 内存解析
   略，图在心中

### Day 07数组

#### 每日一考

1. 一维数组初始化的两种方式

   ```java 
   //静态初始化
   int[] arr1 = new int[] {123};
   //支持类型推断
   int[] arr1 = {123};
   //动态初始化
   int arr1[] = new int[3];
   ```

   

2. 二维数组初始化的两种方式

   ```java
   //静态初始化
   int[][] arr2 = new int[][]{{123,456},{7,8}}
   //支持类型推断
   int[][] arr2 = {{123,456},{7,8}}
   //动态初始化
   int[][] arr3 = new int[4][3];
   int[][] arr4 = new int[4][];
   ```

   

3. 遍历如下的二维数组`int[][] arr = new int[][]{{1,2,3},{4,5},{6,7,8}};`

   ```java
   for(int i = 0; i < arr.length; i++){
     for(int j = 0; j <arr[i].length; j++){
       //process arr[i][j];
     }
   }
   ```

   

4. 不同类型的一维数组元素的默认初始化值是多少
   `int,short,long: 0`；`float,double: 0.0`；`boolean: false`；`char: \U0000`；引用数据类型`null`

5. 一维数组的内存解析：

   ```java 
   String[] strs = new String[5];
   str[2] = "Tom";
   strs = new String[3];
   
   //Stack: strs = 0x1212; Heap: 0x1212--连续五个地址值--0x1213,0x1214,0x1215,0x1216,全是null
   //Stack: strs = 0x1212; Heap: 0x1214 变成 Tom，其实Tom在字符串常量池中，所以其实还是个地址值
   //Stack: strs = 0x2121; Heap: 0x2121--连续三个地址值--0x2122,0x2123,全是null
   ```

   

#### 数据结构浅谈

数据结构解决两种问题：

1. 数据与数据之间的逻辑关系：集合、一对一（链表）、一对多（树）、多对多（网络、地图）
2. 数据的存储结构：
   线性表：刻画一对一的关系，顺序表（数组）、链表、栈、队列（消息队列）
   树形结构：二叉树（B tree、B+tree）
   图形结构：

算法：没有边界，排序算法，搜索算法等

---

here is May 24, 2021

#### 数组练习题

1. `int[] x, y[];`的结果是`x`是`int`型一维数组，`y`是`int`型二维数组`int[] x; int[] y[];`

2. 杨辉三角形

   ```java
   package com.atguigu.exer;
   
   public class YangHuiTest {
   public static void main(String[] args) {
   	//1. 声明并初始化二维数组
   	int[][] yanghui = new int[10][];
   	//2. 给数组的元素赋值
   	for(int i =0; i < yanghui.length; i++) {
   		yanghui[i] = new int[i+1];
   		//首末元素，连续赋值
   		yanghui[i][0] = yanghui[i][i] = 1;
   		//给首末元素赋值
   		//if(i > 1) {
   		for(int j = 1; j < yanghui[i].length - 1; j++) {// j < i 是i错的！
   			yanghui[i][j] = yanghui[i-1][j] + yanghui[i-1][j-1];
   		}
   		//}去掉也可以
   	}
   	//3. 遍历二维数组
   	for(int i = 0; i < yanghui.length; i++) {
   		for(int j = 0; j < yanghui[i].length; j++) {
   			System.out.print(yanghui[i][j] + "\t");
   		}
   		System.out.println();
   	}
   }
   }
   ```

   

#### 常用算法

1. 数组元素赋值（杨辉三角、回姓数）

   ```java
   package com.atguigu.java;
   /*
   回形数
   */
   import java.util.Scanner;
   
   public class HuiXingShu1 {
   	public static void main(String[] args) {
   		Scanner scan = new Scanner(System.in);
   		
   		System.out.print("Please Enter the Size of the problem:");
   		int size = scan.nextInt();
   		
   		int[][] arr = new int[size][size];
   		
   		int l = 0, top = 0, state = 0;// left and top limit
   		int num = 1;//the next number to fill in
   		int r = size -1, bot = size -1; // right and bottom limit 
   		int row, col;// current position
   		row = col = 0;
   		
   		while(num <= size * size) {
   			System.out.println("State is: " + state);
   			switch(state) {
   			
   			case 0:
   				//going right
   				while(col <= r) {
   					arr[row][col] = num;
   					num++;
   					col++;
   				}
   				col = (col > r)?r : col;
   				top ++;
   				row ++;
   				System.out.println("row index: " + row + " column index: " + col);
   				break;
   			case 1:
   				//going down
   				while(row <= bot) {
   					arr[row][col] = num;
   					num++;
   					row++;
   				}
   				row = (row > bot)?bot : row;
   				r--;
   				col--;
   				System.out.println("row index: " + row + " column index: " + col);
   				break;
   			case 2:
   				//going left
   				while(col >= l) {
   					arr[row][col] = num;
   					num++;
   					col--;
   				}
   				bot--;
   				row--;
   				col = (col < l)?l : col;
   				System.out.println("row index: " + row + " column index: " + col);
   				break;
   			case 3:
   				//going up
   				while(row >= top) {
   					arr[row][col] = num;
   					num++;
   					row--;
   				}
   				row = (row < top)?top : row;
   				l++;
   				col++;
   				System.out.println("row index: " + row + " column index: " + col);
   				break;
   			
   			}
   			
   			//update state
   			state = (state + 1) % 4;
   
   			for(int i = 0; i < arr.length; i++) {
   				for(int j=0; j<arr[i].length;j++) {
   					System.out.print(arr[i][j] + "\t");
   				}
   				System.out.println();
   		
   			}
   			System.out.println("********");
   		}
   		
   		scan.close();
   		System.out.print("Stopped");
   }
   }
   ```

   

2. 求数值型数组中元素的最大值、最小值、平均数、总和等
   随机数`(int) (Math.random() * (max - min + 1)) + min`

3. 数组的复制、反转、查找（Linear Search; Binary Search）

   ```java
   //数组的复制
   int[] arr1, arr2;
   arr1 = {1,2,4,45,5};
   arr2 = new int[arr1.length];
   for(int i = 0; i < arr1.length; i++){
     arr2[i] = arr1[i];
   }
   
   //数组的反转
   //方式一：注意别i的终止条件，别搞两遍了
   for(int i = 0; i < arr1.length / 2 ; i++) {
     String temp = arr[i];
     arr[i] = arr[arr.length - i - 1];
     arr[arr.length - i -1] = temp;
   }
   //方式二
   for(int i = 0, j = arr.length; i < j;i++,j--) {
     String temp = arr[i];
     arr[i] = arr[j];
     arr[j] = temp;
   }
   
   	//Binary Search
   	//prerequisite: sorted list
   	boolean isNotFind = true;
   	int[] arr2 = new int[] {-99, -34, 2,3,4,5,6,7,1234,12567,79345};
   	int dest1 = -34;
   	int head = 0;//初始的首索引
   	int end = arr2.length;//初始的末索引
   	
   	while(head <= end) {
   		int middle = (head + end)/2;
   		if(dest1 == arr2[middle]) {
   			System.out.println("Find item " + dest1 + " at " + middle);
   			isNotFind = false;
   			break;
   		}else if (arr2[middle] > dest1){
   			end = middle -1;
   		}else {
   			head = middle + 1;
   		}
   		
   	}
   	if(isNotFind){
   		System.out.println("item not found");
   	}
   ```

   

4. 数组元素的排序算法
   时间复杂度，空间复杂度，稳定性
   内部排序：内存中搞定的
   外部排序：数据量比较大，需要借助外部存储设备才能搞定
   <span style="color:red;">冒泡、快排</span>需要会手写
   <span style="color:orange;">堆排序、和并归</span>需要知道

5. 算法的特征
   5.1 输入(Input)：0个或者有多个输入数据，这些输入必须有清楚的描述和定义
   5.2 输出(Output)：至少1个或多个结果
   5.3 有穷性(Finiteness)：在有限步骤内结束，并在可接受的时间范围内完成
   5.4 确定性(Definiteness)：每一步都有确定的含义，没有二义性
   5.5 可行性(Effectiveness)：算法的每一步都是清楚且可行的，用纸笔也能搞定

```java
/*
冒泡
*/
for(int i = 0; i < arr.length - 1; i++) {
		
		for(int j = 0; j < arr.length - 1 -i; j++) {
			if (arr[j] > arr[j+1]) {
				int temp = arr[j];
				arr[j] = arr[j+1];
				arr[j + 1] = temp;
			}
			
		}
		
	}
	
	for (int i = 0; i < arr.length; i++) {
		
		System.out.print(arr[i] + "\t");
	}
```



#### Arrays工具类

`java.util.Arrays`

1. 判断两个数组是否相等`Arrays.equals(int[] a, int[] b)`
2. 输出数组的信息`Arrays.toString(int[] a );`底层用到`StringBuilder()`
3. 将指定值填充到数组之中`void fill(int[] a, int val);`
4. 对数组进行排序`void sort(int[] a)`底层用到快排
5. 对排序后的数组进行二分法搜索`int binarySearch(int[] a, int key)`找到返回索引，找不到返回一个负数

#### 常见异常

出现异常程序就终止了，后面的都不执行了

1. 角标越界异常`ArrayIndexOutOfBountException`
2. 空指针异常`NullPointerException`

---

here is May 24, 2021

### Day 08 OOP上

#### 每日一考

1. 使用冒泡排序，实现如下的数组从小到大排序。`int[] arr = new int[]{34,5,22,-98,6,-76,0,-3};`

   ```java
   public static void main(String[] args) {
   	
   	int[] arr = new int[]{34,5,22,-98,6,-76,0,-3};
   	
   	for(int i = arr.length - 1; i > 0; i--) {
   		for(int j = 0; j < i; j ++) {
   			if(arr[j] > arr[j+1]) {
   				int temp = arr[j];
   				arr[j] = arr[j+1];
   				arr[j+1] = temp;
   			}
   		}
   
   	}
   	for(int i = 0; i < arr.length; i++) {
   		System.out.print(arr[i] + " ");
   }
   }
   ```

   

2. 如何反转上面的数组。请代码实现

   ```java
   int temp = 0;
   for(int i = 0; i < arr.length / 2; i++) {
     temp = arr[i];
     arr[i] = arr[arr.length - i - 1];
     arr[arr.length - i - 1] = temp;
   }
   ```

   

3. 复制上述数组，得到一个新的数组

   ```java
   int[] arr2 = new int[arr.length];
   	for(int i = 0; i < arr.length; i++) {
       arr2[i] = arr[i];
     }
   System.out.println();
   System.out.println("***************");
   for(int i = 0; i < arr2.length; i++) {
     System.out.print(arr2[i] + " ");
     }
   ```

   

4. 使用线性查找，从上述数组中查找22是否存在。存在，返回所在位置的索引。不存在，输出提示信息。

   ```java
   	int tar = 22;
   	boolean isFound = false;
   	for(int i = 0; i < arr.length; i++) {
   		if(arr[i] == tar) {
   			System.out.println(tar + " is found at index " + i);
   			isFound = true;
   			break;
   		}
   	}
   	if(!isFound) {
   		System.out.println(tar + " is NOT found");
   	}
   ```

   

5. 数组中常见的异常有哪些？请举例说明
   角标越界异常`ArrayIndexOutOfBoundException`
   空指针异常`NullPointerException`

#### 面向对象概述

这部分是核心，后面基本都是应用；特点是内容多，细节多，都需要理解和记忆。

<span style="color:red;">大处着眼，小处着手</span>

学习的三条主线，并行推进

1. Java类及类的成员：
   属性、方法、构造器；代码块、内部类
2. 面向对象的三大特征：
   封装性、继承性、多态性；先把代码弄明白，思想层面的事情后面再体现；如果要说有四个就是抽象性
3. 其他关键字：
   `this`，`super`，`static`，`final`，`abstract`，`interface`，`package`，`import`，等

#### POP vs OOP

面向过程POP与面向对象OOP的对比:<span style="color:red;">大象装进冰箱</span>

面向过程强调的是功能行为，以函数为最小单位，考虑怎么做

1. 把冰箱门打开
2. 抬起大象，塞进冰箱
3. 把冰箱门关上

面向对象对功能进行封装，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做

```java
人{
  打开(冰箱){
    冰箱.打开();
  }
  抬起(大象){
    大象.进入(冰箱)
  }
  关闭(冰箱){
    冰箱.闭合;
  }
}
冰箱{
  打开(){}
  闭合(){}
  
}
大象{
  进入(冰箱){
  }
  
}
```

程序员：从面向过程的执行者转化成了面向对象的指挥者

思路及过程：

1. 分析需求，选择问题所针对的现实世界中的实体
2. 从实体中寻找解决问题相关的属性和功能，这些属性和功能形成了概念中的类
3. 把抽象的实体用计算机语言来表述，形成计算机世界中的类
4. 类实例化成计算机世界中的对象，对象是解决计算机世界中问题的最终工具

#### Java类和对象

`Class`和`Object`是面向对象核心概念

* **类**是对一类事物的描述，是抽象的、概念上的定义。相当于图纸、蓝图
* **对象**是实际存在的该类事物的每个个体，因为也成为**实例(instance)**。相当于产品
  * Java语言万物皆对象

面向对象程序设计的重点是类的设计，而类的设计就是类成员的设计。类的内部结构主要有两个：

* `属性 = 成员变量 = field = 域 = 字段` 对应类中的
* `方法 = 成员方法 = method = 函数` 功能和行为

类和对象的使用（面向对象思想落地实现）：

1. 创建类、设计类的成员（这一步是最花时间的）
2. 创建类的对象
3. 通过`对象.属性`或`对象.方法`调对象中的结构

每个对象有自己独立的一套属性，属性也有默认初始化值（非`static`）
![复杂版内存解析](/Users/chris/Coding Bootcamp/Notes/atguigu-notes/Backend/00. Java基础/内存解析.png)

属性（成员变量）和局部变量的异同

1. 相同点:
   1.1 都是变量，所以定义格式是一样的：数据类型 变量名 = 变量值；
   1.2 先声明，后使用
   1.3 都有其作用域
2. 不同点：
   2.1 声明位置不同：
   <span style="color:red">属性</span>：直接定义在类的一对`{}`内
   <span style="color:red">局部变量</span>：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
   2.2 权限修饰符不同：
   <span style="color:red">属性</span>：可以在声明时，指明其权限，使用权限修饰符
   例如`private, public, 缺省, protected` 封装性的时候再说
   目前，都是用缺省就可以了
   <span style="color:red">局部变量</span>：不能使用权限修饰符
   2.3 默认初始化值的不同
   <span style="color:red">属性</span>：类的属性，根据其类型，都有默认初始化值
   <span style="color:red">局部变量</span>：没有默认初始化值=> 使用前必须显式初始化
   特别的：形参在调用时赋值即可
   2.4 内存中加载的位置不一样
   <span style="color:red">属性</span>：加载到堆空间中（非`static`）
   <span style="color:red">局部变量</span>：加载到栈空间中

方法声明格式，按照有无形参，有无返回值分为4类

|        | 无返回值                   | 有返回值                     |
| :----: | :------------------------- | ---------------------------- |
| 无形参 | `void method1(){}`         | `String method2(){}`         |
| 有形参 | `void method3(形参列表){}` | `String method4(形参列表){}` |

`static, final, abstract`也可以用来修饰方法，但是后面再说

```java
/*方法声明：权限修饰符 返回值类型 方法名 (形参列表){

}
*/

//如果声明的时候有返回值，则一定要有返回值，带分支的话也是每个分支都要有
public int getNum(){
  
  return 5;
  
}
//如果声明的时候没有返回值，则仍可以使用return来结束方法体，但不是一定要有

//return 后面不能再有执行语句
```

**形参列表格式：**

`[数据类型1 形参1， 数据类型2 形参2， 数据类型3 形参3，...]`

**方法体：**最多的工作是在这个地方，方法内部可以调方法，但是不能定义新的方法；调用自己叫递归，用不好可能会栈溢出

---

here is May 26, 2021

### Day 09 OOP上

#### 每日一考

1. 面向对象思想编程内容的三条主线是什么？
   Java类及类的成员：属性，方法，<span style="color: red;">构造器</span>；代码块，内部类
   面向对象三大特征：封装性、继承性、多态性、如果要第四个就是抽象性
   其他关键字：`statci`,`final`,`abstract`,`this`,`super`

2. 谈谈你对面向对象中类和对象的理解，并指出二者的关系
   类是泛指是抽象的，对象是特指是具体的。类是蓝图，对象是实例。Java里面万物皆对象

3. 面向对象思想的体现一：类和对象的创建和执行操作有哪三步？
   3.1 设计类
   3.2 创建：实例化对象
   3.3 调用属性和方法

4. 画出如下代码在执行时的内存分配情况

   ```java
   class Car{
          String color = "red";
          int num = 4;
          void show(){
   			  int a = 10;
   	          System.out.println("color="+color+",num="+num);
          }
   }
   class CarTest {
   	public static void main(String[] args) {
   		Car c1 = new Car();   
   		Car c2 = new Car(); 
   		c1.color = "blue";  
   		c1.show();   
   		c2.show();
     }
   }
   
   ```

   

5. 类的方法内是否可以定义变量？是否可以调用属性？是否可以定义方法？是否可以调用方法？
   可、可、不可、可

JVM内存解析：编译完源程序以后，生成一个或多个字节码文件。我们使用JVM中的类加载器和解释器对生成的字节码文件进行解释运行。意味着：需要讲字节码文件对应的类加载到内存中，涉及到内存解析

栈：局部变量存储在虚拟机栈中
堆：`new`出来的结构，比如数组，对象，加载在堆空间中
方法区：类的加载信息、常量池、静态域

#### 万物皆对象的理解

1. 在`Java`语言的范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构
2. 涉及到`Java`语言跟前端的`HTML`和后端的数据库在`Java`层面交互时，都体现为类、对象

匿名对象
没有显示给某给变量名，只能调用一次，开发中用的多

举例：新对象的地址已经赋给形参了

```java
class Phone{
	double price;
	
	public void sendEmail() {
		System.out.println("send Email");
	}
	
	public void playGame() {
		System.out.println("Play Game.");
	}
  
  public void showPrice(){
    System.out.println("Price is " + price);
  }
}

class PhoneMall{
  public void show(Phone phone){
    phone.sendEmail();
    phone.playGame();
  }
  
}

//别的主方法中：
new Phone().sendEmail(); 
PhoneMall mall = new PhoneMall();
mall.show(new Phone());
```

自己写类的时候尽量不要用和系统自带类重名的结构

#### 方法的重载

1. 定义：在同一个类中，允许存在一个以上同名方法，只要他们的参数个数或者参数类型不同即可。同名方法之间叫做重载
   “两同一不同”：同一个类，同方法名、参数列表不同

2. 举例：下列四个都构成重载

   ```java
   	public void getSum(int i, int j) {
   		System.out.println("1");
   	}
   	public void getSum(double d1, double d2) {
   		System.out.println("2");
   	}
   	
   	public void getSum(String s, int i) {
   		System.out.println("3");
   	}
   	
   	public void getSum(int i, String s) {
   		System.out.println("4");
   	}
   ```

3. 返回值类型无所谓，权限无所谓，形参名无所谓，如果把第一个getSum干掉，此时调用`getSum(1,2)`会打印`2`因为自动类型提升

4. 通过对象调用方法时，如何确定某一个指定的方法
   方法名 ==还要看==> 参数列表

#### 可变个数形参

* `JavaSE 5.0`加入了Varargs，允许直接定义能和多个实参匹配的形参。
* 格式`数据类型 ...形参名`。当调用可变个数的方法时，传入的参数可以是0个，1个，2个...
* 与其他同方法名，不同形参列表的方法构成重载
* 跟同类型数组参数的同名方法被认为是同一个方法，下面这俩不行
  * `public void show(String ... args){}`
  * `public void show(String[] args){}`
* 参数`args`就当成数组就可以了
* 必须声明在末尾，也就意味着只能有一个

#### Java方法参数传递：值传递机制

Java的实参值是如何传递的？都是值传递

* 基本数据类型是将实际存储的值赋给被赋值的变量
* 引用数据类型是将变量存储的地址值赋给被复制的变量

方法的形参传递机制。

* 形参：方法定义时，小括号内的参数
* 实参：调用方法的时候实际传递给参数赋的数据

---

Here is May 27, 2021

### Day 10 OOP上

#### 每日一考

1. 什么是方法的重载？
   两同一不同，在同一个类下的，同方法名不同形参列表的两个或多个方法相互构成重载
2. 说明Java方法中的参数传递机制的具体体现？
   值传递机制：体现在基本数据类型的变量，将实参的所存储的数据值复制给被传递的形参。
   引用数据类型则是将实参所存储的地址值传递给被赋值的对象
3. 成员变量和局部变量在声明的位置上、是否有默认初始化值上、是否能有权限修饰符修饰上、内存分配的位置上有何不同？
   成员变量直接声明在类的一对`{}`内，具有默认初始化值，可以使用权限修饰符，非`static`的都在堆空间中
   局部变量声明在：方法内，方法形参列表，构造器内，构造器形参列表，以及代码块当中
4. 谈谈return关键字的使用
   用来结束方法调用，对于有返回值的方法，用`return`关键字指明所要返回的值
5. 提供如下代码的内存解析
   ![image-20210528140207977](/Users/chris/Coding Bootcamp/Notes/atguigu-notes/Backend/00. Java基础/练习题.png)

#### 面向对象特征之一：封装与隐藏

* 为什么要封装？封装的作用和含义？
  * 用洗衣机只需要按开关就可以了，不需要知道内部怎么运作的，没必要碰电动机
  * 要开车，没必要知道发动机和传动的原理
* ​	我们写代码搞开发也是一样，我们用的是别人的API
  * 高内聚：类内部数据操作细节自己完成，不允许外部干涉
  * 低耦合：进队外暴露少量的方法用于使用
* 隐藏对象内部的复杂性，之队外公开简单的接口（不是后面的`Interface`） 从而提高系统的可扩展性和可维护性

1. 问题的引入

   当我们创建一个类的对象以后，我们可以通过`对象.属性`的方式，对对象的属性进行复制，这里，复制操作要收到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件，但是在实际问题中，我们往往需要给属性赋值有其他方法。这个需求仅靠属性声明不能满足。除此之外我们要禁止用户用`对象.属性`的方式对属性进行赋值`private`的使用。

2. 封装性的体现(只是体现，不等于封装性)
   我们将类的属性xxx私有化`private`，同时提供公开的`public` `getter/setter `方法来获取和设置属性
   拓展:其他封装性的体现，类内部自己使用的（不对外暴露的）私有方法，高内聚，单例模式也是封装性的体现

3. 封装性的体现需要权限修饰符来配合

   Java一共有四种，从小到大排列`private < （缺省）default < protected < public`
   `private`： 类内部
   `缺省`：类内部、同一个包

   `protected`：类内部、同一个包、不同包的子类
   `public`：类内部、同一个包、不同包的子类、同一个工程

* 四种可以用来修饰类及类的内部结构：
  * 属性、方法、构造器、内部类，注意，代码块不行
* 用来修饰类：`class`只能用`public`和`缺省`
* 总结： `Java`提供了四种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小

#### 构造器`constructor`

1. 构造器的作用：创建类的对象`new + constructor`、可以初始化对象的属性
2. 任何一个类都有构造器，如果没有显示定义构造器，则系统默认提供一个空参的构造器(权限与类一样，public或者缺省)
   一旦我们显示定义了类的构造器之后，系统就不再提供默认空参构造器
3. 构造器的定义格式：`权限修饰符 类型名(形参列表){}`
4. 不建议将构造器理解为一种特殊的方法，主要是构造器的作用与方法不同，且二者发生作用的时间也不一样
5. 一个类中，至少会有一个构造器

属性赋值的先后顺序：目前为止，对象属性赋值的四种方法

1. 默认初始化
2. 显示初始化
3. 构造器中初始化
   ***前三种之所以叫初始化，是因为只有一次，后面这种可以反反复复调用***
4. 通过`对象.方法`/`对象.属性`的方式

`Java Bean`是一种`Java`语言写成的，可以重用的组建，满足三个条件的Java类叫做Java Bean：

1. 类是公共的
2. 有一个无参的公共构造器
3. 有属性及对应的`getter/setter`方法

使用`JavaBean`将功能、处理、值、数据库访问和其他任何可以用`Java`代码创造的怼心啊哥进行打包，并且其他的开发者可以通过内部的JSP页面，Servlet，其他JavaBean，applet程序或者应用来使用这些对象。

用户可以认为JavaBean提供了一种随时随地的复制粘贴功能，不用关心任何改变。

#### 关键字`this`

* `this`可以理解为当前对象（方法中）或者当前正在创建的对象（构造器中），可以用来修饰属性、构造器、方法。
  * 在类的方法中，我们可以使用`this.属性`或`this.方法`的方式调用当前的属性或者方法，但是，通常情况下，我们都选择省略。特殊情况下，如方法的形参和类的属性同名的时候我们必须显示使用`this.变量`的方式表明次变量是属性，而非形参
  * 在类的构造器中，我们可以使用`this.属性`或`this.方法`的方式调用当前的属性或者方法，但是，通常情况下，我们都选择省略。特殊情况下，如构造器的形参和类的属性同名的时候我们必须显示使用`this.变量`的方式表明次变量是属性，而非形参
* `this（形参列表）`修饰和调用本类中指定的<span style="color:red;">其他</span>构造器:
  * 比如调空参的：`this();`
  * 比如调带参的：`this(age);`
  * 注意构造器不能调自己，也不能形成“环”，换言之，如果一个类中有n个构造器，则至多有n-1个构造器使用`this(形参列表)`这种形式
  * 构造器内部的，`this(形参列表)`必须出现在<span style="color:red;">首行</span> ==所以==>一个构造器内部只能调用一个

#### 关键字`package`和`import`

`package`

* `package`叫做包，目的是为了更好的实现项目中类的管理
* 使用`package`声明类或接口所属的包，声明在源文件的<span style="color:red;">首行</span>
* 包名属于标识符，遵循标识符的命名规范，见名知意`com.atguigu.java`
* 每`.`点一次代表一层文件目录
  * 补充：同一个包下不能命名同名的接口或类
  * 不同包下可以命名同名的接口或类

JDK中主要的包介绍

1. `java.lang`Java语言的核心类`String,Math,Integer,System`
2. `java.net`网络编程
3. `java.io`输入输出
4. `java.uitl`定义系统特性，接口的结合，日期日历相关函数
5. `java.text`java格式化相关
6. `java.sql`JDBC进行数据库编程的相关类/接口
7. `java.awt`抽象窗口工具机，写GUI的，渐渐被浏览器取代

MVC是常用设计模式之一，是结构清晰，灵活，同时也描述了程序各个对象之间的通信方式，降低了程序的耦合度

* 视图模型层：view.utils
* 控制器层：controller.activity/controller.base
* 数据模型层：model.bean/domain/model.dao/model.db

`import`关键词，导入

* 在源文件中现实的使用`import`结构导入指定包下的类、接口
* 申明在包的声明和类的声明之间
* 如果需要导入多个包，则并列写出即可
* 也可以使用xxx.*的方式导入xxx包下的所有结构
* `java.lang`包下的可以省略`import`这个结构，本包下定义的类和接口结构可以省略
* 如果有同名的类，在不同的包下，只能`import`其中的一个，另一个只能用全类名的方式
  * `Date`就有可能同时出现`java.util`和`java.sql`下都有这个类
* 如果使用`xxx.*`的方式表明可以`xxx`下的所有结构，但是如果使用的是`xxx`子包心爱的接口，则仍需要显示导入
  * `java.lang.reflect.Field`
* `import static`：导入指定的类或者接口中的结构静态：属性或者方法，用的少，落点是类而不是包

---

Here is May 28, 2021

### Day 11 OOP中

#### 每日一考

1. 构造器的作用是什么？使用中有哪些注意点(>=3条)
   构造器的作用：创建对象，初始化对象；注意名称与类名相同，如果不显示提供构造器的话系统默认提供一个空参构造器；如果显示提供了构造器则系统不再默认提供空参构造器；在构造器内可以调用其他结构，如属性和方法；<span style="color:red;">构造器没有返回值；每一个类都要有构造器；构造器不应该理解为特殊的方法，应该是跟方法并列的结构</span>

2. 关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序
   目前有四种：默认初始化 < 显示初始化  < 构造器初始化 < setter Method 赋值

3. this关键字可以用来调用哪些结构，简单说明一下其使用
   当前类或者当前正在创建的类的结构：属性`this.属性`、方法`this.方法名(方法形参)`、构造器`this(构造器形参)`。

4. Java中目前学习涉及到的四种权限修饰符都有什么？并说明
   由小到大：`private` < `缺省`< `protected`< `public`
   类内部，类和同一个包下，类和不同包下的字类，同一个工程
   出了工程都要用`import`来导入，import的时候要注意，`.`一次代表一层目录‘不同包内的同名类

5. 创建Circle类，提供私有的radius属性，提供相应的get和set方法，提供求圆面积的方法

   ```java
   public class Circle{
     private double radius;
     
     public void setRadius(double radius){
       this.radius = radius;
     }
     
     public double getRadius(){
       return this.radius;
     }
     
     public double findArea(){
       
       return Math.PI * this.radius * this.radius;
       
     }
     
   }
   ```


#### 项目二

写完了，跟了一下，比较简单。收获：

* 熟悉Eclipse 的快捷键，还有在Mac下熟悉指法。
* 建立自信
* MVC极简版初体验，有时间可以再反复品味一次

#### OOP特征，继承性，inheritance

* 好处：
  1. 减少了代码的冗余，提高了代码的复用性
  2. 便于扩展功能
  3. 为多态性的使用提供了前提
* 坏处：详见，*The Pragmatic Programmer*
* 继承的格式：`class A extends B{}`
  * `A` 子类、派生类`subclass`
  * `B`父类、超类、基类`superclass`
  * 体现：一旦子类`A`继承父类`B`以后，字类`A`中就获得了`B`中声明的所有的属性和方法
    * 父类中声明为`private`的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构，只是因为封装性的影戏那个，使子类不能直接调用父类中的结构。
  * 子类继承父类以后还可以声明自己的属性或方法：实现功能的拓展
    * 子类和父类的关系不同于，子集和集合的关系
* Java中关于继承行的规定：只支持单继承和多层继承
  * 一个类可以被多个子类继承
  * 一个类只能继承一个父类：`Java`中类的单继承性，不同于`c++`上的多继承性
  * 子父类是相对的概念，也就是可以多层继承。直接父类和间接父类
  * 子类继承父类以后，就获取了直接父类和所有间接父类中声明的属性和方法
* 如果我们没有显示地声明一个类的父类的话，则此类继承于`java.lang.Object`
  * 所有的`Java`类（除`java.lang.Object`外）都直接或间接继承于`java.lang.Object`。
  * 意味着，所有`Java`类都具有`java.lang.Object`类声明的功能。

---

Here is May 29, 2021

### Day 12 OOP中

后面项目大了以后，先跑起来，各种插件配置什么的弄好，然后再一个模块一个模块一点点写。

Eclipse macOS下点击行数设置断电需要双击

这里有`step into`失灵问题的解决

#### 方法的重写(override)

* 定义：子类中对从父类中继承来的方法进行该做，也称为方法的重置、覆盖。在执行过程中，子类的方法将覆盖父类的方法

* 应用：重写以后，当创建子类对象以后，通过子类对象调用父类中的同名同参的方法时，实际执行的是父类中被重写的方法 

* 要求：子类中交重写的方法，父类中的叫被重写的方法

  * 子类重写的方法和父类被重写的方法必须有相同的方法名称、形参列表
  * 子类重写的方法的返回值类型<span style="color:red;">不能大于</span>父类被重写的方法的返回值类型
    * 父类被重写的返回值类型是`void`的，则子类中重写的方法的返回值类型也只能是`void`
    * 父类被重写的返回值类型是`A`,则子类中重写的方法的返回值类型可以是`A`或者`A`的子类。这就意味着，如果父类中被重写的方法返回值是基本数据类型，则子类中重写的方法也必须是相同的基本数据类型
  * 子类重写的防范的访问权限<span style="color:red;">不能小于</span>父类被重写的方法的访问权限（摊煎饼）
    * 子类不能重写父类中声明为`private`权限的方法（不构成重写）
  * 子类抛出的异常<span style="color:red;">不能大于</span>父类被重写方法的异常

* 实际开发中，不用搞这么细致，需要重写的时候直接把父类的方法声明复制粘贴过来完事儿；或者用IDE自带的override提示功能

* 注意：子类与父类同名同参数的方法必须同时声明为非`static`的（此时是重写），或者同时声明为`static`的（此时不是重写）。因为`static`方法是属于类的，子类无法覆盖父类的方法。`static`一定不能被重写，为什么？因为不合理呀，类和子类各自是自己的类，所以有自己的`static`结构。井水不犯河水

* 方法声明的完全体

  ```java
  /*
  权限修饰符 返回值类型 方法名（形参列表）[throws 异常类型]{
  
  }
  */
  
  ```

#### 关键字`super`

`super`可以理解为“父类的”（包括间接父类），可以用来调用：属性、方法、构造器。

* 我们可以再子类的方法和构造器中通过`super.属性`或者`super.方法`的方式，显式调用父类中声明的属性或方法，但是，通常情况下我们习惯性省略`super.`
* 如果子父类中出现了同名的属性，可以用`super.属性`和`this.属性`来做区分。
* 特殊情况：当子类重写了父类的方法以后，我们想在子类的方法中调用父类中被重写的方法是，则必须显示的使用`super.`的方式
* `super(形参列表)`调用父类构造器的情况
  * 我们可以在子类的构造器中，使用`super(形参列表)`的方式，调用父类中声明的指定的构造器。
  * `super(形参列表)`的使用，必须声明在子类构造器的首行
  * 我们在类的构造器中，针对于`this(形参列表)`或`super(形参列表)`只能二选一，不能同时出现
    * 在类的所有构造器中，至少有一个类的构造器中是使用了`super(形参列表)`，调用了父类的构造器
    * 原因：回忆以前说过，一个类的`n`个构造器中，至多有`n - 1 `个使用了`this(形参列表)`的形式
  * 如果在构造器的首行没有显示的舍命，则默认调用的是`super()`,空参构造器

#### 字类对象实例化过程

1. 从结果上来看：（这就是继承性）
   1.1 子类继承父类以后，子类就获得了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。
2. 从过程上来看：
   2.1  继承性底层的实现跟直接或者间接调用父类的构造器有关，如果父类中的构造器被调用了，父类中声明的结构就被加载到内存中，子类也就继承到了
   2.2 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接地调用父类的构造器，直到`java.lang.Object`为止。正因为加载过所有父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。
3. 加载构造器不等于创建对象
   3.1 明确：虽然创建子类对象的时候调用了父类的构造器，但是！自始至终，只创建了一个对象，即为子类`new`的对象

类的继承课后练习题，super自己搞定了

#### OOP特征，多态性，Polymorphism

既是重点，也是难点。是面向对象中最重要的概念，在Java中的体现是：

<span style="color:red;">对象的多态性：父类的引用指向子类的的对象</span>

Java引用变量有两个类型：

* <span style="color:red;">编译时类型</span>：由声明该变量是使用的类型决定

* <span style="color:red;">运行时类型</span>：由实际赋给该变量的对象决定
* 口诀：<span style="color:red;">编译时，看左边；运行时，看右边（虚拟方法调用）</span>

如果编译时类型和运行时类型不一致，就出现了对象的多态性。

多态情况下：<span style="color:red;">看左边</span>看的是，父类的引用（父类中不具备子类的特有的方法）<span style="color:red;">看右边</span>看的是，子类的对象（实际运行的是子类重写父类的方法）

多态是的使用：虚拟方法调用

有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期我们实际执行的是子类重写父类的方法。

多态性的使用前提：

1. 类的继承关系
2. 有方法的重写

虚拟方法调用：子类中重写了父类中的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。

多态是<span style="color:red;">运行时行为</span>

---

May 30, 2021

### Day13 OOP中

#### 每日一考

1. 什么是多态性？什么是虚拟方法调用？
   多态：在Java中主要体现为对象的多态性，父类的引用指向子类的对象 == 子类的对象赋给父类的引用
   虚拟方法调用：编译看左边，运行看右边
2. 一个类可以有几个父类？（只能有一个）一个父类可以有多少个子类？（Java语言层面没有限制）子类能获取直接父类中的结构吗？（可以的，而且是一定可以的，连`private`都可以的）
3. 方法的重写(override/overwrite)的具体规则有哪些？
   子类中重写父类中同名同参数列表的方法
   private的不构成重写
   子类中重写的方法权限修饰符不小于父类中被重写的方法
   子类中重写的方法的返回值类型不大于父类中被重写的方法，意思是：如果是引用数据类型，则子类重写的方法返回值是被重写方法返回值类型或者它的子类
   子类中重写的方法抛出的异常类型不大于父类中被重写的抛出的异常。
4. super调用构造器，有哪些具体的注意点
   每一个类中，都至少有一个构造器调用了`super()`。`super(形参列表)`必须在构造器的首行，意思是，只能二选一而且必须二选一。一定会调用（所有）父类的构造器，一直到`java.lang.Object`
5. 在下面的代码结构中：使用关键字：this,super;方法的重写;继承;

<span style="color:red;">为什么规定`super()/this()`必须出现在构造器首行？</span>无论通过那个构造器创建子类对象，需要先保证先初始化父类。目的是当子类继承父类后，“继承”父类中所有的属性和方法，因此子类必须要知道父类如何对对象进行初始化.

#### 多态练习和理解

* 多态的重要性的体现：如果`Java`不支持多态性，抽象类和接口都没有意义了。

* 多态性只适用于方法，不适用于属性。

* 在多态存在下，不能调用子类特有的方法：编译时认为引用只是父类的类型，所以不能调用子类中特有的结构。但是子类中特有的结构肯定已经加载到内存中了。

  * 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于比纳凉声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。
  * 如何才能调用子类特有的属性和方法？使用强制类型转换符`Man m1 = (Man) p1;`(向下转型)
  * 向上转型其实就是多态性

* 使用强转时，可能出现异常的。为了避免出现`ClassCastException`问题，我们使用关键字`instanceof`进行判断，一旦返回`true`我们就强转，如果返回false就不进行向下转型。

  ```java
  if(p2 instanceof Woman){
    Woman w1 = (Woman)p2;
    w1.goShopping();
    System.out.println("********");
  }
  ```

  * 另外如果`class A extends B{}`，则，当`a instanseof A`返回`true`时，`a instanceof B`也一定是`true`

* 向下转型用的比较少，开发当中90%用的还是多态。

若子类重写了父类方法， 就意味着子类里定义的方法彻底覆盖了父类里的同名方法；对于实例变量则不纯在这样的现象，既是子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量；编译运行都看左边

#### `Object`类的使用

* 是所有`Java`类的根父类，如果在类声明的时候没有使用`extends`关键字指明其父类，则默认父类是`java.lang.Object`
  * 属性：无
  * `equals()`，`toString()`，`getClass()`，`hashCode()`，`clone()`，`finalize()`，`wait()`，`notify()`，`notifyall()`，
* 只声明了一个空参构造器
* 在对象被垃圾回收之前，垃圾回收器会调对象的`finalize()`方法。我们不要主动调取，留给垃圾回收器

`==`和`equals()`的区别：

1. `==`是运算符，可以使用在基本书据类型变量和引用数据类型变量中使用

2. 如果比较的是基本数据类型，比较两个变量保存的数据是否相等（类型不一定要一样）；如果比较的是引用数据类型的变量，则比较的是连个变量的地址值是否相等，即两个引用是否指向同一个对象实体。

3. `equals()`是一个方法，而非运算符

4. 只能适用于引用数据类型

5. `java.lang.Object`类中`equals()`的定义：

   ```java
   public boolean equals(Object obj){
     return (this == obj);
   }
   ```

   跟`==`的作用是相同的

6. 像`String`，`Date`，`File`，包装类等都重写了`Object`类中的`equals()`方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同。

7. 通常情况下，我们定义的类如果使用`equals()`的话，也通常是比较两个对象的实体内容是否相同，那我们需要重写`equals()`方法。可以仿写`String.equals()`，也可以用代码生成。

8. 注意，对称性、自反性、传递性、一致性、`x.equals(null)`永远返回`false`，类型不一样永远返回`false`

`toString()` 方法：

1. 当我们输出一个对象的引用时，实际上就是调用当前对象的`toString()`方法

2. `Object`类中`toString()`方法的定义：

   ```java
   public String toString(){
     reutnr getClass().getName() + "@" + Integer.toHexString(hashCode());
   }
   //comg.atguigu.java.Person@14f7e
   ```

   像`String`，`Date`，`File`，包装类等都重写了`Object`类中的`toString()`方法。使得在调用对象的`toString()`方法时，返回"实体内容"

3. 自定义类也可以重写`toString()`方法，调用次方法时，返回"实体内容"。

   ```java
   @Override
   public String toString(){
     return "Circle [radius=" + radius + "]";
   }
   ```

   

####  包装类的使用

单元测试的说明`JUnit`测试：

1. `当前工程 ==> 右键选择 build path ==> add libraries ==> JUnit4 ==> 下一步` 

2. 创建一个`Java`类，进行单元测试。要求：public的类，提供公共的无参构造器

3. 在此类中声明单元测试方法。
   此时的单元测试方法：要求权限是`public`，没有返回值，没有形参

4. 此单元测试方法上需要声明注解：`@Test`，并在单元测试类中导入`org.junit.Test`

   ```java
   import org.junit.Test;
   
   public class JUnitTest{
     
     @Test
     public void testEquals(){
       String s1 = "MM";
       String s2 = "MM";
       System.out.println(s1.equals(s2));
     }
       
   }
   ```

5. 声明好单元测试以后就可以在方法体内进行测试相关的代码

6. 写完代码以后，左键双击单元测试方法名，右键：`run as - JUnit Test`

说明：

1. 如果执行结果没有任何异常：绿条
2. 如果执行结果出现异常：红条

 包装类的使用：

1. java提供了8中基本数据类型对应的包装类（封装类），使得基本数据类型的变量具有类的特征（方法调用，继承，多态等）
2. 掌握的：基本数据类型、包装类、String三者之间的互相转换 
   2.1 基本数据类型 ==> 包装类：调用`包装类的构造器`
   2.2 包装类==>基本数据类型：调用`包装类的xxxValue()`
   2.3 `JDK5.0`新特性：自动装箱与自动拆箱
   自动装箱: `int num2 = 10;Integer in1 = num2;`
   自动拆箱： `int number3 = in1;`
3. 既然如此，基本数据类型和其对应的包装类可以看做是同一个类型。我们只需要掌握它和String之间的相互转换即可
   3.1 基本数据类型、包装类 ==> String类型：调用`String`重载的`valueOf(Xxx xxx)`方法，或者和空字符串`""`做链接运算
   3.2 `String` 类型 ==> 基本数据类型、包装类：调用`包装类的parseXxx()`方法，可能会报`NumberFormatException`

练习题：

```java
Object o1 = true ? new Integer(1) : new Double(2.0);
System.out.println(o1);// 1.0
```

因为三元运算符要求统一类型，所以会做自动类型提升

一道阴题：

```java
public void test(){
  
  Integer i = new Integer(1);
  Integer j = new Integer(1);
  System.out.println(i == j);//false
  
  Integer m = 1;
  Integer n = 1;
  System.out.println(m == n);//true;
  
  Integer x = 128;
  Integer y = 128;
  System.out.println(x == y);//false
}
```

`Integer`内部定义了`IntegerCache`结构，`IntegerCache`定义了`Integer[]`，保存了`-128-127`范围内的整数，需要用的时候直接用数组里面的整数就可以了，不用去`new`了
目的是提高效率

---

Here is June 1, 2021

### Day 14 OOP下

#### 每日一考

1. 如何实现向下转型？需要注意什么问题？如何解决此问题？
   使用强制类型转换符`m1 = (Man) p1`，可能转不成`ClassCastException`，异常处理的时候再具体说，使用instanceof 判断再进行向下转型。

2. == 和 equals()有何区别？
   `==`是运算符，可以作用于基本数据类型和引用数据类型，用于引用数据类型的时候比较的是地址值。`equals()`是方法，只能运用于类
   重写过的`equals()`方法比较的是对象的实际内容是否相同。

3. ```java
   class User{
   String name;
   int age;
   		//重写其equals()方法
     @Override
     public boolean equals(Object obj){
       if(obj == User){
         return true;
       }
       if(obj instanceof User){
         User u = (User)obj;
         return this.age == u.age && this.name.equals(u.name);
       }
       
       return false;
     }
   }
   
   ```

   

4. 写出8种基本数据类型及其对应的包装类
   `int ==> Integer`;`short ==> Short`;`byte ==> Byte`; `long ==> Long`; `boolean ==> Boolean`; `char ==> Character`; `float ==> Float`; `double ==> Double`

5. 基本数据类型、包装类与String三者之间如何转换:

   基本数据类型和其包装类之间：自动装箱、自动拆箱
   基本数据类型和其包装类 <==> String，调用后面那个家伙的方法

   基本数据类型、包装类 ===> `String`: `String.valueOf(new Long(13))`
   `String` ===>基本数据类型、包装类: `Long.parseLong(String s)`

数组也可以认为是一种特殊的类，也作为Object 的子类

#### `static`关键字的引入

以前：new一个对象，有一份属性和行为。有时候希望无论是否产生了对象或无论产生了多少对象，<span style="color:red">某些特定数据在内存里只有一份</span>。不归具体对象所有，没有必要每个对象一份

1. `static`可以用来修饰后：属性、方法、代码块、内部类，构造器不行

2. 使用`static`修饰属性：静态变量（它也修饰不了局部变量，所以只要修饰变量就是属性，所以就叫局部变量了）
   属性，按是否使用`static`修饰，有可以分为：类变量（静态属性） vs 实例变量 (非静态属性)
   实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性，彼此互相不干扰。随着对象的创建而加载。
   静态变量：我们创建了类的多个对象，多个对象共用那个同一个静态变量。随着类的加载而加载，早于对象的创建。可以通过`类.静态变量`的方式进行调用。
   由于类只加载一次，则静态变量也在内存中只存在一份：存在方法区的静态域中

   |      | 类变量 | 实例变量 |
   | ---- | ------ | -------- |
   | 类   | 可以   | 不可以   |
   | 对象 | 可以   | 可以     |

   `System.out`；`Math.PI`

3. 使用`static`修饰方法：静态方法
   3.1 随着类的加载而加载，可以通过`类.方法名来调用`
   3.2 能否调用的表同上
   3.3 静态方法中只能调用静态的方法和属性； 非静态方法中既可以调用非静态的方法也可以调用静态的方法

4.  `static`注意点：
   在静态的方法内，不能使用`this`关键字，`super`关键字

5. 属性和方法该不该用`static`修饰属性和方法的经验之谈：
   5.1 属性：可以被多个对象所共享的，不会随着对象的不同而不同的。类中的常量也常常声明为`static`
   5.2 方法：操作静态属性的方法，通常设置为`static`；工具类中的方法，习惯上声明为`static`。

#### 设计模式：单例模式Singleton

设计模式<span style="color:red;">是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式</span>，简称，套路

所谓单例模式，就是采取一定的方法保证在整个软件系统中，对某个类的智能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。

1. 将类的构造器私有化`private`
   在类的外部不能`new `该类的对象了，但是在类的内部还是可以造对象的
2. 调用该类的某个静态方法可以返回类内部创建的对象
3. 静态方法只能访问静态变量，所以只想类内部产生的该类对象的变量也必须是静态的 

如何实现？

```java
package com.atguigu.java1;
//饿汉式
public class SingletonTest1 {
	public static void main(String[] args) {
		Bank bank1 = Bank.getInstance();
		Bank bank2 = Bank.getInstance();
		
		System.out.println(bank1 == bank2);
	}

}

class Bank{
	
	//1. 私有化构造器
	private Bank() {
		
	}
	
	//2. 内部创建类的对象
	//4. 要求此对象也必须声明为静态的
	private static Bank instance = new Bank();
	
	//3. 提供公共的方法，返回类的对象
	public static Bank getInstance() {
		return instance;
	}
}

package com.atguigu.java1;
//懒汉式
public class SingletonTest1 {
	public static void main(String[] args) {
		Bank bank1 = Bank.getInstance();
		Bank bank2 = Bank.getInstance();
		
		System.out.println(bank1 == bank2);
	}

}

class Bank{
	
	//1. 私有化构造器/Users/chris/Downloads/SingletonTest2.java
	private Bank() {
		
	}
	
	//2. 只是声明对象的实例，不初始化
	//4. 要求此对象也必须声明为静态的
	private static Bank instance = null;
	
	//3. 提供公共的方法，返回类的对象
	public static Bank getInstance() {
    if(instance == null){
      instance = new Bank();
    }
		return instance;
	}
}
```

懒汉式和饿汉式的区分

饿汉式：坏处：对象加载时间过长
				好处：饿汉式式线程安全的

懒汉式：好处：延迟对象的创建。
				坏处：目前写法线程不安全 ==> 多线程的时候改成线程安全的写法

应用模式：

* 网站的计数器
* 应用程序的日志应用
* 数据库连接池
* 项目中，读取配置文件的类
* Application也是单例的典型应用
* Windows的Task Manager 和 Recycle Bin

#### `public static void main()`方法的语法

1. `main()`方法作为程序的入口，改名不行
2. `main()`方法也是一个普通的静态方法
3. `main()`也可以作为我们与控制台交互的方式。之前是用(`Scanner`) main方法获取到的形参都认为是String

#### 类的成员：代码块

```java
{
  //这就是代码块
  //就是一段大括号
  //功能上来说，就是初始化类或者是对象
  //如果要修饰，只能用static修饰
  
}
static{
  
}
```

1. 静态代码块
   内部可以用输出语句
   随着类的加载而执行，不能主动去调代码块的，一般都是自动调的。而且只执行一次
   作用：初始化类的信息/对静态变量
   如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行
   只能调用静态的属性和方法，不能调用非静态的结构
2. 非静态代码块
   内部可以用输出语句
   随着对象的创建而执行，而且每创建一个对象就执行一次。作用：可以在创建对象的时候对对象的属性进行初始化
   非静态代码块可以调用静态的属性、和方法，或非静态的属性和方法
3. 举例：虽然实际开发中使用频率不高
   总结一下：由父及子，静态先行；非静态代码块的执行在构造器之前
4. 跟显示初始化是平行的：具体看在代码层面谁出现在前面

#### 关键字：`final`

可以修饰的结构：类、方法、变量

* 类：`final class FinalA{}` 该类不能被其他的类继承
  * 如`String`，`System`，`StringBuffer`
* 方法：`public void final finalMethod(){}`
  * 如`java.lang.Object.getClass()`
* 变量：此时的"变量"就变成常量了
  * 属性：可以考虑赋值的有：显示初始化/代码块中；构造器中（如果要搞，就所有构造器都要搞）
  * 为什么用方法来赋值不靠谱？因为在方法是用对象来调用的，在构造器运行完了以后对象就已经出来了，这时候属性就应该有值了
  * 局部变量：方法内、形参。尤其是`final`形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。
* `static final`:修饰属性，全局常量； 修饰方法：不能重写的静态方法（少见）



### Day 15 OOP下

#### 每日一考

1. static 修饰的属性，相较于实例变量，有哪些特别之处(>=3点)
   随着类的加载而加载，可以通过类名来调用，所有类的的对象共用一份（内存中只有一份）

2. final 可以用来修饰哪些结构，分别表示什么意思
   类：不能被继承
   变量：初始化以后不能再赋值
   方法：不能被重写

3. 代码实现单例模式的饿汉式 

   ```java
   public class Singleton1{
     //1. 私有化构造器
     private Singleton1(){
       
     }
     //2. 该类的内部提供一个对象
     //4. 这个对象也得是静态的
     private static Singleton1 instance = new Singleton1();
     //3. 提供返回该对象的公共 方法（静态的）
     private static getInstance(){
       return instance;
     }
     
   }
   ```

   

4. 代码实现单例模式的懒汉式 -目前还是线程不安全的

   ```java
   public class Singleton1{
     //1. 私有化构造器
     private Singleton1(){
       
     }
     //2. 该类的内部提供一个对象
     //4. 这个对象也得是静态的
     private static Singleton1 instance = null;
     //3. 提供返回该对象的公共 方法（静态的）
     private static getInstance(){
       if(instance == null)
         instance = new Singleton1();
       return instance;
     }
     
   }
   ```

   

5. 类的属性赋值的位置有哪些？先后顺序为何？
   默认初始化 < 显示初始化/代码块 < 构造器 < 对象.属性 / 对象.方法

#### 抽象类与抽象方法

随着继承层次中一个个新子类的定义，类变得越来越具体，二父类则更一般，更通用。类的设计应该保证父类和子类的能够给共享特征。有时将一个父类设计的非常抽象，以至于它没有具体的实例，这样的类叫做<span style="color:red;">抽象类</span>。

* 用`abstract`关键词修饰类以后，该类不能造对象了
* 但是该类仍然有构造器。便于子类对象实例化时调用（涉及：子类对象实例化的全过程）
* 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作

抽象方法：`public abstract void eat();`用abstract 修饰方法，只有方法的声明，没有方法体。

* 包含抽象方法的类，一定是抽象类
  * 没有方法体就不应该被调用，但是如果能造对象，就有可能会被调用。反之，
* 抽象类中，可以没有抽象方法。
* 若子类重写了父类的所有抽象方法后，此子类方可实例化
  * 反过来说，若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要用`abstract`修饰 

`abstract`关键词注意点：

* 不能用来修饰：属性、构造器等结构
* 不能用来修饰私有方法、静态方法、final的方法、final的类

抽象类的匿名子类：

```java
package com.atguigu.java;

public class PersonTest {
	public static void main(String[] args) {
		method(new Student());
		
		Worker worker = new Worker();
		method1(worker);//非匿名的类非匿名的对象
		
		method1(new Worker());//非匿名的类匿名的对象
		
		//创建了一个匿名字类的对象：P
		Person p = new Person() {

			@Override
			public void eat() {
				System.out.println("eat something");
			}
			@Override
			public void breath() {
				System.out.println("Breath hardly");
			}};
			
//			method1(p);
			
			//还能更懒：匿名字类的匿名对象
			method1(new Person() {
				@Override
				public void eat() {
					System.out.println("eat something");
				}
				@Override
				public void breath() {
					System.out.println("Breath hardly");
				}
			});
	}
	public static void method1(Person p) {
		p.eat();
		p.breath();
	}
	public static void method(Student s) {
	}
}

class Worker extends Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}

	@Override
	public void breath() {
		// TODO Auto-generated method stub
	}
}

```



---

Here is June 3, 2021

多态的应用之：模版方法设计模式(TemplateMethod)

要解决的问题是，当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。

换句话说，<span style="color:red;">在软件开发中实现一个算法时，整体步骤很固定，通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模版模 式。</span>

回调(callback)方法钩子方法是开发中常用的手段，我们搞

#### 接口`Interface`

* 一方面，有时必须从几个类中派生出一个子类，继承他们所有的属性和方法。但是，Java不支持多重继承，有了接口就可以得到多重继承的效果。
* 另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有`is-a`的关系，仅仅是具有相同的行为特征而已。举例：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3、手机、数码相机、移动硬盘、等！USB
* 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要...则必须能..”的思想<span style="color:red;">继承是一个“是不是”的关系，而接口实现则是“能不能”的关系。</span>
* <span style="color:red;">接口的本质是契约，标准，规范</span>就像我们的法律一样，制定好以后，大家都要遵守。

接口使用`interface`关键字来定义，`interface`和`class`是两个并列的结构

* 如何定义接口：

  * `JDK7.0`及以前：只能定义全局常量和抽象方法
    * `public static final`的但是可以省略不写，不写人家也认为是`public static final`的
    * `public abstract`的方法，也可以省略`public abstract`
  * `JDK8.0`：除了全局常量和抽象方法以外，还可以定义静态方法、默认方法

* 接口中不能定义构造器，意味着接口不能实例化

* `Java`开发中，接口都通过类去实现(`implements`)

  * 如果实现类覆盖了接口中所有的抽象方法，则此实现类就可以实例化
  * 如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍然是抽象类

* Java类可以实现多个接口，多实现 ==> 弥补了`Java`单继承的局限性

  * 格式：`class AA extends BB implements CC, DD, EE{}`

* 接口与接口之间构成继承关系，而且可以多继承。  

* 接口的具体使用，体现多态性：抽象类和接口有什么异同？

  ```java
  //USB 是个接口
  class Computer {
    public void transferData(USB usb){
      usb.start();
      code();
      usb.stop();
    }
  }
  
  class USBTest{
    
    Computer com = new Computer();
    Flash flash = new Flash();
    com.transferData(flash);
  }
  ```

  

* 接口实际上可以看作是一种规范

* 开发中体会面向接口编程

再体会一下，接口的匿名实现类 

```java
com.transferData(new USB(){
  @Override
  public void start(){
    System.out.println("Anonymous USB device started working");
  }
  
  @Override
  public void stopped(){
    System.out.println("Anonymous USB device stopped working");
  }
  
});
```

体会后面慢慢体会，先多写代码。

**接口的应用：代理模式**

代理模式是`Java`开发中使用比较多的一种设计模式。代理设计就是为其他对象提供一种代理控制对这个对象的访问。 按说应该是被代理的对象自己去执行某些功能，但是在代码层面上只能看到代理类调用该方法。

代理还有静态代理和动态代理，动态代理跟反射有关系。

**接口的应用：工厂模式**

体会无工厂模式、简单工厂模式、工厂方法模式、抽象工厂模式，还是需要反射

工厂模式要把对象的创建和调用分开来，简单工厂和工厂方法模式都不能有效的必将改添加功能需要改代码的问题（开闭原则）

一道阴题：

```java
interface A{
  int x = 0;
}

class B {
  int x = 1;
}

class C extends B implements A{
  public void px(){
    //编译器报错，因为不知道是哪里的x
    System.out.println(x);
  }
  public static void main(String[] args){
    new C().px();
  }
}
```

`Java 8.0`接口的新特性：

 除了全局常量和抽象方法以外，还可以定义静态方法、默认方法

知识点1: 接口中的静态方法，只能用接口来调用

知识点2: 通过实现类的对象，可以调用接口中的默认方法 

知识点3:如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法（类优先原则）

知识点4:如果实现类实现了多个接口，而这个接口中定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，报错==> 接口冲突。解决办法：必须在实现类中重写此方法

知识点5:在实现类中调用接口中的默认方法`CompareA.super.method3();`

#### 类的成员：内部类

当一个事物的内部，还有一个部分需要一个完整的结构进行描述，二这个内部的完整的结构有职位外部事物提供服务，那么整个内部的完整结构最好使用内部类。

在`Java`中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类(`Inner class`)。

* 内部类的分类：成员内部类（静态、非静态） vs 局部内部类(方法内，代码块内，构造器内 )

* 成员内部类：

  * 一方面，作为成员：
    * 调用外部类的结构
    * 可以用`static` 修饰
    * 可以被四种不同的权限修饰符修饰
  * 另一方面，作为类：
    * 类的内部可以定义属性、方法、构造器
    * 可以被`final`修饰，表示此类不能被继承。言外之意，不使用`final`就可以被继承
    * 可以被`abstarct`修饰
  * 关注如下问题：
    * 如何实例化成员内部类的对象
    * 如何在成员内部类中区分调用外部类的结构

* 开发中局部内部类的使用

  ```java
  public class InnerClassTest{
    
    //开发中很少见
    public void method(){
      class AA{
        
      }
    }
    
    //返回一个实现了Comparable 接口的类的对象
    public Comparable getComparable(){
      
      //创建一个实现了Comparable 接口的类
      
      class Mycomparable implements Comparable{
        @Override
        public int comparaTo(Object o){
          return 0;
        }
      }
      
      return new MyComparable();
    }// getComparable()
  }//InnerClassTest
  ```

  

### Day 16 异常处理

#### 每日一考

1. `abstract`可以修饰那些结构？修饰以后，有什么特点？
   方法：没有方法体，子类必须重写，含有抽象方法的类必须是抽象类；继承的子类如果没有重写所有的抽象方法也必须是抽象类。只定义了一种功能的标准，具体的执行需要子类去实现。
   类：不能实例化，要想实例化必须由子类重写所有抽象方法；不一定含有抽象方法，但是含有抽象方法的必须是抽象类

2. 接口是否能继承接口？抽象类是否能实现(implements)接口？抽象类能否继承非抽象的类？
   可以，还可以多继承。可以。可以，没有直接说明父类的抽象类父类是`java.lang.Object`，那不就OK了吗

3. 声明抽象类，并包含抽象方法。测试类中创建一个继承抽象类的匿名子类的对象。

   ```java
   abstract class Employee{
     
     public abstract void Work();
     
   }
   
   public class EmployeeTest{
     
     public static void main(String[] args ){
       Employee aEmp = new Employee(){
         public void Work(){
         	System.out.println("Anonymous SubClass working"); 
         }
       };
     }
     
   }
   ```

   

4. 抽象类和接口有哪些共同点和区别？
   共同点：不能实例化，都可以被继承，
   区别：抽象类有构造器，接口不能声明构造器；接口可以多继承，类只能单继承；

5. 如何创建静态成员内部类和非静态成员内部类的对象？

   ```java
   class Peron{
     
     private static class StaticInner{
       
     }
     
     private class InstanceInner{
          
     }
     
   }
   
   public class PersonTest{
     
     public static void main(String[] args){
     //静态  
   	Person.StaticInner sin = new Person.StaticInner;
     //非静态
     Person p = new Person();
     Person.InstanceInner iin = p.new InstanceInner();
       
     }
   }
   ```

#### 异常处理概述

在使用计算机语言进行项目开发的过程中，既是程序员吧代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是考代码能够避免的，如：
<span style="color:blue;">用户输入数据格式、读取文件是否存在、网络是否始终保持通畅</span>等

在`Java`语言中，将程序执行中发生的不正常情况称为“异常”。那么，**什么不算异常？**：语法错误饿逻辑错误不是异常。Java程序在执行过程中所发生的异常事件可以分为两类：

* **Error**:JVM解决不了的重大问题，比如`StackOverflowError`，`OOM`
* **Exception**:其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理：例如：
  * `NullPointerException`
  * `ArrayIndexOutOfBountException`

#### 常见异常

```java
java.lang.Throwable
  	|----java.lang.Error:一般不编写针对性的代码进行处理。
    |----java.lang.Exception:可以进行异常的处理
      |-----编译时异常（checked）
      	|----IOException
      		|----FileNotFoundException
      	|----ClassNotFountException
      |-----运行时时异常（unchecked）
      	|----NullPointerException
      	|----ArrayIndexOutOfBountException
      	|----ClassCastException
      	|----NumberFormatException
      	|----InputMismatchException
      	|----ArithmaticException
```

#### 异常处理机制一 `try-catch-finally`

在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。过多的`if-else`分支会导致程序的代码加长、臃肿，可读性差，因此采用异常处理机制。

`Java`采用的异常处理机制，是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅、便于维护

**抓抛模型：**

1. “抛”：程序在正常执行过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。
   一旦抛出对象以后，其后的代码就不在执行。
2. “抓”：可以理解为异常处理的方式`try-catch-finally`：尝试把异常干掉；`throws`上报

```java
try{
  //可能出现异常的代码
}catch (异常类型1 变量名1){
  //处理异常的方式1
}catch (异常类型2 变量名2){
  //处理异常的方式2
}catch (异常类型3 变量名3){
  //处理异常的方式3
}finally{
  //可选的不是一定要写的
  //一定会执行的代码
}
```

* 使用`try`将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常的对象，根据此对象的类型，去`catch`中进行匹配
* 一旦`try`中的异常怼心啊哥匹配到某一个`catch`时，就进入`catch`中进行异常的处理。一旦处理完成，就跳出当前的`try-catch`结构（在没有写`finally`的情况下），继续执行其后的代码
* `catch`中的异常类型，如果没有子父类关系，声明的顺序无所谓。如果满足子父类关系，则要求子类一定声明在父类的上面，否则报错。
* 常用的异常对象处理的方式
  * `String getMessage()`
  * `void printStackTrace()`
* 在`try`结构中声明的变量在除了`try`以后就不能再调用

体会一个问题：使用`try-catch-finally`处理编译时异常，使得程序在编译时就不再报错，但是在运行时仍可能报错。相当于将一个编译时异常延迟到运行时出现

开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写`try-catch-finall`了。对于编译时异常，必须要处理

finally中声明的事一定会被执行的代码。既是`catch`中又出现异常了，`try`中有`return`语句，`catch`中有`return`语句等情况

像数据库连接， 输入输出流，网络编程`Socket`资源，JVM事不能自动回收的，我们需要自己手动进行资源的释放。此时的资源释放，就需要声明在`finally`中。

#### 异常处理机制二`throws`

1. `throws + Exceptioin`写在方法的声明处。指明执行此方式时，可能会抛出的异常类型。一旦方法体执行出现异常的时候，仍会在异常代码处出现一个异常类的对象，此对象满足`throws`后异常类的对象时，此对象就是会被抛出。异常后续的代码就不再执行
2. 体会`try-catch-finally`：真正的将异常处理掉了
   `throws`的方式只是把异常抛给了方法的调用者。并没有真正将异常处理掉

```java
package com.atguigu.java;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

import org.junit.Test;

public class ExceptionTest2 {

	public static void main(String[] args) {
		try {
			test2();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@Test
	public static void test2() throws FileNotFoundException, IOException {
		test1();
	}

	@Test
	public static void test1() throws FileNotFoundException, IOException {
		File file = new File("hello.txt");
		FileInputStream fis = new FileInputStream(file);

		int data = fis.read();
		while (data != -1) {
			System.out.println((char) data);
			data = fis.read();
		}
		fis.close();
	}
}

```



#### 手动抛出异常`throw`

异常对象的产生有两种方式：

1. 系统自动生成的异常对象
2. 手动的生成一个异常对象，并抛出：`throw`

#### 用户自定义异常类

三步走

1. 继承与现有的异常结构：`RuntimeException`，`Exception`
2. 提供全局常量：序列号`static final long seriesVersionUID = -12312341234 L`
3. 提供重载的构造器

---

Here is June 6

### Day 17 项目三

#### 小技巧

`p.getStatus().getNAME.equals("BUSY")`对比`"BUSY".equals(p.getStatus().getNAME())`后者更好，因为可以避免空指针异常

体会子父类的toString方法需要改变类名的时候，把基本信息抽象出来这个问题，期待用反射的方式更漂亮地去解决这个问题

到处体会cascade `if-else`的时候注意范围从小到大的过程，体会这两个的区别，前对后错

```java
Programmer p = (Programmer)e;
//正确写法：
if(p instanceof Architect){
  if(nArchitect >= 1){
    throw new TeamExcpetion("At most one architect in one team");
  }
}else if (p instanceof Designer){
  if(nDesigner >= 2){
    throw new TeamExcpetion("At most two designers in one team");
  }
}else if (p instanceof Programmer){
  if(nProgrammer >= 3){
    throw new TeamExcpetion("At most three programmers in one team");
  }
}

//错误写法
if(p instanceof Architect && nArchitect >= 1){
    throw new TeamExcpetion("At most one architect in one team");
}else if (p instanceof Designer && nDesigner >= 2){
    throw new TeamExcpetion("At most two designers in one team");
}else if (p instanceof Programmer && nProgrammer >= 3){
    throw new TeamExcpetion("At most three programmers in one team");
}

//反例：当Team中有两个Designer的时候，想要添加一个Architect的时候出bug
```



开发中还有一个判断数组是否为空的小技巧：

```java
Employee[] employees = NameListService.getAllEmployee();
if(employees == null || employees.length() ==0){
  //注意排查非空的情况，除非看过源码
}
```



要求：对着需求PPT自己敲一遍

---

Here is June 7, 2021

## Java高级编程 

Java语言的具体应用



### Day 18 IDEA的使用与多线程

#### 前情提要

June 8， 2021，项目3对着需求自己敲了一下，view没有敲，但是其他的两个类搞完了

#### IDEA Hello World

`psvm + enter`： 主函数

`sout + enter`： `System.out.println()`，也可以先写一个String literal 然后点出来这个结构

#### Module的理解

IDEA官网上说的，：
`Eclipse`中的`workspace`相当于IDEA中的`Project`

`Eclipse`中的`Project`相当于IDEA中的`Moduel`

一些不同点：

`Eclipse`的一个窗口可以管理很多个项目，但是IDEA是不行的，IDEA提供的解决方案是打开多个窗口，每个窗口可以搞不同的项目。

IDEA中Project是最顶级的级别，其次是Module。

如果要干掉一个Module 要先从Project里面剔除出来，然后再从文件系统中删除掉文件夹



#### 基本概念：程序、进程、线程

* 程序programm：是为完成特定任务、用某种语言编写的一组指令的集合，<span style="color:red;">一段静态的代码</span>，静态对象。
* 进程process：是程序的一次执行过程，或者是<span style="color:red;">内存中正在运行的一个程序</span>，是一个动态的过程。它有产生，存在，消亡的过程--声明周期。资源分配的单位，系统给不同的进程分配不同的内存空间。
* 线程thread：进程可以进一步细化称为线程，是一个程序内部的一条执行路径。
  如果一个进程同一时间并行执行多个线程，就是支持多线程的。
  <span style="color:red;">线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器PC</span>，线程切换开销比较小。多线程共享内存空间，所以存在线程安全问题

单核CPU和多核CPU：

* 单核CPU时代，多线程是假的，只是看似多线程，同时运行
* 真正的多核才能更好的发挥多线程的效率
* 一个Java应用程序`java.exe`至少有三个线程：主线程`main()`，垃圾回收线程`gc()`，异常处理线程
* 并行：多个CPU同时执行多个任务：多个人同时做不同的时parallel
* 并发：一个CPU采用时间片同时执行多个任务concurrence

多线程的优点：

单核CPU之使用单核线程先后完成多个任务，肯定比用多个线程来完成总用时更短，那么为什么要多线程？

1. 提高应用程序的响应，对图形化界面更有意义，可增祺那个用户体验。
2. 提高计算机系统CPU的使用率
3. 改善程序结构，将既长又复杂的进程氛围多个线程，独立运行，利于理解和修改

---

Here is June 8, 2021

#### 线程的创建和使用

**方式一：**继承`Thread`类

1. 创建一个继承于`Thread`类的子类
2. 重写`Thread`类的`run()`方法
3. 创建`Thread`类的子类的对象
4. 通过对象调用`start()`
   有两个作用：1. 启动当前线程； 2. 调用当前线程的`run()`

两个小问题：

问题一：如果我不调用`start()`，直接调`run()`发生什么？

```java
public class ThreadTest {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
      //这行干掉
      //t1.start();
      //改成run()
	      t1.run()
        for (int i = 0; i < 100; i++) {
            if( i % 2 == 0){
                System.out.println(i + "main()");
            }
        }
    }
}
/*
结果是会在主线程中执行Thread子类中的run方法，然后继续执行主线程中后面的语句，换言之，只有一个线程在做
*/
```

问题二：再启动一个线程，遍历100以内的偶数，能否再`start()`一次？
答案是不能，因为start以后状态不是0了，会报错，需要再创建一个对象来调

```java
//t1.start();
//上面这种调法会报错，正确做法是再创建一个对象
MyThread t2 = new MyThread();
t2.start();
```

**Thread 类的常用方法**

1. `start()`方法：启动当前线程，调用当前线程的`run()`
2. `run()`方法：通常需要重写Thread类中的次方法，将创建的线程要执行的操作声明在此方法中
3. `currentThread()`方法：是个静态方法，返回当前代码执行的线程
4. `getName()`：过去当前线程的名字
5. `setName()`：设置当前线程的名字
   也可以重写构造器，因为Thread()有一个构造器
6. `yield()`：释放当前cpu执行权
7. `join`：在线程a中，调用线程b的`join()`方法，此时线程`a`进入阻塞状态，直到线程`b`完全执行完之后线程`a`才结束阻塞状态
   ![线程join方法](/Users/chris/Coding Bootcamp/Notes/atguigu-notes/Backend/00. Java基础/a.join().png)
8. `stop()`：强制线程生命周期结束
9. `sleep(long millitime)`：让当前线程睡眠制定的millitime毫秒，在睡眠时间内，当前线程进入阻塞状态。
10. `isAlive()`：当前线程是否存活

**线程的优先级**

1. 常量`MAX_PRIORITY: 10`，`MIN_PRIORITY: 1`，`NORM_PRIORITY: 5`
2. 如何获取和设置当前线程的优先级：
   `getPriority()` vs `setPriority(int p)`
   高优先级的线程要抢占低优先级cpu的执行权，但只是从概率上来将的，高优先级的线程高高绿的情况下被执行。并不意味着只有高优先级的线程执行完以后，低优先级的线程才执行。

**方式二：**实现`Runnable`接口

1. 创建一个实现了`Runnable`接口的类
2. 实现类去实现`Runnable`中的抽象方法`run()`
3. 创建实现类的对象
4. 将此对象作为参数传递到`Thread`类的构造器中，创建Thread类的对象
5. 通过`Thread`类的对象调用`start()`

比较创建多线程的两种方式：由于`Java`单继承，如果继承Thread就不能继承别的类了，但是我们有时候它应该有自己的父类

开发中，优先选择实现`Ruannable`接口的方式，原因：

1. 实现的方式没有类的单继承性的限制

2. 实现的方式更适合来处理多个线程有共享数据的情况

   联系：Thread类也实现了Runnable。不管是继承的方式还是实现的方式都需要重写`run()`，将线程要执行的逻辑声明在`run()`中

---

Here is June 9, 2021

### Day 19 多线程

#### 每日一考

1. 谈谈你对程序、进程、线程的理解
   程序就是一段静态的指令的集合，通常是为了解决某些特定问题而产生的。进程是加载到内存当中的程序，是动态的，正在运行的。进程可以进一步细化成线程，一个线程代表一条执行路径，进程内部可以有多条线程，他们共享进程的内存空间。线程建切换也比较（相对于切换进程）轻便
   <span style="color:red;">每个线程拥有自己独立的栈和程序计数器</span>

2. 代码完成继承Thread的方式创建分线程，并遍历100以内的自然数

   ```java
   t1 = new Thread(){
     @Override
     public void run(){
       for(int i = 0; i < 100; i++){
         if(i % 2 == 0){
           System.out.println(getCurrentThread.getName() + ":" + i);
         }
       }
     }
   };
   t1.start();
   ```

   

3. 代码完成实现Runnable接口的方法创建分线程，并遍历100以内的自然数

   ```java
   r1 = new Ruannable(){
     public void run(){
       for(int i = 0; i < 100; i++){
         if(i % 2 == 0){
           System.out.println(getCurrentThread.getName() + ":" + i);
         }
       }
     }
   };
   t2 = new Thread(r1);
   t2.start();
   ```

   

4. 对比两种创建方式
   实现Runnable接口的方法具有一定的优越性，所以开发中通常使用这种方法。第一是对公共资源不需要使用static去修饰，只需要保证使用同一个Runnable接口实现类去造`Thread`类的对象即可。第二，也是更重要的一点，实现`Runnable`接口的方法不受到`Java`单继承类的影响；

5. 说说你对IDEA中Project和Module的理解
   IDEA中的Project相当于Eclipse中的Workspace
   IDEA中的Module相当于Eclipse中的Project
   就IDEA而言，Project是最低级的结构，再下来是是Module，Module相当于一个Java工程



#### 线程的声明周期

生命周期：从出生到消亡的整个过程

* **新建**：当一个Thread类或起子类的对象被声明并创建是，新生的线程对象处于新建状态
* **就绪**： 处于新建状态的线程被`start()`后，将进入线程队列等待CPU时间片，此时她已具备了运行的条件，只是没有分配到CPU资源
* **运行**：当就绪的线程被调度并获得CPU资源是，便进入运行状态`run()`方法定义了线程的操作和功能
* **阻塞**：再某种特殊情况下，被人挂起或执行输入输出操作时，让出CPU并临时终止自己的执行，进入阻塞状态
* **死亡**：线程完成了他的全部工作或线程被提前签执行的种植或出现异常导致结束  

![线程的生命周期](/Users/chris/Coding Bootcamp/Notes/atguigu-notes/Backend/00. Java基础/Thread_lifespan.png)

#### 线程的同步

1. 主要用来解决线程的安全问题，比如说卖票的程序有出现重票和错票的问题
2. 问题出现的原因是：当某个线程操作车票的过程中，其他线程参与进来，也操作车票；车票等同于共享数据
3. 如何解决：“进去以后加锁”，当一个线程操作共享数据的时候，其他线程不能参与进来，直到线程a操作完ticket的时候，才可以操作ticket。这种情况及时线程a出现了阻塞也不能被改变。

**在Java中是怎么做的？**

通过同步机制来解决线程的安全问题：

方式一：同步代码块，通过关键字`synchronized`

```java
synchronized (monitor){
  //需要被同步的代码 或者说
  //操作共享数据的代码
}
```

1. 什么是共享数据？多个线程共同操作的变量。比如：卖票问题中的ticket
2. `monitor`也叫**同步监视器**，俗称叫**锁**，任何一个类的对象都可以充当锁。
   要求：**多个线程必须要公用同一把锁**。

方式二：同步方法

如果操作共享数据的代码完整的生命在一个方法中，我们不妨将此方法声明为同步的。

 同步方法依然涉及到同步监视器，只是不需要我们显示的声明

非静态的同步方法，同步监视器是`this`；静态的同步方法，同步监视器是：当前类本身

```java
//实现Runnable的方法
class Window3 implements Runnable {
    private int ticket = 100;

    @Override
    public void run() {
        while (true) {
            show();
        }
    }

    private synchronized void show() {
        if (ticket > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + " sold ticket # " + ticket);
            ticket--;
        }
    }
}


```

```java
//继承Thread类的方式
class Window4 extends Thread {
    private static int ticket = 100;
//    private static Object obj = new Object();

    @Override
    public void run() {
        while (true) {
            show();
        }
    }

    private static synchronized void show() {//这才是对的因为同步监视器是Window4.class
//    private synchronized void show() {//此时是错误的，因为同步监视器是this,所以是t1,t2,t3，一个线程一把锁，不成
        if (ticket > 0) {
            System.out.println(Thread.currentThread().getName() + " sold ticket # " + ticket);
            ticket--;
        }
    }

}
```

5. 同步的方式，解决了新城安全的问题---这是个好处
   但是，操作同步代码是，只能有一个线程参与，其他线程等待，相当于是一个单线程过程，效率低。---这是个局限

6. 同步锁的简便方法就是用`this`，这是针对实现Runnable`接口的方式，因为从头到尾就只有一个Window的对象，如果用的是继承`Thread类的方式可以用`Window.class`来搞。这里说明了一件事：类也是对象，类只会加载一次，意味着就只有一份

   ```java
   public void run() {
     synchronized (Window2.class) {
       while (true) {
         if (ticket > 0) {
           System.out.println(Thread.currentThread().getName() +
                              " sold ticket # " + ticket);
           ticket--;
         } else {
           	break;
         }
       }
     }
       
   ```

**死锁DeadLock**

* 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
* 死锁状态出现以后，不会出现异常，也不会出现提示，只是所有的线程都处于阻塞状态，无法继续

从JDK5.0开始，Java提供了更强大的线程同步机制，通过显示定义同步锁对象来是想同步。同步锁使用`Lock`对象来充当。

* `java.util.concurrent.locks.Lock`接口是控制多个线程对共享资源进行访问的工具。
* `ReentrantLock`类实现了`Lock`接口，具有与`synchronized`相同的并发行和内存语义。
  * 构造器接受一个`boolean`型的参数，`fair`，默认是`false`，如果设置成`true`，会有先到先得的特性
* `ReentrantLock`和`synchronized`有什么异同？
  * 相同：两者都可以解决线程安全问题
  * 不同：`synchronized`机制在执行完相应的同步代码以后，自动的释放同步监视器，`Lock`需要手动的启动`lock()`，同时也需要手动释放`unlock()`。
* 建议顺序：`Lock ==> 同步代码块 ==> 同步方法` 

#### 线程的通信

**例子：两个线程交替打印1-100** 

```java
class Number implements Runnable{
    private int number = 1;

    @Override
    public void run() {
        while(true)
        {
            synchronized (this) {
                notify();
                if(number < 100){
                    System.out.println(Thread.currentThread().getName()
                                       + " : " + number);
                    number++;
                    try {
                        wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }else{break;}
            }
        }
    }
}
public class CommunicationTest {
    public static void main(String[] args) {
        Number number = new Number();
        Thread t1 = new Thread(number);
        Thread t2 = new Thread(number);

        t1.setName("Number-1:");
        t2.setName("Number-2:");

        t1.start();
        t2.start();

    }
}
```

涉及到的方法：

1. `wait() `：一旦执行此方法，当前线程就会进入阻塞状态，并释放同步监视器
2. `notify()`：一旦执行此方法，就会唤醒被`wait()`的一个进程，如果有多个被`wait`的进程就唤醒优先级高的那个
3. `notifyAll()`：一旦执行此方法，就会唤醒所有被`wait()`的线程

**说明：**

1. 这三个方法必须使用在同步代码块或同步方法中。
2. 这三个方法的<span style='color:red;'>调用者必须是同步代码块或同步方法中的同步监视器</span>，否则会出现`IllegalMonitorSateException`
3. 这三个方法都定义在`java.lang.Object`类中

**面试题：**`sleep()`方法和`wait()`方法的异同

* 相同点：一旦执行，都可以使得当前的线程进入阻塞状态。
* 不同点：
  * 两个方法声明的位置不同：`sleep()`在`Thread`类中，`wait()`声明在`java.lang.Object`类中
  * 调用的要求不同：`sleep()`可以在任何需要的情景下调用，`wait()`必须在同步代码块或同步方法中
  * 是否释放同步监视器的问题：如果两个方法都在同步方法或同步代码块中，`sleep()`不会释放同步监视器，但是`wait()`会

**经典例题**：生产者/消费者问题

问题描述：生产者`Productor`将产品交给店员`Clerk`，而消费者`Customer`从店员处取走产品，店员一次只能持有规定数量的产品比如`20`，如果生产者试图生产更多的产品，店员会叫生产者停一下，如果点钟有空位放产品了再通知生产这继续生产；如果店中没有产品了，店员会告诉消费者等一下  

#### JDK5.0新增线程创建方式

新增方式一： `Callable`接口

`Callable`功能更强大些，体现在：

* 相比`run()`方法，`call()`方法可以有返回值
* `call()`方法可以抛出异常
* 支持泛型的返回值
* 需要借助 `FutureTast`类，比如获取返回结果

1. 创建一个实现`Callable`接口的实现类
2. 实现`call`方法，将此线程需要你执行的操作声明在`call()`中
3. 创建`Callable`接口实现类的对象
4. 将此接口的实现类的对象作为实参，传递到`FutureTask`构造器中，创建`FutureTask`的对象
5. 将`FutureTast`的对象作为参数传递到`Thread`类的构造器中，创建`Thread`对象，并调用`start()`
6. 如果对结果感兴趣，获取`Callable`中`call()`方法的返回值

新增方式二：线程池

实际开发中，很少会手造线程，而是使用线程池的方式。

* 背景：经常创建和销毁、使用两特别大的资源，比如高并发情况下的线程对性能影响很大。
* 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用。类似生活中的公共交通工具。
* 好处：
  * 提高响应速度（减少了创建新线程的时间）
  * 降低资源消耗（重复利用线程池中的线程，不需要每次都创建）
  * 便于线程管理：
    * `corePoolSize`：核心池的大小
    * `maximumPoolSize`：最大线程数
    * `keepAliveTime`：建成没有任务时最多保持多久后会被终止

**怎么搞？代码实现**

`ExecutoerService`和`Executors`。真正的接口和工具类

       1. 提供制定线程数量的线程池
          `ExecutorService service = Executors.newFixedThreadPool(10);`
       2. 执行指定线程的操作。需要提供实现`Runnable` 或`Callable`接口的实现类的对象

---

**June 10， 2021**

### Day 20 常用类

#### 每日一考

1. 画图说明线程的生命周期，以及各状态切换使用到的方法等
   状态，方法

2. 同步代码块中涉及到同步监视器和共享数据，谈谈你对同步监视器和共享数据的理解，以及注意点。
   同步代码块是一种`Java`提供的解决线程安全问题的同步机制，涉及到的同步监视器充当的角色就是同步锁，可以由任何一个类的对象来充当，但需要确保锁只有一把，也即不同线程使用同一个对象。共享数据指的是多个线程可以同时访问的数据，对共享数据的操作应该被包在同步代码块中。

3. `sleep()`和`wait()`的区别
   声明的位置不一样，`sleep()`是在`Thread()`类中声明的，`wait()`则是在`java.lang.Object`中声明的结构
   虽然都会让当前线程进入阻塞状态，但是`sleep()`不会释放同步锁，但是`wait()`在阻塞前会释放同步锁。
   <span style="color:red;">调用的要求不同：`sleep()`可以在任何需要的情景下调用，`wait()`必须在同步代码块或同步方法中</span>

4. 写一个线程安全的懒汉式

   ```java
   class Bank{
     
     private static Bank instance = null;
     
     private Bank(){
       
     }
     
     public static Bank getInstance(){
       if(instance == null){
         synchronized (Bank.class){
           if(instance == null){
             instance = new Bank();
           }
         }
       }
       return instance;
     }
   }
   ```

   

5. 创建多线程有哪几种方式
   4种：
   JDK5.0以前有两种：继承`Thread()`类和实现`Runnable`接口

   JDK5.0新增了两种：实现`Callable`接口和线程池

#### 字符串相关的类

`String`：

1. `Java`程序的所有字符串字面值都作为此类的实例实现，是一个`final`类表示不可被继承。
2. 字符串是常量，用双引号引起来表示，它们的值在创建以后不能更改。
   体现1：当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值
   体现2：当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使  用原有的value进行赋值
   体现2：当调用`Sting`的`replace()`方法修改指定的字符或字符串时，也需要重新指定内存区域赋值，不能使  用原有的value进行赋值
3. `String`对象的字符内容是存储在一个字符数组`value[]`中的
4. `String`实现了`Serializable`接口，具体到IO流的时候再说。还实现了`Comparable`接口表示`String`可以比较大小。 

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];

    /** Cache the hash code for the string */
    private int hash; // Default to 0

    /** use serialVersionUID from JDK 1.0.2 for interoperability */
    private static final long serialVersionUID = -6849794470754667710L;

    /**
     * Class String is special cased within the Serialization Stream Protocol.
     *
     * A String instance is written into an ObjectOutputStream according to
     * <a href="{@docRoot}/../platform/serialization/spec/output.html">
     * Object Serialization Specification, Section 6.2, "Stream Elements"</a>
     */
    private static final ObjectStreamField[] serialPersistentFields =
        new ObjectStreamField[0]; 
```

5. 通过字面量方式（区别于`new`）的方式给字符串复制，此时的字符串值声明在字符串常量池中；
6. 在字符串常量池中不会储存相同内容的字符串的

**两种`String`实例化方式的对比**

方式一：通过字面量`String s1 = "abc";`

方式二：通过构造器`String s1 = new String("abc");`

```java
public void test2(){
    //此时的s1和s2的数据都在方法区的字符串常量池中
    String s1 = "JavaEE";
    String s2 = "JavaEE";

    //构造器的方式，此时的s3，s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值:
    String s3 = new String("JavaEE");
    String s4 = new String("JavaEE");

    System.out.println(s1 == s2);//true
    System.out.println(s1 == s3);//false
    System.out.println(s1 == s4);//false
    System.out.println(s3 == s4);//false

}
```

**两种拼接操作的对比**

```java
/*
结论：常量与常量的拼接结果在常量池中，且常量池中不会存在内容相同的常量
		 只要其中有一个是变量，结果就在堆中
		 如果拼接的结果调用inter()方法，返回值就在常量池中

*/
    public void test3(){
        String s1 = "javaEE";
        String s2 = "hadoop";

        String s3 = "javaEEhadoop";
        String s4 = "javaEE" + "hadoop";
        String s5 = s1 + "hadoop";
        String s6 = "javaEE" + s2;
        String s7 = s1 + s2;

        System.out.println(s3 == s4);//true
        System.out.println(s3 == s5);//false
        System.out.println(s3 == s6);//fasle
        System.out.println(s3 == s7);//fasle
        System.out.println(s5 == s6);//fasle
        System.out.println(s5 == s7);//fasle
      
	      String s8 = s5.intern();
      
      	Sysout.out.println(s3 == s8);//true
    }
```

**字符串常用方法**

第一波：非常常用，要记忆，开发中，拿起来就能写的程度

1. `int length()`：返回字符串的长度，`return value.length`
2. `char charAt(int index)`：返回某索引处的字符`return value[index]`
3. `boolean isEmpty()`：判断是否是空字符串，`return  value.length == 0`
4. `String toLowerCase()`：返回调用函数的字符串中所有字符为小写的字符串，调用的字符串本身不变
5. `String toUpperCase()`：返回调用函数的字符串中所有字符为大写的字符串，调用的字符串本身不变
6. `String trim()`：删除leanding 前导和 trailing 尾部空白
7. `boolean equals(Object object)`：比较内容，因为重写过了
8. `boolean equaalsIgnoreCase(String anotherString)`：与`equals()`类似，忽略大小写
9. `String concat(String str)`：将制定字符串链接到次字符串的结尾，等价于`+`
10. `int compareTo(String anotherString)`：比较两个字符串的大小
    直接挨个儿比，不一样就减一下，涉及到字符串排序
11. `String substring(int beginIndex)`：取子字符串从`beginIndex`开始
12. `String substring(int beginIndex, int endIndex)`：前包后不包，左闭右开

第二波：也搞一下

1. `boolean endsWith(String suffix)`：测试此字符串是否是以指定后缀结束的
2. `boolean startsWith(String prefix)`：测试此字符串是否是以指定前缀开始
3. `boolean startsWith(String prefix, int toffset)`：测试此字符串从指定索引开始的子字符串是否是以指定前缀开始

第三波：没啥技术含量，搞一下

1. `contains(CharSequence s)`：CharSequence是个接口，String实现了这个接口，所以放个字符串就完全可以。作用为，当且仅当此字符串包含制定的`char`值序列是，返回true
2. `int indexOf(String str)`：返回指定字符串在此字符串中第一次出现处的索引，如果返回`-1`认为没找到
3. `int indexOf(String, int fromIndex)`：返回指定子字符串在此字符串中第一次出现处的索引，如果返回`-1`认为没找到
4. `int lastIndexOf(String str)`：从后往前去找，找到以后，返回值还是从前往后的，也即左边第一个是0
5. `int lastIndexOf(String str, int fromIndex)`：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。跟上面一对儿是`indexOf(String str)`和`indexOf(String str, int fromIndex)`是对称的

小问题：什么情况下`indexOf(str)`和`lastIndexOf(str)`返回值相同？
情况一，存在唯一的`str`；情况二，不存在

第四波：关于替换、匹配、切片

1. `String replace(char oldChar, char newChar)`：将`oldChar`的字符替换成`newChar`

2. `String replace(charSequence target, charSequence replacement)`：使用指定的字面值替换序列

3. `String replace(String regex, String replacement)`：使用给定的`replacement`替换此字符串中所有匹配给定的正则表达式的子字符串

4. `String replaceFirst(String regex, String replacement)`：使用给定的`replacement`替换此字符串中第一个匹配给定的正则表达式的子字符串

5. `boolean matches(String regex)`：告知此字符串是否匹配给定的正则表达式。

   ```java
   str = "12345";
   boolean matches = str.matches("\\d+");//全是数字
   System.out.println(matches);
   String tel = "0571-4534289";
   boolean isPhoneNumber = tel.matches("0571-\\d{7,8}");
   System.out.println(isPhoneNumber);
   ```

6. `String[] split(String regex)`：根据正则表达式的匹配拆分此字符串

7. `String[] split(String regex, int limit)`：根据正则表达式的匹配拆分此字符串，最多不超过`limit`个

---

Here is June 16, 2021

**`String`与`char[]`之间的转换**

```java
@Test
public void test(){
  String str1 = "abc123";
  char[] charArray = str1.toCharArray();
  
  String str2 = new String(charArray);
}
```

**`String`与`byte[]`之间的转换**

```java
@Test
public void test(){
  String str1 = "abc123";
  byte[] bytes = str1.getBytes();//使用默认的字符集，进行编码
  
  String str2 = new String(charArray);
}
```

编码(encoding)：字符串 ---> 字节（二进制数组）

解码(decoding)： 字节（二进制数组）--->字符串

要求：编码时与解码时所使用的字符集要一致！包括以后，从浏览器到后台再到数据库编码集必须都是一致的

几道关于`String`的测试题：

```java
/*
* 	1. 模拟一个trim方法，去除字符串两端的空格。
*/

/*
* 	2. 将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg”
*/

/*
* 	3. 获取一个字符串在另一个字符串中出现的次数。
* 	比如:获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数
*/

/*
* 	4. 获取两个字符串中最大相同子串。比如:
* 	str1 = "abcwerthelloyuiodef“;str2 = "cvhellobnm"
* 	提示:将短的那个串进行长度依次递减的子串与较长的串比较。
*/

/*
* 	5. 对字符串中字符进行自然顺序排序。
* 	str1 = "abcwerthelloyuiodef“;str2 = "cvhellobnm"
* 	提示:
* 	1)字符串变成字符数组。
* 	2)对数组排序，选择，冒泡，Arrays.sort();
* 	3)将排序后的数组变成字符串。
*/
```



**`StringBuffer`和`StringBuilder`**

1. `String`，`StringBuffer`和`StringBuilder`的异同：
   `String`：JDK1.0就有，不可变的字符序列；底层使用`char[]`进行存储
   `StringBuffer`：JDK1.0就有，可变的字符序列，线程安全，效率低；底层使用`char[]`进行存储
   `StringBuilder`：JDK1.5新增，线程不安全的，效率高；底层使用`char[]`进行存储

2. 源码分析：

   ```java
   String str = new String();
   //底层是建造了一个
   char[] value = new char[0];
   
   /****************/
   
   String str1 = new String("abc");
   //底层是建造了一个
   char[] value = new char[]{'a','b','c'}
   
   /****************/
   
   StringBuffer sb1 = new StringBuffer();
   //底层是建造了一个
   char[] value = new char[16];
   sb1.append('a');//value[0] = 'a';
   
   StringBuffer sb2 = new StringBuffer(str);
   //底层是建造了一个
   char[] value = new char[str.length + 16];
   
   System.out.println(sb2.length());//3
   ```

   扩容问题：如果添加的数据底层数据存不下了，那就需要扩容底层的数组
   默认情况下，扩容为原来容量的2倍+2（value.length<<2 + 2），同时将原有数组中的元素复制到新数组中
   开发中建议使用`StringBuffer(int)`这个构造器，避免扩容

3. `StringBuffer`和`StringBuilder`的常用方法
   `StringBuffer append()`：提供了很多的`append()`方法，用于进行字符串拼接
   `StringBuffer delete(int start, int edn)`：删除指定位置的内容
   `StringBuffer replace(int start, int end, String str)`：把`[start,end)`位置替换为`str`
   `StringBuffer insert(int offset, xxx);`在指定位置插入`xxx`
   `StringBuffer reverse();`把当前字符序列逆转
   `public int indexOf(String str);`：
   `public String substring(int start, int end);`
   `public int length();`
   `public char charAt(int n);`
   `public void setCharAt(int n, char ch);`

4. 对比三者的效率从高到低是：`StringBuilder` > `StringBuffer`  > `String`

#### `JDK8`之前的日期时间API

1. `long time = System.currentTimeMillis()`：返回当前时间与1970年1月1日0时0分0秒之间的时间差，以毫秒为单位，通常称为时间戳`timestamp`

2. `java.util.Date`类
   2.1 两个构造器的使用
   `new Date();`：创建了一个当前时间对应的对象
   `new Date(long date)；`：创建了一个指定时间的对象，很多都过时了`Deprecated`比如指定年月日的

   2.2 两个方法的使用
   `toString()`：显示当前对象代表的，年、月、日、时、分、秒
   `getTime()`：获取当前`Date`对象对应的时间戳（毫秒数，距1970年1月1日0时0分0秒）

3. `java.sql.Date`类，是`java.util.Date`的子类，对应着数据库中的日期类型的变量
   3.1构造器：`new java.sql.Date(long date);`
   3.2方法：`toString();`只打印了年月日；
   3.3 将`java.util.Date`转化成`java.sql.Date`对象
   `java.sql.Date date2 = new java.sql.Date(date1.getTime());`

---

Here is June 18, 2021

### Day 21 常用类

整合已经已经会了的东西是需要时间积累的，逻辑能力

```java
package com.atguigu.java;

import org.junit.Test;

public class IDEADebugTest {
    @Test
    public void StringBufferTest(){
        String str = null;
        StringBuffer sb = new StringBuffer();

        sb.append(str);
        System.out.println(sb.length());//4
        System.out.println(sb);// "null"

        StringBuffer sb1 = new StringBuffer(str);// Exception
        System.out.println(sb1);

    }
}
```

#### `java.text.SimpleDateFormat`

1. 两个操作
   1.1 格式化：日期 --> 字符串
   1.2 解析：字符串 --> 日期，格式化的逆过程

2. Instanticate SimpleDateFormat
   使用默认构造器就是固定格式，使用指定构造器`new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); `

3. 三天打鱼两天晒网的问题
   解决思路：先计算出来总天数`n`，然后`n % 5 == 1,2,3`打鱼，`n % 5 == 4, 0;`晒网
   总天数的计算有两种思路：
   一、先都转化成时间戳，然后毫秒数转化成天数

   二、分段，先到年底，然后算整年，然后再算年初到现在

#### `java.util.Calendar`

1. 实例化
   `Calendar`是一个抽象类，所以不能直接造对象，提供了一个子类`GregorianCalendar`的对象和`getInstance()`方法，但是实质上是一样的
2. 常用方法
   `int days = calendar.get(Calendar.DAY_OF_MONTH)`
   `set()`
   `add()`
   `getTime()`
   `setTime()`
3. 注意一个事情：
   获取月份时：一月是0，12月是11
   获取星期时：周日时1，周六是7

---

Here is June 19, 2021

#### `JDK8`新增的日期时间API

`JDK 1.1 `推出`Calendar`以后，大部分的`Date`方法就Deprecated了，然而，`Calendar`类本身还是存在许多问题，比如可变性、偏移量  等等。这些问题在`JDK 8`新增的日期时间API中得到了比较好的解决



1. `LocalDate`、`LocalTime`、`LocalDateTime`的使用,其中`LocalDateTime`使用频率高于其他两种
   1.1 实例化：`now()`，`of()`
   1.2获取属性：`getXXX()`
   1.3设置属性：`withXXX()`
   1.4加减操作：`plusXXX()`、`minuseXXX()`
   注意不可变性

2. `instant`瞬时：时间线上的一个瞬间点，这可能被用来记录应用程序中的时间时间戳
   面向机器的通用模型，`UNIX`中以1970年开始以秒为单位，`Java`中也是从1970年开始，以毫秒为单位
   `java.time`通过值类型`Instant`提供机其视图，不提供处理人类意义上的时间单位。基于纳秒计算
   $$
   10^{-9}
   $$
   2.1 实例化：`Instant instance = Instant.now()`，注意是本初子午线上的时间，北京在东八区，需要做处理
   `OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));`

3. `java.time.format.DateTimeFormatter`：格式化或解析日期、时间
   方式一：与定义的标准格式如，`ISO_LOCAL_DATE_TIME`,`ISO_LOCAL_DATE`,`ISO_LOCAL_TIME`
   方式二：本地化相关的格式，`ofLocaltizedDateTime()`
   方式三：自定义格式如，`ofPattern("yyyy-MM-dd hh:mm:ss E")`

4. 其他API
   持续时间：`Duration`，日期差异`Period`

#### Java比较器`Comparable`接口和`Comparator`

Java中的对象，正常情况下，只能进行`==`或`!=`，不能使用`<`或`>`，但是在实际开发中，我们需要对多个对象进行排序。也就是说，我们需要比较对象的大小。办法就是使用`Comparable`接口和`Comparator`接口

1. `String`和Wrapper Class等实现了`Comparable`接口，重写了`compareTo(obj)`方法，给出了比较两个对象大小的规则
2.  `String`和Wrapper Class 重写compareTo以后，进行了从小到大的排序    
3. 重写`comparaTo(obj)`的规则：
   如果当前对象`this`小于形参对象`ojb`，则返回正整数；
   如果当前对象`this`大于形参对象`ojb`，则返回负整数；
   如果当前对象`this`等于形参对象`ojb`，则返回0；
4. 当元素的类型没有实现`java.lang.Comparable`接口，而又不方便修改代码，比如JDK中的代码，或者实现了`java.lang.Comparable`接口的排序规则不适合当前的操作，那么可以考虑使用`Comparator`来实现
5. 两个的主要区别：`Comparable`接口的方式一旦指定，保证`Comparable`接口实现类的对象在任何位置都可以比较大小，`Comparator`接口属于临时性的比较

#### System类

1. 代表系统，系统级的很多属性和控制方法都放置在该类的内部，该类位于`java.lang`包下
2. 构造器是`private`的，也就是无法实例化该类，但是内部成员变量和许多方法都是静态的
3. 典型的三个属性`System.in`，`System.out`，`System.err`
4. 成员方法`currentTimeMillis()`
   `void exit(int status)`：退出程序，其中status为0代表正常退出，非零代表异常退出
   `void gc()`：该方法是请求系统进行垃圾回收，至于系统是否立即挥手，则取决于系统中垃圾回收算法的实现及系统执行时的情况
5. `String getProperty(String key)`：该方法的作用是获得系统中名为key的属性对应的值如
   `java.version`、`java.home`、`os.name`、`os.version`、`user.name`、`user.home`、`user.dir`

#### Math类

提供一系列静态方法，用于科学计算，参数和返回值类型一般为double型

#### BigInteger和BigDecimal

`Integer`包叕昂`int`最大到，2的31次方-1，`Long`包装`long `最大到，2的63次方-1
`BigInteger`可以表示不可变的，任意精度的整形

`BigDecimal`，在科学计算或工程计算，商业计算中，对精度要求很高的时候用`BigDecimal`

除法的时候要指定精度

---

Here is June 20, 2021

### Day 22 枚举类和注解

#### 每日一考

1. 将字符串”2017-08-16”转换为对应的java.sql.Date类的对象。（使用JDK8之前或JDK8中的API皆可）

   ```java
   SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
   java.sql.Date Date1 = sdf.parse("2017-08-16");
   ```

   造对象的方法`new` + 构造器
   单例、`Calendar.getInstance()`

2. 解释何为编码？解码？ 何为日期时间的格式化？解析？
   编码：就是人能看懂的字符串  ==> 机器能看懂的二进制码序列
   解码：编码的逆过程，二进制码 ===> 字符串
   格式化：日期时间对象 ===> 字符串
   解析：格式化的逆过程，字符串 ===> 日期时间的对象

3. 自定义Person类如下，如何实现自然排序（按姓名从小到大排序）

   ```java
   class Person {
     private String name;
     private int age;
     
   }
   ```

   

4. 提供定制排序涉及到的接口的实现类对象，并按Person类的年龄从大到小排序

   ```java
   ```

5. JDK 8之前和JDK8中日期、时间相关的类分别有哪些？

这部分不太扎实，不过不管了

枚举类和注解都是`JDK 5.0`新增的，可以认为是新特性

#### 枚举类

1. 自定义美剧类
   类的对象只是有限个，确定的，比如：
   星期、性别、季节、支付方式、就职状态、订单状态、线程状态
   当需要定义一组常量时，强烈建议使用枚举类

2. 使用关键字`enum`定义枚举类
   当枚举类中只有一个对象的时候，就可以作为单例模式的实现方式，jdk5.0以前，只能自定义枚举类，之后则可以使用`enum`关键字来定义

   ```java
   enum Season1{
       //1. 提供当前枚举类的多个对象,多个对象之间用逗号隔开，末尾对象用分号结束
       SPRING("Spring", "Spring is short"),
       SUMMER("SUMMER", "SUMMER tiem sadness"),
       AUTUMN("AUTUMN", "FALL is beautiful"),
       WINTER("WINTER", "Winter is coming");
   
       //2. 声明Season 对象的属性
       private final String seasonName;
       private final String seasonDesc;
   
       //3. 私有化类构造器
       private Season1(String seasonName, String seasonDesc){
           this.seasonDesc = seasonDesc;
           this.seasonName = seasonName;
       }
   
       //5. 获取枚举类对象的属性
   
       public String getSeasonName() {
           return seasonName;
       }
   
       public String getSeasonDesc() {
           return seasonDesc;
       }
   }
   ```

   

3. `Enum`类的主要方法
   `toString()`：没有重写的情况下写的就是对性的名称
   `values()`：当前枚举类有几对象/常量,举例，`Thread.State[] states = Thread.State.values();`
   `valueOf(String objName)`：返回枚举类中对象名是`objName`的对象，如果没有`objName`的枚举类对象，则抛异常

4. 实现接口的枚举类

#### 注解(Annotation)

1. Annotation概述
   JDK5.0增加了对元数据的支持，也就是注解。注解就是代码里的特殊标记，可以在编译，类加载。运行时被读取，并执行相应的处理。
   程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息，代码分析工具，开发工具，和部署工具可以通过这些补充信息进行验证或者部署
   Annotation可以像修饰符一样被使用，可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息被保存在Annotation的name=value中
   未来开发的时候注解的作用就非常明显了，比如`JPA`就是基于注解的。
   
   框架 = 注解 + 反射 + 设计模式
   
2. 常见的Annotation示例
   一：文档注释中的注解
   二：在编译是进行格式检查，JDK中原生的三个注解
   `@Deprecated`：过时了，不推荐使用，但是能用。要兼容以前开发的代码
   `@Override`：只能用来形容方法
   `@SurpressWarnings`
   三：框架中，用于跟踪代码依赖性，实现替代配置文件功能
   servlet是一个接口，开发中需要提供该接口的实现类

3. 自定义Annotation(自定义的情况比较少，一般是用别人定义好的)
   参照`SurpressWarning`注意`@interface`跟`interface`没有任何关系

   成员变量以无参数方法的形式来声明。方法名和返回值定义了该成员的名字和类型
   内部定义成员变量，通常使用`value`表示；可以指定成员的默认值，使用`default`定义
   如果自定义注解没有成员，就叫一个标记表明是一个标识作用
   如果注解有成员，在使用注解是，需要指明成员的值

---

Here is June 24, 2021

4. JDK中的元注解：对现有注解进行解释说明的注解，meta-annotation
   JJDK的元注解，用于修饰其他Annotation定义，JDK提供了4个标准的meta-annotation。
   `Retention`；指定所修饰的Anotation的生命周期：`SOURCE`\`CLASS`（默认行为）\`RUNTIME`，只有声明为`RUNTIME`生命周期的注解才能通过反射获取`Target`：用于修饰Annotation的定义，指明被修饰的Annotation能用于修饰那些程序元素
   
   我们如果自定义注解一般来说会定义`Retention`和`Target`，剩下两种稍微不常用一些。
   `Documented`： 用于指定元注解将会被`javadoc`解析时保留
   `Inherited`：被它修饰的Annotation将具有继承性
   元数据的理解：`String name = "atguigu";`，数据就是`atguigu`，而前面的`String`和`name`就可以看作是对`"atguigu"`的修饰
   
5. 利用反射获取注解信息

   ```java
   @Test
       public void testGetAnnotation(){
           Class clazz = Student.class;
           Annotation[] annotations = clazz.getAnnotations();
           for (int i = 0; i < annotations.length; i++) {
               System.out.println(annotations[i]);
           }
       }
   ```

6. JDK8中注解的新特性
   可重复注解、类型注解

### Day 23 集合

#### 每日一考

1. 什么是枚举类？枚举类的对象的修饰符又哪些？
   类的对象的个数是确定的，有限的，比如季节，线程生命周期状态等
   `public static final`
2. 什么是元注解？说说`Retention`和 `Target`元注解的作用
   解释说明其它注解的注解称为元注解，JDK中提供了4个元注解，比较常用的两个是`Retention`用来指明注解的生命周期，SOURCE、CLASS、RUNTIME，只有RUNTIME可以被反射获取
   `Target`修饰注解可以修饰的对象，比如方法，类，属性，构造器，局部变量等
3. 说说你所理解的集合框架都有哪些接口，存储数据的特点是什么
   Collection 和 Map，存储的是分别是单列数据和双列数据（键值对）。Collection又可以分为List和Set分别存储有序可重复和无序不可重复的元素
4. `throw`和 `throws`的异同
   `throw`是手动生成异常对象并抛出，写在方法内部 <--> 自动抛出异常
   `throws`用在方法声明中，是一种异常处理机制， <--> try-catch-finally
5. 谈谈你对同步代码块中同步监视器和共享数据的理解及各自要求
   同步监视器：俗称锁。任何一个类的对象都可以充当，多个线程必须公用同一把锁。
   共享数据：多个线程都要操作的数据就是共享数据，需要使用同步机制把共享数据包起来，不能包多了也不能包少了。

#### Java集合框架概述

数组和集合都是对多个对象进行存储的方式

1. 集合、数组都是对多个数据进行存储操作的结构，简称Java容器
   此时的存储都是内存层面的，不涉及到持久化层米那个的存储
2. 2.1 数组在存储多个数据方面的特点
    一旦初始化以后，其长度就确定了
   数组一旦定义好，其元素的类型也就确定了，我们也就只能操作指定类型的数据了。
   2.2 数组在存储多个数据方面的缺点：
    一旦初始化以后，长度就不能修改了
   数组中提供的方法非常有限，对于添加、删除、插入数据等操纵，非常不便，效率不高。
   获取数组中实际元素的个数的需求，数组没有现成的属性和方法可用
   数组是连续存储的特点：有序、可重复。对于无序、不可重复的需求，不能满足

Java集合可分为Collection 和 Map两种体系
Collection 接口：单列数据，定义了存取一组对象的方法的集合
List:元素有序、可重复的集合

Set:元素无序、不可重复的集合
Map 接口：双列数据，保存具有映射关系`key-value`对的集合

```Java
/* 
|----Collection 接口
		|----List 接口： 有序的可重复的、动态数组
			|----ArrayList、LinkedList、Vectoe
    |----Set 接口：无序的、不可重复的数据，数学中的集合
    	|----HashSet、LinkedHasSet、TreeSet
|----Map 接口：双列集合、用来存储键值对，高中的函数
			|----HashMap、LinkedHasMap、TreeMap、HashTable、Properties
*/
```



#### Collection接口方法

API中的方法都讲，因为涉及容器的增删改查。看源码的前提是先会用，用会了再考虑去看源码的问题。

1. `contains()`会调用`obj`类对象的`equals`方法，所以，要求向Collection接口类的对象中添加数据`obj`时，要求伯爵穿梭在类要重写`equals`方法
2. `containsAll(Collection coll1)`：判断形参中的所有元素是否都存在于当前集合中。

#### Iterator迭代器接口

`Iterator`对象陈给迭代器，也是设计模式的一种。主要用于遍历`Collection`集合中的元素。GOF给迭代器模式的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需要暴力对象的内部细节。迭代器模式，就是为容器而生。 类似于，公交车上的售票员，火车上的乘务员、空姐

Iterator机用于遍历结合，Iterator本身并不提供装对象的能力。如果需要创建Iterator对象，必须有一个被迭代的集合。

用`hasNext()`和`next()`搭配`while`循环去遍历

开始的之后指针指在第一个元素的上面一个位置，一旦调了`next()`就将指针下移，并把下移后指的元素返回。



每次调用`iterator()`的时候都会返回一个新的迭代器。

内部定义了`remove`可以在遍历的时候删除集合中的元素。不同于直接调用集合中的元素。需要注意的是，如果没有掉过next就掉remove肯定会报错；另外，如果掉过next，然后掉了一次remove()又调一次remove()还是报错。

 

还有，迭代器接口主要是针对`Collection`，对`Map`遍历我们不用Iterator



增强for循环格式：`for(集合元素的类型 局部变量 : 集合对象)`

#### Collection子接口一：List

可以认为是动态数组，常用实现类是`ArrayList`、`LinkedList`和`Vector`。他们的异同如下
同：这三个类都实现了List接口，存储数据的特点相同：都是有序的，可重复的。
不同：
`ArrayList`：作为`List`接口的主要实现类，执行效率比较高，线程不安全。底层使用`Object[] elementData`存储
`LinkedList`：对于频繁的插入、删除操作，私用此类效率比`ArrayList`高。底层使用双向链表存储。
`Vector`：是List接口的古老实现类，从JDK1.0就有了，但是`List`接口是1.2才有的。线程安全的，效率低。底层使用`Object[]`存储



`ArrayList`源码分析

JDK 7 中

`ArraylList list - new ArrayList();`底层创建了一个长度为10的`Object[] elementData`

`List.add(123);`底层做的是`elementDate[0] = new Integer(1234);`

...

`List.add(11);`如果此次的添加导致底层的`elementData`数组容量不够，则扩容。

默认情况下扩容为原来的1.5倍，同时需要将原有数组中的数据复制到新的数组中

结论：建议开发中使用代餐的构造器`ArrayList list = new ArrayList(int capacity)`



JDK 8中

使用空参构造器时，第一次调add的时候才帮我们把数组初始化好了

---

July 2 2021



`LinkedList`源码分析

 `LinkedList list = new LinkedList();`内部声明了`Node`类型的`first`和`last`

#### Collection子接口二：Set

三个主要的实现类`HashSet`、`LinkedHashSet`和`TreeSet`，其中`HashSet`是`Set`接口的主要实现类，是线程不安全的，可以存储`null`值

`LinkedHashSet`作为`HsahSet`的子类；遍历其内部数据时，可以按照添加的顺序遍历。底层在添加数据的同时，每个数据还维护了两个引用。
优点：对于频繁便利的操作，`LinkedHashSet`执行效率要高

`TreeSet`：可以按照添加的对象的指定属性，进行排素。

如何去理解`Set`的无序性和不可重复性

1. 无序性：不等于随机性。存储的数据在底层数组中，并非按照索引的顺序添加。而是根据数据的哈希值决定的。
2. 不可重复性：保证添加的元素按照`equals()`判断是，不能返回`true`。即相同元素只能存一个

添加元素的过程，以`HashSet`为例：

1. 先算`Hash` 值，在用`Hash`找位置，如果不冲突，直接添加。如果冲突，看一下`Hash`值 是否相同
2. 如果`Hash`值相同，再调`equals()`，如果相同就不存了，如果不相同在数组位置上存一个列表，七上八下

我们像`HashSet`中添加元素`a`，首先调用元素`a`所在类的`hashCode()`方法， 计算元素`a`的哈希值，此哈希值接着通过某种算法计算出在`HashSet`底层数组中的存放位置（即索引位置），判断此数组位置上是否已经有元素：
如果没有其它元素，则元素`a`添加成功；---> 成功情况1

如果有其他元素`b`（或以链表形式存在的多个元素），则比较`a `与 `b`的`hash`值：
	如果`hash`值不同，则元素`a`添加成功。 ---> 成功情况2
	如果`hash`值相同，进而需要调用`a`所在类的`equals()`方法：
		如果`equals()`返回`true`，元素`a`添加失败

​		如果`equals()`返回`falst`，元素`a`添加成功---> 成功情况3

七上八下的含义：jdk7，元素`a`放在数组中，指向原来的元素。jdk8，原来的元素在数组中，指向`a`

`HashSet`底层是数组+链表的形式

31有什么特殊？离2的5次方32比较近，而且是个素数。

要用`HashCode`添加元素，其所在的类一定要重写`hashCode()`和`equals`，而且要尽量保证一致性

重写`hashCode()`的基本原则：

* 在程序运行时，同一个对象多次调用`hashCode()`方法应该返回相同的值
* 当两个怼心啊个的`equals()` 方法比较返回`true`的时候，这两个`hashCode()`也返回`true`
* 对象中用作`equals()`方法比较的`Field`，都应该用来计算`hashCode`

---

Here is June 8, 2021



### Day 24 集合

#### 每日一考

1. 集合Collection中存储的如果是自定义类的对象，需要自定义类重写哪个方法？为什么？

   `List`：`equals()`；`contains()/remove()/retainsAll()`
   `Set`: `equals()`，`hashCode()`这两个方法。在判断是否是重复的时候用到`hashCode()`。因为这两个方法在有序的`sort()`中要用到，`Set`的实现类，如果`HashSet `存储时就需要用到。`TreeSet`不一样的地方是它比较元素是否相同的方法变了，用`Comparable`接口或者是`Comparator`

2. `ArrayList`,`LinkedList`,`Vector`三者的相同点与不同点？
   都是`List`接口的实现类，存储数据的特点都是一样的，就是有序、可重复；
   不同点是：`ArrayList`是主要实现类，底层用数据实现，线程不安全，所以相对`Vector`来说效率较高；数组的因为有索引，所以按索引查询以及遍历操作都比较快；但频繁添加和删除时，效率不如`LinkdedList`

3. List 接口的常用方法有哪些？(增、删、改、查、插、长度、遍历)
   `add(Object ele)`、`addAll(Colletion elements)`
   `remove(int index)`、`remove(Object obj)`

   `set(int index, Object obj)`
   `at(int index)`:<span style="color:red;">`get(int index)`</span>
   `add(Object obj, int index)`
   `size()`
   `iterator()`

4. 如何使用Iterator和增强for循环遍历List。举例说明
   `for(Object obj : list1){ System.out.println(obj)}`

5. Set存储数据的特点是什么？常见的实现类有什么？说明一下彼此的特点。
   无序、不可重复；`HashSet`、`LinkedHashSet`、`ThreeSet`

关于`Set`元素存储的一道经典题：

```java
@Test
    public void test3(){
        HashSet set = new HashSet();
        Person p1 = new Person(1001,"AA");
        Person p2 = new Person(1002,"BB");

        set.add(p1);
        set.add(p2);

        System.out.println(set);//两个元素
        p1.name = "CC";
        set.remove(p1);
        System.out.println(set);//还是两个元素
        set.add(new Person(1001,"CC"));
        System.out.println(set);//三个元素
        set.add(new Person(1001,"AA"));
        System.out.println(set);//四个元素

    }
```



#### Map接口

1. `Map`实现类的结构：

```java
/*
Map:双列数据；存储key-value对的数据 
	|---HashMap:作为Map的主要实现类; 线程不安全的，效率高；存储null的key和value
		|---LinkedHashMap:保证在遍历map元素是，可以按照添加的顺序实现遍历。
					原因：在原有的HashMap底层结构上添加了一对执行，指向前一个元素和后面一个元素。对于频繁的遍历操作，此类执行效率高于HashMap
  |---TreeMap:
  |---Hastble:作为Map的古老实现类;1.0就有；线程安全，效率低，不能存储null的key和value
  	|---Properites:常用来处理配置文件，key和value都是String类型的
	
*/
```

`HashMap`的底层：数据+链表（jdk7及之前）、jdk8之后，数组+链表+红黑树

`HashMap`与`Hashtable`的异同

2. `Key-Value`的特点：
   `key`就是`Set`：无序，不可重复，使用`Set`存储所有的`key` 
   -->`key`所在类要重写`equals()`和`hashCode()`方法（此时以`HashMap`为例）
   `value`的特点是：无序，可重复，并没有这样一个结构，就泛泛的说是`Collections`存储的

   -->value所在的类要重写`equals()`方法。
   其实`put(k,v)`的时候，自动包装成了`entry`，也是无序、不可重复的，也是`Set`

   

3. 面试题：`HashMap`的底层实现原理？需要关注源码

先说`JDK7`为例说明
HashMap map = new HashMap()

在实例化以后，此层创建了一个长度是16的一维数组`Entry[] table;`
。。。可能已经执行过多次`put()`

`map.put(key1,value1)`

首先，调用`key1`所在类的`hashCode()`计算`key1`哈希值，此哈希值经过某种算法计算以后，得到在`Entry`数组中的存放位置。
如果此位置上的数据为空，此时的`key1-value1`添加成功。

如果此位置上的数据不为空，（意味着此位置上存在一个或多个数据（以链表形式存在）），比较`key1`和已存储在的一个或多个数据的哈希值：
	如果`key1`的哈希值与已经存在的数据的哈希值都不相同，此时的`key1-value1`添加成功。

​	如果`key1`的哈希值和已经存在某个的数据(`key2-value2`)的哈希值相同，则继续比较：调用`key1`所在类的`equals()`方法，比较：

​			如果`equals`返回`false`此时`key1-value1`添加成功

​			如果`equals`返回`true` ，使用`value1`替换相同`key `的value值，`value2`

在不断的添加过程中，会涉及到扩容问题，默认的扩容方式：扩容为原来的2倍，并将原来的数据复制过来。

扩容的条件：超过临界值且要存的位置非空。

jdk8 相较于jdk7在底层是想方面的不不同：

* new HashMap()：底层没有创建一个长度为16的数组
* jdk8 底层数组是`Node[]`而非`Entry[]`
* 首次调用`put()`是，底层创建长度为16的数组
* jdk7底层只有数组+链表，jdk8中，底层有数组+链表+红黑树。
  * 当数组的某一个索引位置上的元素以链表形式存在的数据个数>8，且当前数组的长度>64时，此时索引位置上的所有数据改为用红黑树存储。

4. `Map`接口中定义的方法
   有很多，但是常用的还是：
   添加：`put(Object key, Object value)`
   删除：`remove(Object key)`
   修改：`put(Object key, Ojbect value)`
   查询：`get(Object key)`
   长度：`size()`
   遍历：`keySet()`、`values()`、`entrySet()`、

#### Collections工具类

 `Collections.synchronizedXxx()`返回的就是线程安全的

Nichlaus Wirth：

程序能否快速而高效地完成预定的任务，取决于是否选对了数据结构，而程序是否能清楚而正确地把问题解决，则取决于算法。

算法是为了解决实际问题而设计的，数据结构则是算法需要处理的问题载体



---

Here is July 12, 2021

### Day 25 泛型

#### 每日一考

1. Map存储数据的特点是什么？并指明key，value，entry存储数据的特点。
   无序，不可重复，一对一对的
2. 描述HashMap的底层实现原理(jdk 8版)
   数组+链表+红黑树：
3. Map中常用实现类有哪些？各自有什么特点？
   `HashMap`
   `LinkedHashMap`、
4. 如何遍历Map中的key-value对，代码实现
5. Collection和Collections的区别？

#### 为什么要有泛型

<span style="color:red;">泛型</span>一定程度上可以理解为<span style="color:red;">标签</span>，超市架子上有很多瓶子，每个瓶子装的是什么，有标签

集合容器类咋四核机阶段，声明阶段不能确定这个容器到底实际存的是什么类型的。JDK 1.5之前只能把元素类型设计为`java.lang.Object`，之后用泛型来解决

把元素的类型设计成一个参数，这个类型参数就叫泛型。

`Collection<E>`、`List<E>`、`ArrayList<E>`中的`<E>`就是<span style="color:red;">类型参数</span>

```java
泛型就是允许在定义类、接口时，通过一个标识表示类中的么讴歌属性的类型，或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）
```

1. 集合接口和集合类在jdk5.0时都修改为带泛型的结构
2. 在实例化集合类时，可以指明具体的泛型类型
3. 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性）使用到累的泛型的位置，都指定为实例化的泛型类型。
4. 注意点：泛型的类型必须时一个类。
5. 如果实例化时，没有指明泛型的类型，默认类型为`java.lang.Object`

如何使用泛型

#### 在集合中使用泛型

多看API体会体会就行

#### 自定义泛型

1. 泛型类可以有多个参数，用逗号隔开，比如`Entry<K,V>`
2. 声明构造器的时候不用尖括号`public GenericClass(){}`
   下面是错的`public GenericClass<E>(){}`
3. 实例化后，操作原泛型位置的结构必须与制定泛型类型一致。
4. 泛型不同的引用不能互相引用。
   `ArrayList<Integer> list1 = new ArrayList<Integer>();`
   `ArrayList<String> list2 = new ArrayList<String>();`
   此时`list1 = list2`或者`list2 = list1`都报错
5. 泛型如果不指定，将被擦出，泛型对应的类型均按照`java.lang.Object`出力，但不等价于`Object`（体现在继承上）
   经验之谈：泛型，要么都用，要么都不用，不要mix
6. 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象
7. jdk，泛型的简化操作：`ArrayList<Fruit> first = new ArrayList<>();` JDK7新特性，类型推断
8. 泛型的指定中不能使用基本数据类型，可以使用包装类
9. 静态方法中不能使用类的泛型。
10. 异常类不能使用泛型。
11. 如果需要`new`一个泛型类型的数组。
    `T[] arr = new T[10];`编译不通过，要这样写
    `T[] arr = (T[]) new Object[10];`

#### 泛型在继承上的体现

`List<Object>`和`List<String>`完全不具备子父类的关系。

但是，什么可以呢？就是如果`List<Object>`和`ArrayList<Object>`是可以的

#### 通配符的使用

1. `<?>`就是通配符，后面数据库里面还会出现叫作占位符
   `A extends B`但是`G<A>`和`G<B>`没有子父类关系，二者共同的父类是`G<?>
2. 有限制条件的通配符：
   `? extends A`：`G<? extends A>`可以作为`G<A>`和`G<B>`的父类，其中`B`是`A`的子类
   `? super A`：`G<? super A>`可以作为`G<A>`和`G<B>`的父类，其中`B`是`A`的父类

#### File类的使用

`java.io.File`的对象就代表一个类或者一个文件目录

1. 如何创建`File`类的示例
2. 相对路径:相较于某个路径下， 指定目的路径。
   绝对路径:包含盘符(Windows)在那的路径
3. seperator路径分隔符

常用方法：

`public boolean renameTo(File dest)`：把文件重命名为指定的文件路径，`file1.renameTo(file2)`为例

要想保证返回`true`，需要`file1`在硬盘中是存在的，但是`file2`是不能在硬盘中存在的

### Day 26 IO流

#### 每日一考

1. 如何遍历`Map`的`key`集、`value`集、`key-value`集、使用上泛型

   ```java
   Map<Integer,String> map = new HashMap<>();
   Set<Integer> keys = map.getKeys();//This is wrong the correct method name is ketSet()
   List<String> values = map.getValues();// This is also wrong the correct method name is values()
   Set<Map.Entry<Integer,String>> entries = map.getEntry();//This again is wrong, the correct method name is entrySet();
   
   ```

   

2. 写出使用`Iterator`和增强`for`循环遍历`List<String>`的代码，使用上泛型

   ```java
   List<String> list = new ArrayList<String>();
   Iterator iterator = list.iterator();
   while(iterator.hasNext()){
     System.out.println(iterator.next());
   }
   for(String str: list){
     System.out.println(str);
   }
   ```

   

3. 提供一个方法，用于遍历获取`HashMap<String,String>`中的所有`value`，并存放在`List`中返回，考虑上集合中泛型的使用。

   ```java
   @Test
   public void test(){
     Map<String,String> map = new HashMap<String,String>();
     List<String> res = new ArrayList<String>();
     Collection<String> raw = map.getValues();
     for(String str : raw ){
       res.add(str);
     }
     return res;
   }
   ```

   

4. 创建一个与a.txt文件同目录下的另外一个文件b.txt

   ```java
   File fileA = new File("a.txt");
   if(fileA.exists)
     File dir = fileA.getParent();
   File fileB = new File(dir,"b.txt");
   fileB.create();
   ```

   

5. Map接口中的常用方法有哪些

   ```java
   增：put(K,V);
   删：remove(K k);
   改：put(K k, V v);
   查：V get(K k);
   长度：int size();
   遍历：Set<K> keySet();
   Collection<V> values();
   Set<Map.Entry<K,V>> entrySet();
   containsKey();
   containsValue();
   isEmpty();
   get(Key);
   ```

#### IO流原理及流的分类

1. I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通信等
   Java程序中，对于数据的输入/输出操作以 `stream`的方式进行。
   java.io包下提供了各种流类和接口，泳衣获取不同种类的数据，并通过标准的方法输入和输出数据

2. 输入和输出是相对的概念，要从站在内存的角度思考这个问题
   输入input：读取外部数据（磁盘、光盘等存储设备中）到程序（内存）中。
   输出output：将程序（内存中）数据存储到外部设备中

3. 按照操作数据单位的不同，分为：字节流(8 bit / 1 byte)和字符流(16 bit / bytes)
   按流的角色不同，分为：节点流（直接插在节点上的），处理流（包在节点流外面的）

4. 四个抽象基类

   | (抽象基类) | 字节流         | 字符流   |
   | ---------- | -------------- | -------- |
   | 输入流     | `InputStream`  | `Reader` |
   | 输出流     | `OutputStream` | `Writer` |

   
